---
layout: post
author: LIU,HONGYANG
tags: [面试]
---

## 交叉科技面试题：

**Machine Learning and statistics (可以用中文或英文答题)**

1. What is overfitting? How to prevent overfitting (in both traditional method and deep learning)?

2. Here is the confusion matrix:

![image-20201014213636385](https://tva1.sinaimg.cn/large/007S8ZIlgy1gjp6wcd5r1j30dw0bw0v2.jpg)

 

Show how to compute precision and recall from these four values.

 

设想这样一个量化交易的预测任务，我们希望每个交易信号都尽量盈利。在这个任务里，我们首先需要优化的precision还是recall？为什么，请提供理由。

设想这样一个风险预警任务。风险事件并不经常发生。我们十分害怕风险，希望躲过所有风险。我们需要每天提供预警信号。在这个任务里，我们首先需要优化的precision还是recall？为什么，请解释。



3. 假设你做了一个机器学习模型上线了。每天业务部门产生很多数据，然后你的算法把这些数据进行收集，并制作成特征，然后通过机器学习算法进行预测。但是最近一个月你突然发现你的模型效果变差了很多。请写出你计划从哪些方面，运用何种数据分析或其他办法进行诊断。

 

4. 美国就要大选了。假设公司做了一个民调的网站，来抽样统计一下目前民主党和共和党的支持比例。但是公司有人后来发现访问这个网站的人70%是年轻人，其他年龄段也都有，但是相对比较少。这个比例和真实人口比例不同。另外还发现西海岸的州人数偏多，其他州人相对少，这个比例也和真实人口比例非常不同。假设年龄和州这两个特征是决定民主党和共和党支持比例的最重要因素。请设计一个合理的统计方法，能够更准确的估计美国全国人口真实的支持比例。





## 编程题：

1. 输入一个10进制数字，输出这个数8进制表示

例子：

输入： 10

输出： 12



```java
public class Code {
    public static void main(String[] args) {
        Code code = new Code();
        code.decimalToOctal(10);
    }

    public void decimalToOctal(int k){
        int d, s = 0, c = 0;


        while (k != 0) {
            d = k % 8;
            s += d * (int) Math.pow(10, c++);
            k /= 8;
        }

        System.out.println("Octal equivalent:" + s);
    }

}
```



![WechatIMG784](https://tva1.sinaimg.cn/large/007S8ZIlgy1gjp707hxjej30tk0aa3zg.jpg)





2. 给定一个矩阵，找出从左上到右下角的一条路，使得这条路上数字和最大。这条路前进的方向只能向右或向下。输入的第一行是矩阵的行数和列数。输出第一行是一个序列，为该条路上的数字，第二行是这些数字的和。



例子

输入：

3 3



1 4 3

2 3 1 

2 3 4 

输出

1 4 3 3 4

15



```java
import java.util.ArrayList;
import java.util.Arrays;

public class Code {
    public static void main(String[] args) {
        Code code = new Code();

        int[][] grid = {{1,1,1,1,2},{2,3,4,1,4},{3,1,4,2,4},{2,1,5,7,2},{4,3,3,4,5}};
        int value = code.maxPathSum(grid);
        System.out.println("最大值"+value);


    }
    //1代表结果从左边加过来，0代表从上边加过来
    public int maxPathSum(int[][] grid) {


        int rowLength = grid.length;

        if(rowLength==0){
            return 0;
        }

        int columnLength = grid[0].length;

        int dp[][] = new int[rowLength][columnLength];

        int[][]  path= new int[rowLength][columnLength];


        dp[0][0] = grid[0][0];

        //计算第一行的值，path都为1
        if(columnLength>=1){
            for(int i=1;i<columnLength;i++){
                dp[0][i] = dp[0][i-1]+grid[0][i];
                path[0][i] = 1;
            }
        }

        //计算第一列的值，path都为0
        if(rowLength>=1){
            for(int i=1;i<rowLength;i++){
                dp[i][0] = dp[i-1][0] + grid[i][0];
                path[i][0] = 0;
            }
        }

        for(int i=1;i<rowLength;i++){
            for(int j=1;j<columnLength;j++){

                int direction = dp[i][j-1] > dp[i-1][j] ? 1 : 0;
                dp[i][j] = Math.max(dp[i-1][j]+grid[i][j],dp[i][j-1]+grid[i][j]);
                path[i][j] = direction;

            }
        }



        ArrayList<Integer> arrayList = new ArrayList<>();
        arrayList.add(grid[rowLength-1][columnLength-1]);

        for(int i=rowLength-1;i>0;){
            for(int j=columnLength-1;j>0;){

                if(path[i][j]==1){
                    arrayList.add(grid[i][j-1]);
                    j--;
                    i = i;

                }

                if(path[i][j]==0){
                    arrayList.add(grid[i-1][j]);
                    i--;
                    j = j;
                }

                if(i==0&&j==0){
                    break;
                }
            }
        }


        System.out.print("路径：");
        for(int i=arrayList.size()-1;i>=0;i--){
            System.out.print("--->"+arrayList.get(i));
        }

        return dp[rowLength-1][columnLength-1];

    }



}
```







![WechatIMG786](https://tva1.sinaimg.cn/large/007S8ZIlgy1gjp71dklx9j30ts0bywfi.jpg)



![WechatIMG788](https://tva1.sinaimg.cn/large/007S8ZIlgy1gjp71mg2ipj31320aoq4a.jpg)



3. 一个**自重复串**是一个字符串，其前一半和后一半是一样的，例如 abcdbabcdb （长度一定是偶数）。

输入一个字符串，找出其中最长的**自重复子串。这里的子串要求连续。**



例子

输入：

abababcdabcd

输出：

abcdabcd



```java
import java.util.ArrayList;
import java.util.Arrays;

public class Code {
    public static void main(String[] args) {
        Code code = new Code();

        String str = "faaacabcddcbabcddcbedfgaac";

        System.out.println("最大值"+code.maxLongestStirng(str));


    }
    //1代表结果从左边加过来，0代表从上边加过来
    public String maxLongestStirng(String str) {
        //求所有子串
        ArrayList<String> list = new ArrayList<>();

        for(int i = 0; i < str.length(); i++){
            for (int j = i+1; j<=str.length(); j++){
                if((j-i)%2==0){
                    list.add(str.substring(i,j));
                }
            }
        }

        //求所有重复子串
        ArrayList<String> list2 = new ArrayList<>();

        for(int i=0;i<list.size();i++){

            String string = list.get(i);

            int j = 0;
            int h = string.length()/2;

            int k = h;
            boolean flag = true;

            while (j<h&&k<string.length()){

                if(string.charAt(j++)==string.charAt(k++)){
                   continue;
                }
                else{
                    flag =false;
                    break;
                }

            }

            if (flag==true){
                list2.add(string);
            }

        }

        String s = "";
        for(String str2:list2){

            if(str2.length()>s.length()){
                s = str2;
            }
        }


        return s;

    }



}
```



![WechatIMG800](https://tva1.sinaimg.cn/large/007S8ZIlgy1gjp72eexz1j30xy0ewwfp.jpg)



4. 输入一个无向图邻接矩阵A（Aij=1代表i点和j点相连，0代表不相连）。输出这个图的联通分量的个数（一个联通分量就是一个子图，该子图每两个点间都可以有路径到达）。输入第一行是这个图点的个数。











## 测试用例：

输入：

5

0 1 1 0 0

1 0 1 0 0 

1 1 0 0 0

0 0 0 0 1

0 0 0 1 0

输出

2





测试用例：



编程题
一题测试
输入：1000000
二题测试：
输入：
5 5
1 1 1 1 2
2 3 4 1 4
3 1 4 2 4
2 1 5 7 2
4 3 3 4 5
三题测试
输入
faaacabcddcbabcddcbedfgaac
四题测试输入：
7
0 1 0 0 0 1 0
1 0 0 0 0 0 0
0 0 0 1 1 0 0
0 0 1 0 1 0 0
0 0 1 1 0 0 0
1 0 0 0 0 0 1
0 0 0 0 0 1 0