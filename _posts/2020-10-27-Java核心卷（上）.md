---
layout: post
author: LIU,HONGYANG
tags: [Java]
---





# 第1章 Java程序设计基础



本章主要讲述JAVA的特性：

Java主要用于服务器端和跨平台客户端应用领域。

| 特性         | 解释                                                         |
| ------------ | ------------------------------------------------------------ |
| 简单性       | 适用于C++-，提出了许多C++中不合理的特性。                    |
| 面向对象     | Java面向对象，与C++不同的是不具备多重继承                    |
| 分布式       | Java可以通过URL访问资源                                      |
| 健壮性       | Java编译器能够检测许多在其他语言中仅在运行时才能检测出来的问题 |
| 安全性       | 运行时堆栈溢出                                               |
| 体系结构中立 | 字节码与平台无关                                             |
| 可移植性     | 跨平台                                                       |
| 解释性       | 解释性语言                                                   |
| 高性能       | 解释字节码                                                   |
| 多线程       | 支持并发编程                                                 |
| 动态性       | 反射                                                         |



# 第2章 Java程序设计环境



对于Java程序，我们一般会下载JDK

![image-20200926110753997](https://tva1.sinaimg.cn/large/007S8ZIlgy1gj3vkkjdnzj314s0h0n95.jpg)



而对于开发者，需要的是JDK, JRE的话不包含编译器。



Java的集成环境



![image-20200926111755794](https://tva1.sinaimg.cn/large/007S8ZIlgy1gj3vuyjphvj30rs0im15w.jpg)



JDK结构



![Screenshot 2020-09-26 at 11.16.51](https://tva1.sinaimg.cn/large/007S8ZIlgy1gj3vvfnr1uj315k0hygq6.jpg)





JRE结构



![Screenshot 2020-09-26 at 11.17.03](https://tva1.sinaimg.cn/large/007S8ZIlgy1gj3vwpj9luj315o04qwf6.jpg)





# 第3章 Java的基本程序设计结构



## 3.1 一个简单的Java应用程序



```java
public class FirtstSample
{
	public staitc void main(String[] args)
	{
		System.out.println("We will not use 'Hello World'");
	}

}
```



- 首先Java区分大小写

- 关键字public为访问修饰符

- Java类名命名规范：（驼峰命名法）

  

![image-20200926122730145](https://tva1.sinaimg.cn/large/007S8ZIlgy1gj3xvc8gqkj316i08a75g.jpg)



- 根据Java语言规范，main方法必须声明为public



## 3.2 注释



三种注释方式：

第一种：//

第二种：/* */

第三种：/** */



## 3.3 数据类型



Java是一种强类型语言。这就意味着必须为每一个变量声明一种类型。

在Java中，一共有8种基本数据类型(Primitive type)，其中4种整型、2种浮点类型、1种表示Unicode编码的字符单元的字符类型char和1种用于表示真值的boolean类型。



### 3.3.1 整型



![image-20200926131334949](https://tva1.sinaimg.cn/large/007S8ZIlgy1gj3z7aakcgj314e09277k.jpg)



java中所有的数值类型所占据的字节数量与平台无关。



**注意 Java中没有任何无符号(unsigned) 形式的int、long、short或byte类型。**



- 数字字面量下划线

- 二进制数



```java
package chapter1;


public class demo01 {

    public static void main(String[] args) {
        int a = 20_0000_0000;
      	//数字字面量下划线
        System.out.println(a);
      	//二进制数
        System.out.println(0b1001);
    }
}

```





### 3.3.2 浮点类型



浮点类型用于表示有小数部分的数值。

![image-20200926132527463](https://tva1.sinaimg.cn/large/007S8ZIlgy1gj3zjn2npij314q074419.jpg)

double表示这种类型的数值精度是float类型的两倍。



```java
 float a= 2.0F;
 float a= 3.0f;
```

只有很少的情况适合float类型，例如，需要单精度数据的库，或者需要存储大量数据。



注意，默认情况是double类型，需要使用float类型的数值时需要加一个后缀F或f

如果在数值计算中不允许有任何舍入误差，就应该使用BigDecimal类。



### 3.3.3 char类型

char类型的字面量值要用单引号扩起来。例如，'A'是编码值为65说对应的字符常量。它与"A"不同。



需要注意的是，Unicode转义序列会在解析代码之前得到处理。例如，"\u0022+\u0022"并不是一个由引号(U+0022)包围加号构成的字符串。

实际上， \u0022会在解析之前转换为"





### 3.3.4 Unicode和char类型

unicode打破了传统字符编码机制的限制。



### 3.3.5 boolean类型



boolean类型有两个值，用来判定逻辑条件。整型值和布尔值之间不能进行相互转换。





## 3.4 变量

在Java中，变量的大小写敏感。

变量名必须是一个以字母开头并由字母或数字构成的序列。

需要注意的是，Java中字母或数字表示的含义和我们想象的并不同：

字母包括'A'~'Z'、 'a'~'z'、 '_'、 '$'

数字包括0~9

不能有空格。

另外可以使用Character类中的isJavaIdentifierStart和isJavaIdentifierPart方法来检验字母。



### 3.4.1 变量初始化

Java中，不区分变量的声明与定义。但是声明一个变量之后，必须用赋值语句堆变量进行显式初始化。



```java
int vacationDays;
System.out.println(vacationDays);
```





### 3.4.2 常量

Java中，关键字final表示这个变量只能被赋值一次。

一旦被赋值之后，就不能够再被更改了。习惯上，常量名使用全大写。

例如

```java
package chapter1;


public class demo01 {

    public static void main(String[] args) {
        final double CM_PER_INCH = 2.54;
        double paperWidth = 8.5;
        double paperHeight = 11;
        System.out.println(CM_PER_INCH*paperHeight);
    }

}
```





https://zhuanlan.zhihu.com/p/30152824



**类常量**

在Java中，经常希望某个常量可以在一个类中的多个方法中使用，通常将这些常量称为类常量。可以使用关键字static final设置一个类常量。



```java
public class demo02 {
    public static final double CM_PER_INCH = 2.55;
    public static void main(String[] args) {
        double paperWidth = 8.5;
        double paperHeight = 11;
        System.out.println("Paper size in centimeters "+paperHeight*paperHeight);
    }
}
```



**Java静态变量与常量：**

static修饰的成员变量和成员方法习惯上称为静态变量和静态方法。

特点：静态变量在内存中只有一个拷贝（节省内存），JVM只为静态分配一次内存.在加载类的过程中完成静态变量的内存分配。可以使用类名直接访问。



**Java常量**

使用final修饰的变量，一旦赋值，不能被再次更改。否则编译器就报错。



**final关键字**

方法前面加上final关键字，代表这个方法不可以被子类的方法重写。

类名前面加上final关键字，代表这个方法不可以被继承。

final关键字可以用于成员变量、局部变量、方法及类。

final关键字必须在声明中初始化，或者在构造器中初始化，否则就会报错。

不能对final再次赋值

在匿名类中所有变量都必须是final变量.

final方法在编译阶段绑定, 称为静态绑定(static binding).



```java
public class demo02 {
    public final double CM_PER_INCH ;

    public demo02(double a){
        this.CM_PER_INCH =a;
    }
    
    public static void main(String[] args) {
        double paperWidth = 8.5;
        double paperHeight = 11;
    }
}

```



## 3.5 运算符



### 3.5.1 数学函数与常量

常见的Math类方法：

Math.sqrt(x); Math.pow(x,y);

两个用于表示数学常量的量：

Math.PI

Math.E



Math库来源于

```
import static java.lang.Math.sqrt;
```



### 3.5.2 数值类型之间的转换



**隐式的强制转换**

实心表示信息无丢失，而虚箭头表示信息可能会被丢失。箭头的方向表示的是隐式的强制转换方向。

![image-20200926232620714](https://tva1.sinaimg.cn/large/007S8ZIlgy1gj4gwwx2uyj30ss0jsakn.jpg)

操作数的优先级：n+f (n是整数，f是浮点数)

- 如果两个操作数有一个是double类型，另一个操作数就会转换为double类型。
- 否则，如果其中一个操作数是float类型，另一个操作数将会转换为float类型。
- 否则，如果其中一个操作数是long类型，另一个操作数将会转换为long类型。
- 否则，两个操作数都将被转换为int类型。



**显式的强制转换**



强制类型是精度高的转化为低的类型，在这种情况下可能会丢失信息。

我们需要通过强制类型转换(cast)实现这个操作。

如果想对符点数进行舍入运算，以便得到最接近的整数，那就需要使用Math.round方法：

```java
double x = 9.997;

int nx = (int)Math.round(x);
```



变量nx的值为10，当调用round的时候，仍然需要使用强制类型转换(int)。因为round方法返回结果为long类型，可能存在信息丢失的可能性，所以只有使用显式的强制类型转换才能够将long类型转换成int类型。



### 3.5.3 结合赋值和运算符



```
x+=4;等驾驭x =x +4;
```



### 3.5.4 自增与自减运算符

前缀形式会先完成加1；而后缀形式会使用变量原来的值。



```java
public class demo03 {

    public static void main(String[] args) {
       int m =7;
       int n =7;
       int a = 2*++m;
       int b = 2*n++;
        System.out.println(a);
        System.out.println(b);

    }
}

```



### 3.5.5 关系和boolean运算符



`expression1 && expression2`

如果第一个表达式的真值位false, 那么结果就不可能为true。因此第二个表达式就不必计算了。

类似地，

如果第一个表达式为true，`expression1 || expression2` 的值就为true，而无需计算第二个表达式。

最后，Java支持三元操作符 ？：

`condition1?expression1:expression2`



### 3.5.6 位运算符



| and  | or   | xor  | not  |
| ---- | ---- | ---- | ---- |
| &    | \|   | ^    | ~    |





```java
public class demo04 {
    public static void main(String[] args) {

        int a = 32;//1000
        System.out.println((a&0b1000)/0b1000);
    }
}

```



**算术位移：**

另外，还有>> 和<<运算符位模式左移或右移。需要建立位模式来完成位掩码时，这两个运算符久很方便。

```java
int fourthBitFromRight = (n&(1<<3)>>3);
```



**逻辑位移：**

最后，>>>运算符会用0填充高位，这与>>不同，它会用符号位填充高位。

不存在<<<运算符。



### 3.5.7 括号与运算符级别



Java运算符的结合性分为两种：一种是从左到右结合，一种是从右向左。

例如： 

a&&b||c等价于(a&&b)||c

a+=b+=c等价于

a+=(b+=c)



运算优先级表

需要注意的是位运算，例如, ^ | &的运算级别很低，避免使用的时候出错。

![image-20200927132258497](https://tva1.sinaimg.cn/large/007S8ZIlgy1gj57br1s9vj310u09s0vh.jpg)



![image-20200927132312838](https://tva1.sinaimg.cn/large/007S8ZIlgy1gj57bs4zaij311s0bqwgy.jpg)





### 3.5.8 枚举类型



 枚举类型包括有限个命名的值。包括null.

```java
import java.lang.Math;

import static java.lang.Math.floorMod;
import static java.lang.Math.sqrt;

public class demo02 {

    enum Size{
        Small,Medium,Large,Extra_Large;
    }

    public static void main(String[] args) {
        //可以放入int, char, String;
        Size size = Size.Small;

        switch (size){
            case Large:
                System.out.println("Suitable for Adults");
                break;
            case Small:
                System.out.println("Suitable for Child");
                break;
            default:
                System.out.println("Try again!");
                break;
        }


    }
}

```





## 3.6 字符串

### 3.6.1 子串



Java字符串就是Unicode字符序列。Java没有内置的字符串类型，而是在标准Java类库中提供了一个预定义类，很自然地叫做String。每个用



```java
String greetings =“Hello”;
String s = greeting.substring(0,3);
```

substring方法的第二个参数是不想复制的第一个位置。这里要复制位置为0、1和2（从0到2，包括0和2）的字符。在substring中从0开始计数，直到3为止，不包括3.



### 3.6.2 拼接

+号与String.join()



Java语言允许使用+号连接（拼接）两个字符串。

如果需要把多个字符串放在一起，用一个定界符分隔，可以使用静态join方法：

```java
public class demo04 {
    public static void main(String[] args) {

        String all = String.join("qqqq","1","2","3");
        System.out.println(all);

    }
}

```



输出结果为:

```java
1qqqq2qqqq3
```



### 3.6.3 不可变字符串



String类没有提供用于修改字符串的方法。但是可以使用提取与拼接的方法

```java
greeting = greeting.substring(0,3)+"p!";
```



String类对象称为不可变字符串。编译器可以让字符串共享。







### 3.6.4 检测字符串是否相等

在Java中使用equals检测字符串是否相等

equalsIgnoreCase()方法可以检测两个字符串是否相等，而不区分大小写。

例如

```java
"Hello".equals(greeting)
"Hello".equalsIgnoreCase("hello");

```



一定不要使用==运算符检测两个字符串是否相等！



或通过如下方法检测Java的值是否相等：

```java
if(a.compareTo(b)==0){
            System.out.println();
}
```



### 3.6.5 空串与Null串



String变量还可以存放一个特殊的值，名为null.这表示没有任何对象与该变量关联。

检查一个字符串既不是null也不是空串，需要使用如下方法：

```java
if(str!=null&&str.length()!=0)
```



### 3.6.6 码点与代码单元



在java中可以返回第i个代码单元，例：

```java
s.charAt(n)
```

n介于0 ~ s.lenght()-1之间



### 3.6.7 String API



常用的String API

![image-20200927152831402](https://tva1.sinaimg.cn/large/007S8ZIlgy1gj58q1z474j30zu0nmk3o.jpg)



![image-20200927152910055](https://tva1.sinaimg.cn/large/007S8ZIlgy1gj58qosm7oj30j00q647m.jpg)



### 3.6.8 构建字符串



有时候，构建较短的字符串时，使用字符串连接的方式效率会很低。每次连接字符串，都会创建一个新的String对象，既耗时，又浪费时间。

使用StringBuilder类可以避免这个问题的发生，

首先构建一个空的字符串构造器，

当每次需要添加一部分内容时，就调用append方法

最后使用toStirng() 方法构建字符串

```java
StringBuilder builder = new StringBuilder();
builder.append(ch);
builder.append(str);
String completeString = builder.toString();
```



**StringBuilder API**

![image-20200927153136352](https://tva1.sinaimg.cn/large/007S8ZIlgy1gj58t7djjkj30x00qgn95.jpg)

**StringBuilder和StringBuffer的区别**



StringBuilder类和StringBuffer类最主要的区别是，StringBuilder是线程不安全的，但是效率比较高；

而StringBuffer允许采用多线程的方式执行添加或删除字符的操作。





## 3.7 输入输出





### 3.7.1 读取输入



要想读取一个整数，就调用nextInt方法。

与此类似，要想读取下一个浮点数，就调用nextDouble方法。

```java
import java.util.Scanner;

public class demo04 {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.println("What is your name?");
        String name = scanner.nextLine();

        System.out.println("What is your age?");
        int age = scanner.nextInt();
        
        System.out.println(name);
        System.out.println(age);
    }
}

```



因为输入是可见的，所以Scanner类不适合从控制台读取密码。



```java
package chapter1;

import java.io.Console;

public class demo05 {
    public static void main(String args[]){
        Console c=System.console();
        System.out.println("Enter your name: ");
        String n=c.readLine();
        System.out.println("Welcome "+n);
    }
}

```



![image-20200927163458665](https://tva1.sinaimg.cn/large/007S8ZIlgy1gj5an5h4xgj30n00moqbl.jpg)





### 3.7.2 格式化输出



Java中继承了 C语言库函数中的printf方法。



f表示浮点数，s表示字符串，d表示十进制整数。

![image-20200927164044182](https://tva1.sinaimg.cn/large/007S8ZIlgy1gj5at5euksj30y40d4n2j.jpg)





### 3.7.3 文件输入与输出

想要对文件进行读取，就需要一个用File对象构造一个Scanner对象，

```java
Scanner in = new Scanner(new File(""),"UTF-8");
```



读取代码：

```java
import com.sun.scenario.effect.impl.sw.sse.SSEBlend_SRC_OUTPeer;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.PrintWriter;
import java.io.UnsupportedEncodingException;
import java.util.Scanner;

public class demo05 {
    public static void main(String[] args) throws FileNotFoundException, UnsupportedEncodingException {
        Scanner in = new Scanner(new File("/Users/liuhongyang/Desktop/newFile.txt"));
        System.out.println( in.nextLine());

    }
}

```



![image-20200927165424865](https://tva1.sinaimg.cn/large/007S8ZIlgy1gj5b7dd6fzj30w60eqjzk.jpg)



写入代码：

```java
import com.sun.scenario.effect.impl.sw.sse.SSEBlend_SRC_OUTPeer;

import java.io.*;
import java.util.Scanner;

public class demo05 {
    public static void main(String[] args) throws IOException {
        Scanner in = new Scanner(new File("/Users/liuhongyang/Desktop/newFile.txt"));
        PrintWriter out = new PrintWriter("/Users/liuhongyang/Desktop/File.txt");
        out.write("11");
        out.println(1);
        out.flush();
        out.close();
    }
}

```



## 3.8 控制流程



与任何程序设计语言一样，Java使用**条件语句**和**循环结构**确定控制流程。Java的控制流程中没有got to语句，但break语句可以带标签。



### 3.8.1 块作用域



块确定了变量的作用域。一个块可以嵌套在另一个块中。

Java不能在嵌套的两个块中声明同名的变量。

![image-20200927180846701](https://tva1.sinaimg.cn/large/007S8ZIlgy1gj5dcr6fc9j31420auq4e.jpg)



### 3.8.2 条件语句

在Java中，条件语句的格式为

```java
if(condition) statement
```

在Java中，else部分是可选的，else子句与最邻近的if构成一组。

```java
if(condition) statement1 else statement2
```



### 3.8.3 循环

但条件为true时，while循环执行一条语句

```java
while(condition) statement
```

![image-20200927182029357](https://tva1.sinaimg.cn/large/007S8ZIlgy1gj5doxr7nvj30h00tgn84.jpg)







若希望循环语句首先检测循环条件。循环体至少执行一次，则应该将检测条件放在最后。

```
do statement while(condition);
```



![image-20200927182052922](https://tva1.sinaimg.cn/large/007S8ZIlgy1gj5dpci8jzj30ha0usakx.jpg)



### 3.8.4 确定循环



for循环语句是支持迭代的一种通用结构，利用每次迭代之后更新的计数器或类似的变量来控制迭代次数。

```java
for(int i=1;i<=10;i++) System.out.println(i);
```

![image-20200927195110641](https://tva1.sinaimg.cn/large/007S8ZIlgy1gj5gbabe28j30ci0megrv.jpg)



for语句的第1部分通常用于对计数器初始化；第2部分给出每次新一轮循环执行前要检测的循环条件；第3部分指示如何更新计数器。



for循环语句只不过是while循环的一种简化形式：

```java
for(int i=10;i>0;i--) System.out.println("Counting down ..."+i);
```



可以重写为:

```java
int i = 10;
while(i>0)
{
	System.out.println("Counting down"+i);
	i--;
}
```









![image-20200927200713118](https://tva1.sinaimg.cn/large/007S8ZIlgy1gj5grzb8gzj313m056gnv.jpg)



![image-20200927201113174](https://tva1.sinaimg.cn/large/007S8ZIlgy1gj5gw5g6byj31440beta0.jpg)

```java
import java.util.Scanner;

public class demo06 {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        System.out.println("How many numbers do u need to draw?");
        int k = in.nextInt();
        System.out.println("What is the highest number you can draw?");
        int n = in.nextInt();

        int lotteryOdds = 1;
        for(int i=1;i<=k;i++){
            lotteryOdds = lotteryOdds * (n-i+1)/i;
        }
        System.out.println(+lotteryOdds);
    }
}

```



### 3.8.5 多重选择：switch语句



case标签可以是：

- 类型为char、byte、short或int的常量表达式
- 枚举常量
- 从Java SE7开始，case标签可以是字符串字面量



```java
import java.lang.Math;

import static java.lang.Math.floorMod;
import static java.lang.Math.sqrt;

public class demo02 {

    enum Size{
        Small,Medium,Large,Extra_Large;
    }

    public static void main(String[] args) {
       
        //可以放入int, char, String;
        Size size = Size.Small;
        switch (size){
            case Large:
                System.out.println("Suitable for Adults");
                break;
            case Small:
                System.out.println("Suitable for Child");
                break;
            default:
                System.out.println("Try again!");
                break;
        }


    }
}

```





### 3.8.6 中断控制流程语句

**break**

带标签的break: 意味着跳出标签所指定的循环。

```java
Scanner in = new Scanner(System.in);
int n;
read_data: 
while(...)
{
	for(...)
	{
		System.out.println("Enter a number>=0:");
		n = in.nextInt();
		if(n<0)
			break read_data;
			//break out of read_data loop
	}
}
```

如果输入有误，通过执行带标签的break跳转到带标签的语句块末尾。对于任何使用break语句的代码都需要检测循环是正常结束，还是由break跳出。

注意，break只能跳出语句块，不能跳入语句块。



**continue**

continue语句将越过当前循环体的剩余部分，立刻跳到循环首部。

如果将continue语句用于for循环中，就可以跳到for循环的"更新"部分。

```java
for(count=1;count<=100;count++)
{
	System.out.print("Enter a number:");
	n = in.nextInt();
	if(n<0) continue;
	sum+=n;
}
```





## 3.9 大数值



如果基本的整数和浮点数精度不能够满足需求，那么可以使用java.math包中的BigInteger和BigDecimal。

BigInteger类实现了任意精度的整数运算，

BigDecimal类实现了任意精度的浮点数运算。



```java
import java.math.BigInteger;
import java.util.Scanner;

public class demo07 {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        System.out.println("How many numbers do u need to draw?");
        int k= in.nextInt();
        System.out.println("What is the highest number you can draw?");
        int n = in.nextInt();

        BigInteger lotteryOdds =  BigInteger.valueOf(1);
        for(int i=1;i<=k;i++){
            lotteryOdds = lotteryOdds.multiply(BigInteger.valueOf(n-i+1)).divide(BigInteger.valueOf(i));
        }

        System.out.println(lotteryOdds);

    }
}

```



用于计算的语句是

```java
lotteryOdds = lotterOdds * (n-i+1)/i;
```



如果使用大数值，则



```java
lotteryOdds = lotterOdds.multiply(BigInteger.valueOf(n-i+1)).divide(BigInteger.valueOf(i));
```







![image-20200927204731027](https://tva1.sinaimg.cn/large/007S8ZIlgy1gj5hxwsq1uj314o0rqdot.jpg)

![image-20200927204800327](https://tva1.sinaimg.cn/large/007S8ZIlgy1gj5hyf5xnwj314q0ngtod.jpg)





## 3.10 数组



创建一个数字数组时，所有元素都初始化为0。boolean数组的元素会初始化为false。对象数组的元素则初始化为一个特殊值null。



### 3.10.1 for each循环

```java
for(int element: a)
	System.out.println(element);
```



有个更加简单的方式打印数组中的所有值，

```java
Arrays.toString(a);
```





### 3.10.2 数组初始化以及匿名数组



在Java中，提供了一种创建数组对象并同时赋予初始值的例子：

```
int[] smallPrimes =  {2,3,5,7,9};
```



初始化一个匿名数组

```
new int[]{1719,23};
```



另外在Java中，允许数组长度为0.

注意：数组长度为0与为null不同！



### 3.10.3 数组拷贝



如果希望将一个数组的所有值拷贝到一个新的数组中去，就要使用Arrays类的copyOf 方法：

第二个参数是新数组的长度。这个方法通常用来增加数组大小；



````java
import java.util.Arrays;

public class demo08 {
    public static void main(String[] args) {
        int[] smallPrimes = {2,3,4,5,7,11,12};
        int[] luckyNumbers = smallPrimes;
        luckyNumbers[5] = 15;

        int[] copiedLuckyNumbers = Arrays.copyOf(luckyNumbers,luckyNumbers.length*2);
        System.out.println(Arrays.toString(copiedLuckyNumbers));
    }
}

````



![image-20200928084350245](https://tva1.sinaimg.cn/large/007S8ZIlgy1gj62n8ie4rj30km0ca0xx.jpg)

```java
System.arraycopy(smallPrimes,0,luckyNumbers,0,smallPrimes.length);
```





### 3.10.4 命令行参数

前面已经看到多个使用Java数组的示例。每一个Java应用程序都有一个带String arg[]参数的main方法。这个参数表明main方法将接收一个字符串数组，也就是命令行参数。



如果使用下面这种形式运行这个程序:

```java
java Message -g cruel world
```

这个程序将显示下列信息：

```java
Goodbye, cruel world~
```



在Java应用程序的main方法中，程序名并没有存储在args数组中。

```java
public class demo09 {
    public static void main(String[] args) {
        if(args.length==0||args[0].equals("-h")){
            System.out.println("Hello");
        }
        else if(args[0].equals("-g")){
            System.out.println("GoodBye,");
        }

        for(int i=1;i<args.length;i++){
            System.out.println(" "+args[i]);
        }

        System.out.println("!");

    }
}

```





### 3.10.5 数组排序





要想对数值型数组进行排序，可以使用Arrays类中的sort方法。





````java
import java.util.Arrays;

public class demo10 {
    public static void main(String[] args) {

        int[] test = new int[100];

        for(int i=0;i<100;i++){
            test[i] = (int)(Math.random()*100);
        }

        Arrays.sort(test);

        int[] test2 = Arrays.copyOfRange(test,0,50);

        System.out.println(Arrays.toString(test));


        System.out.println(Arrays.toString(test2));

        Arrays.fill(test2, 3);
        System.out.println(Arrays.toString(test2));

        System.out.println(Arrays.equals(test,test2));


    }
}

````



![image-20200928091255056](https://tva1.sinaimg.cn/large/007S8ZIlgy1gj63hhubk6j30xa0mmwqy.jpg)

![image-20200928091316470](https://tva1.sinaimg.cn/large/007S8ZIlgy1gj63hvab1xj30xe0jugvo.jpg)



### 3.10.6 多维数组









多维数组将使用多个下标访问数组元素，它适用于表示表格或更加复杂的排列形式。



for each循环语句不能自动处理二维数组的每一个元素。它是按照行，也就是一维数组处理的。要想访问数组a的所有元素，需要使用两个嵌套的循环。

```java
for(double[] row: a)
	for(double value: row)
		do something with value 
```



要想快速得打印一个二维数组的数据元素列表，可以调用：

```java
System.out.println(Arrays.deepToString(a));
```



代码如下：

```java
import java.util.ArrayList;
import java.util.Arrays;

public class demo11 {
    public static void main(String[] args) {
        double[][] balances;
        balances = new double[5][10];

        //求得row
        System.out.println(balances.length);

        //求得column
        System.out.println(balances[0].length);

        for(double[] row: balances)
            for(double value: row) {
                System.out.println(value);
            }

        System.out.println(Arrays.deepToString(balances));

    }
}

```



# 第4章 对象与类

## 4.1 面向对象程序设计概述



面向对象的程序是由对象组成的，每个对象包含对用户公开的特定功能部分和隐藏的实现部分。

传统的结构化程序设计通过设计算法来解决问题。一旦确定了这些过程，就要开始考虑存储数据的方式。



### 4.1.1 类



类是构造对象的模版和蓝图。由**类构造**对象的过程称为创建类的**实例**。

封装（encapsulation，有时称为数据隐藏） 是与对象有关的一个重要概念。封装不过是将**数据**和**行为**组合在一个包中，并对对象的使用者隐藏了数据的实现方式。



对象中的数据称为**实例域**，操作数据的过程称为**方法**。

对于每个特定类实例都有一组特定的实例域值。

程序仅通过对象的方法与对象数据进行交互。



### 4.1.2 对象



- 对象的行为(hehavior)  — 可以对对象施加哪些操作，或可以对对象施加哪些方法。

- 对象的状态 — 当施加哪些方法时，对象如何响应？
- 对象的标识 — 如何辨别具有相同的行为而具有家族式的相似性。





### 4.1.3 识别类



传统的结构化程序设计。必须从顶部的main函数开始编写程序。在面向对象程序设计时没有所谓的“顶部”。

应该从设计类开始，然后再往每个类中添加方法。

- 商品(Item)
- 订单(Order)
- 送货地址(Shipping address)
- 付款(Payment)



### 4.1.4 类之间的关系



- 依赖（“uses-a”）
- 聚合（“has-a”）
- 继承 （“is-a”）

依赖：即"uses-a"关系，是一种最明显的、最常见的关系。例如，Order类使用Account类是因为Order对象需要访问Account对象查看信用状态。因此，如果一个类的方法操作另一个类的对象，我们就说一个类依赖于另一个类。

**一般而言，依赖关系在Java语言中体现为局域变量、方法的形参，或者对静态方法的调用。**



聚合：即"has-a"关系，是一种具体且易于理解的关系。一个Order对象包含一些Item对象。聚合关系意味着类A的对象包含类B的对象。



继承：即“is-a”关系，是一种用于表示特殊于一般关系的。例如，RushOrder类由Order类继承而来。



![image-20200928115550873](https://tva1.sinaimg.cn/large/007S8ZIlgy1gj6872sfipj30uk0n2tsc.jpg)







## 4.2 使用预定义类



### 4.2.1 对象与对象变量



在Java程序设计语言中，使用构造器(constructor)构造新实例。构造器是一种特殊的方法，用来构造并初始化对象。

构造器的名字应该与类名相同。因此Date类的构造器名为Date。要想构造一个Date对象，需要在构造器前加上new操作符。

一个对象变量并没有实际包含一个对象，而仅仅引用一个对象。



```java
import java.util.Date;

public class demo12 {
    public static void main(String[] args) {
        System.out.println(new Date().toString());
       	LocalDate date = LocalDate.now();
        date.getMonth();
        date.getMonth();
    }
}

```





## 4.3 用户自定义类



### 4.3.1 Employee类

![image-20200928123101947](https://tva1.sinaimg.cn/large/007S8ZIlgy1gj697n34vdj311w0ca0u2.jpg)



文件名必须与public类的名字相匹配。在一个源文件中，只能有一个公共类，但可以有任意数目的非公共类。

编译这段源代码，编译器将在目录下创建两个类文件：EmployeeTest.class和Employee.class

将程序中包含main方法的类名提供给字节码解释器，以便启动这个程序：

```java
java EmployeeTest
```



### 4.3.2 剖析Employee类

实例域：用来存放将要操作的数据

```java
private String name;
```



关键字public意味着任何类的任何方法都可以调用这些方法。

关键字private确保只有Employee类自身的方法能够访问这些实例域，而其他类的方法不能够读写这些域。

public数据域允许程序中的任何方法对其进行读取和修改。这就完全破坏了封装。



### 4.3.4 从构造器开始



![image-20200928125218037](https://tva1.sinaimg.cn/large/007S8ZIlgy1gj69trch5tj314o07sgn9.jpg)

- 构造器与类同名
- 每个类可以有一个以上的构造器
- 构造器可以有0个、1个或多个参数
- 构造器没有任何返回值
- 构造器总是伴随着new操作一起调用



注意：不要在构造器中定于与实例域重名的局部变量。下面的构造器将无法设置salary。



这是因为构造器声明了局部变量name和salary。这些变量只能在构造内部访问。这些变量屏蔽了同名的实例域。



```java
public class demo13 {
    String name;
    String salary;
    public demo13(String n,String s){
        String name = n;
        String salary = s;
    }

    public static void main(String[] args) {
        demo13 demo = new demo13("红杨","2k");
        System.out.println(demo.name);
        System.out.println(demo.salary);
    }
}

```



### 4.3.5 隐式参数与显式参数



Java中关键字this表示隐式参数。

### 4.3.6 封装的优点



不要编写返回引用可变对象的访问器方法。例如，在Employee类中就违反了这个设计原则



```java
import java.util.Date;

public class demo14 {
    public static void main(String[] args) {
        Employee harry = new Employee();
        Date d = harry.getHireDay();
        double tenYearsInMilliSeconds = 10 * 365 * 24 * 60 * 60 *1000;
        d.setTime(d.getTime()-(long)tenYearsInMilliSeconds);
    }
}

class Employee{
    private Date hireDay;

    public Date getHireDay()
    {
        return hireDay;
    }
}

```



LocalDate类没有更改器方法，而Date类中有一个更改器方法setTime



出错的原因：

d和harry.hireDay引用同一个对象，对d调用更改器方法就可以自动地改变雇员对象的私有状态。

![image-20200928135555207](https://tva1.sinaimg.cn/large/007S8ZIlgy1gj6bnzbkysj30s80h8qg1.jpg)

![image-20200928140107230](https://tva1.sinaimg.cn/large/007S8ZIlgy1gj6btdvahcj315e06wn0y.jpg)

```java
import java.util.Date;

public class demo14 {
    public static void main(String[] args) {
        Employee harry = new Employee();
        Date d = harry.getHireDay();
        double tenYearsInMilliSeconds = 10 * 365 * 24 * 60 * 60 *1000;
        d.setTime(d.getTime()-(long)tenYearsInMilliSeconds);
    }
}

class Employee{
    private Date hireDay;

    public Date getHireDay()
    {
        return (Date)hireDay.clone();
    }
}

```





### 4.3.7 基于类的访问权限



```java
class Employee
{
	public boolean equals(Employee other)
	{
		return name.equals(other.name);
	}
}
```

调用

```java
if(harry.equals(boss)) 
```



方法可以访问所属类的私有特性，而不仅限于访问隐式参数的私有特性。



### 4.3.8 私有方法

在实现一个类时，由于公有数据非常危险，所以应该将所有的数据域都设置为私有的。

在Java中，为了实现一个私有的方法，只需将关键字public改为private即可。

私有方法的好处，类的设计者可以确信：它不会被外部的其他类操作调用，可以将其删去。如果方法是公有的，就不能将其删去，因为其他的代码很可能依赖它。



### 4.3.9 final实例域

可以将实例域定义为final。

final 关键字只是表示存储在evaluations变量中的对象引用不回再指示其他StringBuilder对象。







## 4.4 静态域与静态方法



### 4.4.1 静态域



如果将域定义为static，每个类中只有一个这样的域。而每一个对象对于所有的**实例域**都有自己的一份拷贝。

例如，假定需要给每一个雇员赋予唯一的标识码。这里给Employee类添加一个**实例域id**和一个**静态域nextId**。





```java
public class demo15 {

    private static int nextId = 1;
    private int id;

    public void setId(){
        id = nextId;
        nextId++;
    }

    public static void main(String[] args) {
        demo15 demo = new demo15();
        demo.setId();
        System.out.println(demo.id);

        demo15 demo2 = new demo15();
        demo2.setId();
        System.out.println(demo2.id);


    }
}

```



现在，每一个雇员对象都有一个自己的id域，当这个类的所有实例将共享一个nextId域。

换句话说，如果有1000个Employee类的对象，则有1000个实例域id。但是，只有一个静态域nextId。

即使没有一个雇员对象，静态域nextId也存在。它属于类，而不属于任何独立的对象。





等同于

```java
harry.id = Employee.nextId;
Employee.nextId++;
```



### 4.4.2 静态常量







### 4.4.3 静态方法

静态方法是一种不能向对象实施操作的方法。例如，Math类的pow方法就是一个静态方法。表达式

```java
Math.pow(x,a)；
```





可以使用对象调用静态方法。例如，如果harry是一个Employee对象，可以用harry.getNextId()代替Employee.getNextId()。不过，这种方式很容易混淆，原因是getNextId方法计算的结果与harry毫无关系。

- 一个方法不需要访问对象状态，其所需参数都是通过显式参数提供。
- 一个方法只需要访问类的静态域。



Employee类的静态方法不能访问Id实例域，因为它不能操作对象。



### 4.4.4 工厂方法 



NumberFormat类使用静态工厂方法来构造对象。

为什么NumberFormat类不利用构造器完成这些操作呢？

- 无法命名构造器。构造器的名字必须和类名相同。但是i，这里希望将得到的货币实例和百分比实例采用不同的名字。
- 当使用构造器时，无法改变所构造的对象类型。

```java
import java.text.NumberFormat;

public class demo16 {
    public static void main(String[] args) {
        NumberFormat currencyFormatter = NumberFormat.getCurrencyInstance();
        NumberFormat percentFormatter =  NumberFormat.getPercentInstance();

        double x = 0.1;
        System.out.println(currencyFormatter.format(x));
        System.out.println(percentFormatter.format(x));

    }
}

```





### 4.4.5 main方法



需要注意的是不需要使用对象调用静态方法。例如，不需要构造Math类对象就可以调用Math.pow

main方法不对任何对象进行操作。事实上，在启动程序时还没有任何一个对象。静态的main方法将执行并创建程序所需要的对象。



## 4.5 方法参数

参数传递给方法的一些专业术语：

分为两种：

- 值调用（call by value）表示方法接收的是调用者提供的值。

- 引用调用（call by reference）表示方法接收的是调用者提供的变量地址。



一个方法可以修改传递引用调用所对应的变量值，而不能修改传递值调用所对应的变量值。

按.....调用（call by）是一个标准的计算机科学术语，它用来描述各种程序设计语言中方法参数的传递方式。



Java程序设计语言总是采用**按值调用**。 也就是说，方法得到的是所有参数值的一个拷贝，特别是，方法不能修改传递给它的任何参数变量的内容。



**基本数据类型**



```java
 /**
 * Test 1: Methods can't modify numeric parameters
 */
System.out.println("Testing tripleValue:");
double percent = 10;
System.out.println("Before: percent="+percent);
tripleValue(percent);
System.out.println("After: percent"+percent);


 public static void tripleValue(double x){
   x = 3*x;
   System.out.println("End of method: x= "+x);
 }

```

调用这个方法之后，percent的值还是10。下面看一下具体的执行过程：

1）x被初始化为percent值的一个拷贝（也就是10）

2）x被乘以3后等于30.但是percent仍然是10

3）这个方法结束后，参数x不再使用





![image-20200928184529125](/Users/liuhongyang/Library/Application Support/typora-user-images/image-20200928184529125.png)





然而方法参数共有两种类型：

- 基本数据类型（数字、布尔值）
- 对象引用



**对象引用**

一个方法不可能修改一个基本数据类型的参数。而对象引用作为参数就不同了，可以很容易地利用下面这个方法实现将一个雇员的薪金提高两倍的操作：

1） x被初始化为harry值的拷贝，这里是一个对象的引用。

2） raiseSalary方法应用于这个对象引用。x和harry同时引用的那个Employee对象的薪金提高了200%

3）方法结束后，参数变量x不再使用。当然，对象变量harry继续引用那个薪金增至3倍的雇员对象。 





```java
 /**
 * Test 2: Methods can change the state of object parameters
 */

System.out.println("\nTesting tripleSalary");
Employee harry = new Employee("Harry",5000);
System.out.println("Before: salary="+harry.getSalary());
tripleSalary(harry);
System.out.println("After: salary="+harry.getSalary());


public static void tripleSalary(Employee x){
        x.raiseSalary(200);
        System.out.println("End of methods: salary="+x.getSalary());
}

```







![image-20200928185049263](/Users/liuhongyang/Library/Application Support/typora-user-images/image-20200928185049263.png)

方法得到的是对象引用的拷贝，对象引用及其他的拷贝同时引用同一个对象。



```java
/**
* Test 3:Methods can't attach new objects to object parameters
*/

System.out.println("\nTesting swap:");
Employee a = new Employee("Alice",70000);
Employee b = new Employee("Bob",60000);
System.out.println("Before: a="+a.getName());
System.out.println("Before: b="+b.getName());
swap(a,b);
System.out.println("After: a="+a.getName());
System.out.println("After: b="+b.getName());

 public static void swap(Employee x,Employee y){
        Employee temp = x;
        x = y;
        y = temp;
        System.out.println("End of methods: x="+x.getName());
        System.out.println("End of methods: y="+y.getName());
 }
```





如果Java对对象采用的是按指调用，那么这个方法就应该能够实现交换数据的效果。

但是，方法并没有改变存储在变量a和b中的对象引用。

swap方法的参数x和y被初始化为两个对象引用的拷贝，这个方法交换的是这两个拷贝。

![image-20200928191018365](/Users/liuhongyang/Library/Application Support/typora-user-images/image-20200928191018365.png)









全部代码：

```java
public class demo17 {
    public static void main(String[] args) {
        /**
         * Test 1: Methods can't modify numeric parameters
         */
        System.out.println("Testing tripleValue:");
        double percent = 10;
        System.out.println("Before: percent="+percent);
        tripleValue(percent);
        System.out.println("After: percent"+percent);


        /**
         * Test 2: Methods can change the state of object parameters
         */

        System.out.println("\nTesting tripleSalary");
        Employee harry = new Employee("Harry",5000);
        System.out.println("Before: salary="+harry.getSalary());
        tripleSalary(harry);
        System.out.println("After: salary="+harry.getSalary());

        /**
         * Test 3:Methods can't attach new objects to object parameters
         */

        System.out.println("\nTesting swap:");
        Employee a = new Employee("Alice",70000);
        Employee b = new Employee("Bob",60000);
        System.out.println("Before: a="+a.getName());
        System.out.println("Before: b="+b.getName());
        swap(a,b);
        System.out.println("After: a="+a.getName());
        System.out.println("After: b="+b.getName());

    }

    public static void tripleValue(double x){
        x = 3*x;
        System.out.println("End of method: x= "+x);
    }

    public static void tripleSalary(Employee x){
        x.raiseSalary(200);
        System.out.println("End of methods: salary="+x.getSalary());
    }

    public static void swap(Employee x,Employee y){
        Employee temp = x;
        x = y;
        y = temp;
        System.out.println("End of methods: x="+x.getName());
        System.out.println("End of methods: y="+y.getName());
    }



}

```



更多例子：



```java
String value = "Hello";
System.out.println("Before:"+value);
changeString(value);
System.out.println("After:"+value);

String[] array = {"中心","思想"};
System.out.println(Arrays.toString(array));
changeArray(array);
System.out.println(Arrays.toString(array));


public static void changeArray(String[] arr){
	arr[1] = "大国";
}


public static void changeString(String a){
	a= "您好";
	System.out.println("End of method"+a);
}
```





![image-20200928191406062](/Users/liuhongyang/Library/Application Support/typora-user-images/image-20200928191406062.png)



## 4.6 对象构造



构造器可以定义对象的初始状态。但是，对象构造非常重要，所以Java提供了多种编写构造器的机制。



### 4.6.1 重载



有的类有多个构造器。例如StringBuilder对象。既可以构造一个空的StringBuilder对象，例如

```java
StringBuilder messages = new StringBuilder();
```



也可构造一个初始字符串： 

```java
StringBuilder todoList = new StringBuilder("To do:\n");
```

这种特征叫做重载。如果多个方法有相同的名字、不同的参数，便产生了重载。



重载解析：编译器必须挑选出具体执行哪个方法，它通过用各个方法给出的参数类型与特定方法调用所使用的值类型进行匹配来挑选出相应的方法。如果编译器找不到匹配的参数，就会产生变异时错误，因为根本不存在匹配，或者没有一个比其他的更好。





### 4.6.2 默认域初始化



如果在构造器中没有显式地给域赋予初值，那么就会被自动地赋予为默认值：数值为0、布尔值为false、对象引用为null。



### 4.6.3 无参数的构造器

很多类都包含一个无参数的构造函数，对象由无参数构造函数创建时，其状态会设置为适当的默认值。例如：

```java
public Employee()
{
	name = "";
	salary = 0;
	hireDay = LocalDate.now();
}
```



如果在编写一个类时没有编写构造器，那么系统就会提供一个默认的无参构造器。这个构造器将所有的实例域设置为默认值。于是，实例域中的数值型数据就会被设置为0、布尔值false，对象变量设置为null。

需要注意的是，如果没有提供无参数的构造器，则构建对象时就必须提供参数。



如果有参：

```java
public class demo18 {
    String name;

    public demo18(){
    }

    public demo18(String name){
        this.name = name;
    }

}

class Test{
    public static void main(String[] args) {
        demo18 demo = new demo18();
        demo18 demo2 = new demo18("hello");
    }
}

```





如果无参：

```java
public class demo18 {
    String name;


    public demo18(String name){
        this.name = name;
    }

}

class Test{
    public static void main(String[] args) {
        demo18 demo2 = new demo18();
    }
}

```



注意：仅当类没有提供任何构造器的时候，系统才会提供一个默认的构造器，如果希望用户能够采用

```java
new ClassName()
```

就必须提供一个默认的构造器

```java
public className()
{

}
```





### 4.6.4 显式域初始化

通过重载类的构造器方法，可以采用多种形式设置类的实例域的初始状态。确保不管怎样调用构造器，每个实例域都可以被设置为一个有意义的初值。

在执行构造器之前，先执行赋值操作。当一个类的所有构造器都希望吧相同的值赋予某个特定的实例域时，这种方式特别有用。



```java
public class demo19 {
    private static int nextId;
    private int id = assignId();

    private static int assignId(){
        int r = nextId;
        nextId++;
        return r;
    }

    public static void main(String[] args) {
        demo19 demo = new demo19();
        demo19 demo2 = new demo19();
        demo19 demo3 = new demo19();

        System.out.println(demo.id);
        System.out.println(demo2.id);
        System.out.println(demo3.id);
    }
}

```







### 4.6.5 参数名



参数名有两种方式：

第一种在参数面前加上一个前缀‘’a“

```java
public Employee(String aName, double aSalary)
{
	name = aName;
	salary = aSalary;
}
```

第二种，将参数命名为this.salary访问实例域，参数名不变

```java
public Employee(String name, double salary)
{
	this.name = name;
	this.salary = salary;
}
```





### 4.6.6 调用另一个构造器

关键字this引用方法的隐式参数。

如果构造器的第一个语句形如this(...)，这个构造器将调用同一个类的另一个构造器。

例如，

```java
public class demo20 {
    private String name;
    private double age;
    private static int nextId;

    public demo20(double s){
        this("hello",s);
        nextId++;
    }

    public demo20(String aName, double aAge){
        name = aName;
        age = aAge;
    }

    public static void main(String[] args) {

    }
}

```

采用这种方式使用this关键字非常有用，这样对公共的构造器代码部分只编写一次即可。



### 4.6.7 初始化块

Java中三种初始化数据域的方法：

- 在构造器中设置值
- 在声明中赋值
- 初始化块



 无论使用哪个构造器构造对象， id域都在对象初始化块中被初始化。首先运行初始化块，然后才运行构造器的主体部分。



如果对类的静态域进行初始化的代码比较复杂，那么可以使用静态的初始化块。

将代码放入在一个块中，并标记关键字static。

```java
static
{
	Random generator = new Random();
	nextId = generator.nextInt(100000);
}
```

在类第一次加载的时候，将会进行静态域的初始化。与实例域一样，除非将它们显式地设置成其他值。否则默认的初始值是0、false、或null。

所有的静态初始化语句以及静态初始化块都将依照类定义的顺序执行。





程序清单如下：

- 重载构造器
- 用this(...) 调用另一个构造器
- 无参数构造器
- 对象初始化块
- 静态初始化块
- 实例域初始化





````java
import java.util.Random;

public class demo21 {
    public static void main(String[] args) {
        Employe[] staff = new Employe[3];

        staff[0] = new Employe("Harry",40000);
        staff[1] = new Employe(60000);
        staff[2] = new Employe();

        for(Employe e:staff)
            System.out.println("name="+e.getName()+",id=");
    }
}

class Employe{
    private static int nextId;

    private int id;
    private String name ="";
    private double salary;

    //static initialization block
    static {
        Random generator = new Random();
        nextId = generator.nextInt(10000);
    }

    //object initialization block
    {
        id = nextId;
        nextId++;
    }

    public Employe(String n,double s){
        name = n;
        salary = s;
    }

    public Employe(double s){
        this("Employee #"+nextId,s);
    }

    public Employe(){

    }

    public String getName(){
        return name;
    }

    public double getSalary(){
        return salary;
    }

    public int getId(){
        return id;
    }

}

````



![image-20200930170220182](https://tva1.sinaimg.cn/large/007S8ZIlgy1gj8sak7exbj315w0920xq.jpg)







### 4.6.8 对象析构与finalize方法

Java有自动的垃圾回收器，不需要人工回收内存，所以Java不支持析构器。

finalize方法将在垃圾回收器清除对象之前调用。在实际应用中，不要依赖于使用finalize方法回收任何短缺的资源。



## 4.7 包



Java允许使用包将类组织起来。借助于包可以方便地组织自己的代码，并将自己的代码与别人提供的代码库分开管理。



使用包的主要原因是确保类名的唯一性。假如两个程序员不约而同地建立了 Employee类。只要将这些类放置在不同的包中，就不会产生冲突。



### 4.7.1 类的导入

一个类可以使用所属包中的所有类，以及其他包中的**公有类**。



常用导入类名方法有：在每个类名之前添加完整的包名。

```java
java.time.LocalDate today = java.time.LocalDate.now();
System.out.println(today);
```



```java
package chapter2;

import java.time.LocalDate;

public class Employee {
    public static void main(String[] args) {
        LocalDate today = LocalDate.now();
    }
}

```



如果这两个Date类都需要使用，可以在每个类名前面加上完整的包名。

```java
 java.util.Date deadline = new java.util.Date();
 java.sql.Date today = new java.sql.Date(...);
```



### 4.7.2 静态导入

import语句不仅可以导入类，还增加了导入静态方法和静态域的工能。

例如，如果在源文件的顶部，添加一条指令：

```java
import static java.lang.System.*;
```



就可以使用System类的静态方法和静态域，而不必加类名前缀： 

```java
out.println("Goodbye, World!");
exit(0);
```



### 4.7.3 将类放入包中

要想将类放入包中，就必须将包的名字放在源文件的开头，包中定义类的代码之前。否则就会进入一个(default package)中。默认包是一个没有名字的包。在此之前，我们定义的所有类都在默认包中。



对于包而言，同一个包中相同的类名不应该出现两次，否则会相互冲突。

对于包的可见性，如果设置为public则所有的包均可见，再次设置相同public，则会出现冲突。



```java
package chapter2;

public class Test {
    public static void main(String[] args) {
        System.out.println("TEST");
    }
}

```













### 4.7.4 包作用域



变量必须显式地标记为private，不然的话将默认为包可见。显然，这样做会破坏封装性。







## 4.8 类路径



在前面已经看到，类存储在文件系统的子目录中。类的路径必须与包名匹配。



在Unix中，禁止使用*以防止shell命令进一步扩展。







## 4.9 文档注释



文档注释域源代码在同一个文件中，在修改源代码的同时，重新运行javadoc就可以轻而易举地保持两者的一致性。

### 4.9.1 注释的插入

自由文本格式 @开始

@author

@para

### 4.9.2 类注释

@code Card



### 4.9.3 方法注释



@param变量描述

@return 描述

@throws 类描述



### 4.9.4 域注释

 ```
/**
*
*/
 ```



### 4.9.5 通用注释



@author 姓名

@version 文本

@since 文本

@deprecated 文本

@see 引用





## 4.10 类设计技巧



1.一定要保证数据私有

2.一定要对数据初始化

3.不要在类中使用过多的基本类型

4.不是所有的域都需要独立的域访问器和域更改器

5.将职责过多的类进行分解

6.类名和方法名要能够体现它们的职责

7.优先使用不可变的类



# 第5章 继承

本章概述：

继承：利用继承，人们可以给予已存在的类构造一个新类。继承已存在的类就是复用（继承）这些类的方法和域。在此基础上，还可以添加一些新的方法和域，以满足新的需求。

反射：反射是指在程序运行期间发现更多的类及其属性的能力。



## 5.1 类、超类和子类



### 5.1.1 定义子类

在通过扩展超类定义子类的时候，仅需要指出子类与超类的不同之处。因此在设计类的时候， 应该将通用的方法放在超类中，而将具有特殊用途的方法放在子类中，这种将通用的功能放到超类的做法，在面向对象程序设计中十分普遍。

```java
public class Manager extends Empoyee
{
	private double bonus;
	
	public void setBonus(double bonus)
	{
		this.bonus = bonus;
	}
}
```



### 5.1.2 覆盖方法

超类中的有些方法对子类Manager并不一定适用。比如，Manager类中的getSalary方法应该返回薪水和奖金的总和。为此，需要提供一个新的方法来覆盖（override）超类中的这个方法：

```java
public class Manager extends Employee
{
	public double getSalary()
	{
		
	}
}
```



只需要返回salary和bonus域综合

```java
public double getSalary()
{
	return salary + bonus;
}
```

这个方法不能运行，这个是因为Manager类的getSalary方法不能够**直接地访问超类的私有域**。

将对salary域的访问替换成调用getSalary方法。

```java
public double getSalry()
{
	double baseSalary = getSalary();
	return baseSalry + bounus;
}
```

上面这段代码仍然不能运行，会导致无限调用自己。

因此我们可以添加特定关键字super

```java
public double getSalary()
{
	double baseSalary = super.getSalary();
	return baseSalary + bonus;
}
```

在子类中可以增加域、增加方法或覆盖超类的方法，然而不能删除继承的任何域和方法。



### 5.1.3 子类构造器



是“调用超类Employee中含有n、s year month 和day参数的构造器”的简写形式。

```java
public Manager(String name, double salary, int year, int month, int day){
	super(name,salary,year,month,day);
	bonus = 0;
}
```

由于Manager类的构造器不能访问Employee类的私有域，所以必须利用Employee类的构造器对这部分私有域进行初始化，我们可以通过super实现对超类构造器的调用。**使用super调用构造器的语句必须是子类构造器的第一条语句。**



如果子类的构造器没有显式地调用超类的构造器，则将自动地调用超类默认的（没有参数）的构造器。如果超类没有不带参数的构造器，并且子类构造器中又没有显式地调用超类的其他构造器，则Java编译器报错。



**父类没有默认构造构造器：**则子类应该显式调用父类构造器，否则会编译错误。

**如果父类有默认构造构造器：**既可以显式调用构造器，也可以隐式；



```java
package chapter5;

class Emplpyee{
    int salary;

    public Emplpyee(int salary){
        this.salary = salary;
    }


    public int getSalary() {
        return salary;
    }

    public void setSalary(int salary) {
        this.salary = salary;
    }
}

class Manager extends Emplpyee{
    int bonus;
    public Manager(int salary, int bonus){
        super(salary);
        this.bonus = bonus;
    }


    public int getSalary() {
        return super.salary+this.bonus;
    }

}

public class demo5_1 {
    public static void main(String[] args) {
        Emplpyee manager = new Manager(1,1);
        manager.getSalary();

    }

}

```



代码：



```java
package inheritance;

import java.time.LocalDate;

public class ManagerTest {
    public static void main(String[] args) {
        Manager boss = new Manager("Carl Cracker",80000,1987, 12,15);
        boss.setBonus(5000);

        Employee[] staff = new Employee[3];

        staff[0] = boss;
        staff[1] = new Employee("Harry Hacker",50000,1989,10,1);
        staff[2] = new Employee("Tommy Tester",40000,1990,3,15);

        for(Employee e:staff){
            System.out.println("name="+e.getName()+",salary="+e.getSalary());
        }
    }
}

class Employee{
    private String name;
    private double salary;
    private LocalDate hireDay;

    public Employee(String name, double salary, int year, int month, int day) {
        this.name = name;
        this.salary = salary;
        hireDay = LocalDate.of(year,month,day);
    }

    public String getName() {
        return name;
    }

    public double getSalary() {
        return salary;
    }

    public LocalDate getHireDay() {
        return hireDay;
    }

    public void raiseSalary(double byPercent){
        double raise = salary * byPercent / 100;
        salary += raise;
    }
}

class Manager extends Employee{
    private double bonus;

    public Manager(String name, double salary, int year,int month, int day){
        super(name,salary,year,month,day);
        bonus = 0;
    }

    public double getSalary(){
        double baseSalary = super.getSalary();
        return  baseSalary+bonus;
    }

    public void setBonus(double b){
        bonus = b;
    }
}

```



### 5.1.4 继承层次



![image-20201002102643567](https://tva1.sinaimg.cn/large/007S8ZIlgy1gjas3nwel4j30ko0jqdpi.jpg)

继承并不仅限于一个层次。由一个公共超类派生出来的所有类的集合被称为继承层次，在继承层次中，从某个特定的类到其祖先的路径呗称为该类的继承链。



通常一个祖先类可以拥有多个子孙继承链。例如，可以由Employee类派生出子类Programmer或Secretary,它们与Manager类没有renew关系。





### 5.1.5 多态



有一个用来判断是否应该设计为继承关系的简单规则，这就是“is-a”规则，它表明子类的每个对象也是超类的对象。

例如，每个经理都是雇员，因此，将Manager类设计为Employee类的子类是显而易见的，反之不染，并不是每一个名雇员都是经理。

可以将子类的对象赋给超类变量。

```java
Employee e;
e = new Employee();
e = new Manager();
```



在Java程序中，对象变量是多态的，一个Employee变量既可以引用一个Employee类对象，也可以引用一个Employee类的任何一个子类的对象。





### 5.1.6 理解方法调用

子类会优先排查

1 ) 编译器查看对象的声明类型和方法名。

2 )  编译器将查看调用方法时提供的参数类型。

3 ）如果是private方法、static方法、final方法或构造器，那么编译器将可以准确地知道应该调用哪个方法，我们将这种调用方式称为静态绑定。

4 ）当程序运行, 并且采用动态绑定调用方法时，虚拟机一定调用与x所引用对象的实际类型最合适的那个类的方法。





### 5.1.7 阻止继承：final类和方法



有时候，可能希望阻止人们利用某个类定义子类。不允许扩展的类被称为final类。如果在定义类的时候使用了final修饰符就表明这个类是final类。

```java
public final class Executive extends Manager
{

}
```



类中的特定方法也可以被声明为final。如果这样做，子类就不能覆盖这个方法（final类中的所有方法自动地称为final方法）。

```java
public class Employee
{
	public final String getName()
	{
		return name;
	}
}
```



前面曾经说过，域也可以被声明为final。对于final域来说，构造对象之后就不允许改变它们的值了。不过，如果将一个类声明为final，自由其中的方法自动地称为final，而不包括域。

将方法或类声明为final主要目的是：确保它们不会在子类中改变语义。



### 5.1.8 强制类型转换







经过测试，子类对象可以强制转换成父类；但是父类对象需要经过instanceof之后才能转换成子类。在进行类型转换之前，先查看一下是否能够成功地转换。

```java
package chapter5;

class Emplpyee{
    int salary;
    public Emplpyee(int salary){
        this.salary = salary;
    }


    public int getSalary() {
        return salary;
    }

    public void setSalary(int salary) {
        this.salary = salary;
    }

    public void printB(){
        System.out.println("Father");
    }
}

class Manager extends Emplpyee{
    int bonus;
    public Manager(int salary, int bonus){
        super(salary);
        this.bonus = bonus;
    }

    public int getBonus(){
        return bonus;
    }

    public int getSalary() {
        return super.salary+this.bonus;
    }

    public void printB(){
        System.out.println("Son");
    }
}

    public class demo5_1 {
        public static void main(String[] args) {
            //将父类对象转化成子类对象
           Emplpyee father_class = new Emplpyee(2);

           if(father_class instanceof Manager)
           {
               Manager manager = (Manager)father_class;
               manager.getBonus();
           }


           //将子类对象转化成父类对象
//            Manager son_class = new Manager(2,10);
//            Emplpyee emplpyee = (Emplpyee) son_class;
//            emplpyee.getSalary();



        }

    }

```



综上所述：

- 只能在继承层次内进行类型转换
- 在将超类转换成子类之前，应该使用instanceof进行检查。

子类引用赋给超类变量——允许

超类引用赋给子类变量——需要强制转换



### 5.1.9 抽象类

包含**一个或多个抽象方法的类**本身必须被声明为**抽象**的。

**抽象类不能被实例化**。如果一个类被声明为abstract，就不能创建这类的对象。

可以定义一个抽象类的对象变量，但是只能引用非抽象子类的对象。

抽象类还可以包含**具体数据和具体方法**。

许多程序员认为，在抽象类中不能包含具体方法。建议尽量将通用的域和方法放在超类中。

抽象方法充当着占位的角色，它们的具体实现在子类中。

扩展抽象类有两种选择：

- 一种是在抽象类中定义部分抽象类方法或不定义抽象类方法，这样子类也必须标记为抽象类。
- 另一种是定义全部的抽象方法，这样一来，子类就不是抽象的了。



PersonTest.java

```java
package AbstractClass;

public class PersonTest {
    public static void main(String[] args) {
        Person[] people = new Person[2];
        people[0] = new Employee("Harry Hacker",50000,1989,10,1);
        people[1] = new Student("Maria Morris","computer science");

        for(Person p: people){
            System.out.println(p.getName()+","+p.getDescription());
        }
    }
}


```



Person.java

```java
package AbstractClass;

public abstract class Person {
   public abstract String getDescription();
   private String name;
   public Person(){}
   public Person(String name){
       this.name = name;
   }
   public String getName(){
       return name;
   }

}

```



Employee.java

```java
package AbstractClass;

import java.time.LocalDate;

public class Employee extends Person{
    private double salary;
    private LocalDate hireDay;

    public Employee(String name,double salary, int year, int month, int day) {
        super(name);
        this.salary = salary;
        hireDay = LocalDate.of(year,month,day);
    }

    public double getSalary()
    {
        return salary;
    }

    public LocalDate getHireDay(){
        return hireDay;
    }

    @Override
    public String getDescription() {
        return String.format("an employ with a salary of $%.2f",salary);
    }

    public void raiseSalary(double byPercent){
        double raise = salary*byPercent/100;
        salary+=raise;
    }
}

```



Student.java

```java
package AbstractClass;

public class Student extends Person {
    private String major;

    public Student(String name, String major){
        super(name);
        this.major = major;
    }

    public String getDescription(){
        return "a student majoring in"+ major;
    }


}

```



### 5.1.10 受保护访问



Java用于控制可见性的4个访问修饰符：

- 仅对本类可见— private
- 对所有类可见— public
- 对本包和所有子类可见— protected
- 对本包可见—默认，不需要修饰符



## 5.2 Object： 所有类的超类



Object类是Java中所有类的始祖。如果没有明确地指出超类，Object类就被认为是这个类的超类。在Java中，每个类都是由Object类扩展而来的。



可以使用Object类型的变量引用任何类型的对象：

```java
Object obj = new Employee("Harrry Hacker",35000);
```

Object类型的变量只能用于作为各种值的通用持有者。

```java
Employee e = (Employee) obj;
```

在Java中，只有基本类型不是对象，所有的数组类型，不管是对象数组还是基本类型的数组都扩展了Object类。

 ```java
Employee[] staff= new Employee[10];
obj = staff;
obj = new int[10];
 ```



### 5.2.1 equals方法





Object类中的equals方法用于检测一个对象是否等于另一个对象。在Object类中，这个方法将判断两个对象是否具有相同的引用。如果两个对象具有相同的引用，则他们一定是相等的。

但是对于许多类来说，这种判断并无意义，然而经常需要检测两个对象的相等性，如果两个对象的状态相等，就认为这两个对象是相等的。



代码：

![image-20201005094259839](https://tva1.sinaimg.cn/large/007S8ZIlgy1gje7oyjl4hj30ur0u0ndh.jpg)

```java
package AbstractClass;

import java.time.LocalDate;
import java.util.Objects;

public class Employee extends Person{
    private String name;
    private double salary;
    private LocalDate hireDay;

    public Employee(String name,double salary, int year, int month, int day) {
        super(name);
        this.salary = salary;
        hireDay = LocalDate.of(year,month,day);
    }

	  //1）显式参数命名为otherObject,稍后需要将它转换成另一个叫做other的变量
    public boolean equals(Object otherObject){
      	//2）检测this与otherObject是否引用同一个对象
        if(this==otherObject) return true;
				//3）检测otehrObject是否为null，如果为null，返回false。
        if(otherObject==null) return  false;
				//4）比较this与otherObject是否属于同一个类。如果equals的语义在每个子类中有所改变，就使用getClass检测
        if(getClass()!=otherObject.getClass()){
            return false;
        }
				//如果所有的之类都拥有统一的语义，就使用instanceof检测:
      	//if(!(otherObject onstanceof ClassName)) return false;
      
        //5）将otherObject转换为相应的类类型变量
        Employee other = (Employee)otherObject;
				//6）比较域
        return Objects.equals(name,other.name)&&salary==other.salary&&
                Objects.equals(hireDay,other.hireDay);
    }

}

```

getClass方法将返回一个对象所属的类。

提示：为了防备name或hireDay可能为null的情况，需要使用Objects.equals方法。如果两个参数都为null则返回true如果其中一个参数为null，则返回false；否则如果两个参数都不为null，则调用a.equals(b)。

```java
 /**
     * Returns {@code true} if the arguments are equal to each other
     * and {@code false} otherwise.
     * Consequently, if both arguments are {@code null}, {@code true}
     * is returned and if exactly one argument is {@code null}, {@code
     * false} is returned.  Otherwise, equality is determined by using
     * the {@link Object#equals equals} method of the first
     * argument.
     *
     * @param a an object
     * @param b an object to be compared with {@code a} for equality
     * @return {@code true} if the arguments are equal to each other
     * and {@code false} otherwise
     * @see Object#equals(Object)
     */
    public static boolean equals(Object a, Object b) {
        return (a == b) || (a != null && a.equals(b));
    }
```



在子类中定义equals方法时，首先调用超类的equals。如果检测失败，对象就不可能相等。

如果超类中的域都相等，就需要比较子类中的实例域。

```
package AbstractClass;

public class Manager {
    int bonus;
    public boolean equals(Object otherObject){
        if(!super.equals(otherObject)) return false;
        Manager other = (Manager)otherObject;
        return bonus == other.bonus;
    }
}

```



### 5.2.2 相等测试与继承



- 如果子类能够拥有自己的相等概念，则对称性需求将强制采用getClass进行检测。

- 如果由超类决定相等的概念，那么就可以使用instanceof进行检测，这样可以在不同子类的对象之间进行相等的比较。



![image-20201005093343455](https://tva1.sinaimg.cn/large/007S8ZIlgy1gje7fcz7w1j31760dan4o.jpg)





![image-20201005000142105](https://tva1.sinaimg.cn/large/007S8ZIlgy1gjdqw498hfj317w0twwr8.jpg)

![image-20201005000040119](/Users/liuhongyang/Library/Application Support/typora-user-images/image-20201005000040119.png)



### 5.2.3 hashCode方法



散列码(hash code)是由对象导出的一个整型值。散列码是没有规律的，如果x和y是两个不同的对象，x.hashCode()与y.hashCode()基本上不会相同。





通过Stirng类调用的hashCode散列码：

```java
int hash = 0;
for(int i=0;i<length();i++)
	hash = 31* hash+ charAt(i);
```



由于hashCode方法定义在Object类中，因此每个对象都有一个默认的散列码，其值为对象的存储地址。



![image-20201005100813778](https://tva1.sinaimg.cn/large/007S8ZIlgy1gje8ffss0ej317u0t24km.jpg)

```java
import java.util.Objects;

public class demo24 {
    public static void main(String[] args) {
        String s ="OK";
        StringBuilder sb = new StringBuilder(s);

        System.out.println(s.hashCode()+" "+sb.hashCode());

        String t = new String("OK");
        StringBuilder tb = new StringBuilder(t);
        System.out.println(t.hashCode()+ " "+tb.hashCode() );
        System.out.println(Objects.hashCode("Hello"));
        System.out.println(Objects.hashCode("Harry"));

    }
}

```







### 5.2.4 toString方法



在Object中还有一个重要的方法啊，就是toString方法，它用于返回表示对象值的字符串。

实际上，最好通过调用getClass.getName()获得类名的字符串，而不要将类名硬加到toString方法中。

```java
public String toString(){
	reutrn getClass.getName() + "[name=]"name+ ",salary="+salary + ",hireDay="+hireDay+"]";
}
```



> Employee类和Manager类中equals、hashCode和toString方法的代码清单

EqualsTest.java

```java
package equals;

public class EqualsTest {
    public static void main(String[] args) {
        Employee alice1 = new Employee("Alice Adams",75000,1987,12,15);
        Employee alice2 = alice1;
        Employee alice3 = new Employee("Alice Adams",75000,1987,12,15);

        Employee bob = new Employee("Bob Brandson",50000,1987,10,1);

        System.out.println("alice1 == alice2"+(alice1==alice2));
        System.out.println("alice1 == alice3"+(alice1==alice3));
        System.out.println("alice1.equals(alice3)"+alice1.equals(alice3));
        System.out.println("alice1.equals(bob)"+alice1.equals(bob));
        System.out.println("bob.toString"+bob);
    }
}

```



Employee.java

```java
package equals;

import java.time.LocalDate;
import java.util.Objects;

public class Employee {
    private String name;
    private double salary;
    private LocalDate hireDay;

    public Employee(String name, double salary, int year, int month , int day) {
        this.name = name;
        this.salary = salary;
        hireDay = LocalDate.of(year,month,day);
    }

    public String getName() {
        return name;
    }

    public double getSalary() {
        return salary;
    }

    public LocalDate getHireDay() {
        return hireDay;
    }

    public void raiseSalry(double byPercent){
        double raise = salary*byPercent/100;
        salary+=raise;
    }

    public boolean equals(Object otherObject){
        if(this == otherObject) return true;
        if(otherObject==null) return false;
        if(getClass()!=otherObject.getClass()) return false;
        Employee other = (Employee)otherObject;
        return Objects.equals(name,other.name) && salary==other.salary
                && Objects.equals(hireDay,other.hireDay);
    }

    public int hashCode(){
        return Objects.hash(name,salary,hireDay);
    }

    public String toString(){
        return getClass().getName() + "[" +name + ",salary="+ salary+ ",hireDay="
                +hireDay+"]";
    }

}

```



Manager.java

```java
package equals;

import java.time.LocalDate;

public class Manager extends Employee {
    private double bonus;

    public Manager(String name,double salary,int year,int month, int day){
        super(name,salary,year,month,day);
        bonus = 0;
    }


    public double getSalary() {
        double baseSalary = super.getSalary();
        return baseSalary + bonus;
    }

    public void setBonus(double bonus){
        this.bonus = bonus;
    }

    public boolean equals(Object otherObject) {
        if(!super.equals(otherObject)) return false;
        Manager other = (Manager)otherObject;
        return bonus == other.bonus;
    }

    public int hashCode() {
        return super.hashCode() + 17*new Double(bonus).hashCode();
    }

    public String toString() {
        return super.toString()+"[bonus="+bonus+"]";
    }
}

```









Override只是告诉编译器你想覆盖这个方法，如果没有成功覆盖编译器会报错。否则的话就是当作子类中的一个普通方法。

![image-20201005233454672](https://tva1.sinaimg.cn/large/007S8ZIlgy1gjevqk8xesj316g0hmn0p.jpg)



![image-20201005233919174](https://tva1.sinaimg.cn/large/007S8ZIlgy1gjevv5476nj317q0psapv.jpg)





## 5.3  泛型数组列表

泛型数组列表允许在运行时确定数组的大小。在添加或删除元素时，具有自动调节数组容量的功能，而不需要为此编写任何代码。

ArrayList是一个采用**类型参数**（type parameter）的**泛型类**（generic class）。

如果调用add且内部数组已经满了，数组列表就将自动地创建一个更大的数组，并将所有的对象从较小的数组中拷贝到较大的数组中。



如果已经清楚或能够估计出数组可能存储的元素数量，就可以在填充数组之前调用ensureCapacity方法：

```java
import java.util.ArrayList;

public class GenericType {
    public static void main(String[] args) {
        ArrayList arrayList = new ArrayList();
        arrayList.ensureCapacity(100);
    }
}

```



一旦能够确认数组列表的大小不再发生变化，就可以调用trimToSize方法。这个方法将存储区域的大小调整为当前元素数量所需要饿存储空间数目。垃圾回收器将回收多余的存储空间。

```java
import java.util.ArrayList;

public class GenericType {
    public static void main(String[] args) {
        ArrayList arrayList = new ArrayList();
        arrayList.ensureCapacity(100);
        arrayList.trimToSize();
    }
}

```

![image-20201008230901378](https://tva1.sinaimg.cn/large/007S8ZIlgy1gjibuoavyvj312w0nik36.jpg)



### 5.3.1 访问数组列表元素

使用get和set方法实现访问或改变数组元素的操作：

```
staff.set(i,harry);
```

等价于对数组a的元素赋值（数组的下标从0开始）：

```java
a[i] = harray;
```



**灵活扩展和访问数组的方法**

```java
ArrayList<X> list = new ArrayList<>();
while(...){
	x = ...;
	list.add(x);
}

X[] a = new X[list.size()];
list.toArray(a);
```





toArray方法将List专护为数组对象。

```java
Integer[] array = new Integer[arrayList.size()];
arrayList.toArray(array);
```



除了在数组列表的尾部追加元素之外，还可以在数组列表的中间插入元素，使用带索引的add方法。

```java
int n = staff.size()/2;
staff.add(n,e);
```

在arraylist中，为了插入一个新元素，位于n之后的所有元素都要向后移动一个位置。如果插入新元素后，数组列表的大小超过了容量，数组列表就会被重新分配存储空间。

```java
Employee e = staff.remove(n)
```

位于这个位置之后的所有元素都向前移动一个位置，并且数组大小减1





![image-20201013000547296](https://tva1.sinaimg.cn/large/007S8ZIlgy1gjmzyuf6pyj31050u0drb.jpg)





### 5.3.2 类型化与原始数组列表的兼容性



介于兼容性的考虑，编译器在对类型转换进行检查之后，如果没有发现违反规则的现象，就将所有的类型转换化数组列表转换成原始ArrayList对象。在程序运行时，所有的数组列表都是一样的，即没有虚拟机中的类型参数。因此，类型转换（ArrayList）和(ArrayList< Employee >)将执行相同的类型检查。





## 5.4 对象包装器与自动装箱



**包装器** ：有时，需要将int这样的基本类型转换为对象。所有的基本类型都有一个与之对应的类。例如，Integer类对应基本类型int。通常，这些类称为包装器（wrapper）。



包装类型有：Integer、Long、Float、Double、Short、Byte、Character、 Void和Boolean（前6个类拍很于公共的超类Number）。



对象包装器类是不可变的，即一旦构造了包装器，就不允许更改包装在其中的值。同时，对象包装器类还是final，因此不能定义它们的子类。



这里就用到了Integer对象包装器类。我们可以声明一个**Integer**对象的数组列表。



```java
ArrayList<Integer> list = new ArrayList<>();
```



**自动装箱（autoboxing）** 将int类型元素转化成Integer

有一个很有用的特性，从而更加便于添加int类型的元素到ArrayList< Integer >中。下面调用

```java
list.add(3);
```

将自动地变换成

```java
list.add(Integer.valueOf(3));
```



**自动拆箱**

```java
int n = list.get(i);
```

翻译成：

```java
int n = list.get(i).intValue();
```

基本类型与它们的包装器是一样的，但是相等性不同。

`==`运算符也可以应用于对象包装器对象，只不过检测的是对象是否指向同一个存储区域，因此，下面的比较通常不会成立：

```java
Integer a = 1000;
Integer b = 1000;
if (a==b) ...
```

然而，Java实现有**可能**让它成立。



注释：自动装箱规范要求**boolean**、**byte**、**char**<= 127，介于-128 ~ 127之间的short和int被包装到固定的对象中。例如，如果在前面的例子中将a和b初始化为100，对它们进行比较的结果一定成立。



自动装箱有可能会抛出**NullPointerException**异常

```java
Integer n = null;
System.out.println(2*n);
```

如果表达式混用Integer和Double类型，Integer值会自动拆箱，提升为double，再装箱为Double:

```java
Integer n = 1;
Double x = 2.0;
System.out.println(true?n:x);
```



装箱和拆箱是**编译器**认可的，而不是虚拟机。编译器在生成类的字节码时，插入必要的方法调用。虚拟机只是执行这些字节码。



另外一个好处是，可以将某些基本方法放在包装器中，例如，将一个数字字符串转换成数值。

如果将字符串转换成整型，可以使用下面这条语句：

```java
int x = Integer.parseInt(s);
```



由于Java方法都是**值传递**，所以**Integer对象是不可变的**：包含在包装器中的内容不会改变。不能使用这些包装器类创建修改数值参数的方法。

```java
public class demo26 {
    public static void main(String[] args) {
        Integer b = 1000;
        changePacakge(b);
        System.out.println("->"+b);
    }

    public static void changePacakge(Integer a){
        a=100;
        System.out.println(a);
    }
}

```





![image-20201016145955977](https://tva1.sinaimg.cn/large/007S8ZIlgy1gjr6o5jttcj30uk0sqtk9.jpg)







## 5.5 参数数量可变的方法



在Java SE 5.0 以前的版本中，每个Java方法都有固定数量的参数。想再的版本可以用可变的参数数量调用的方法（有时称为**"变参"**方法）

对于printf方法，可以使用如下方法调用

```java
System.out.printf("%d",n);
和
System.out.printf("%d %s",n,"widgets");
```



在上面两条语句中，尽管一个调用包含两个参数，另一个调用包含三个参数，但它们调用的都是同一个方法。

printf方法是这样定义的：

```java
public class PrintStream
{
	publit PrintStream printf(String fmt, Object... args){ return format(fmt,args);}
}
```

这里的省略号...， 是Java代码的一部分，它表示这个方法可以接收任意数量的对象。

这里的Object... 参数类型与 Object[] 功能完全一样。



```java
public static void main(String... args) {}
等同于
public static void main(String[] args) {}
```



用户也可以自己定义可变参数的方法，可以是**任意类型**， 也可以是基本类型。下面代码用于计算若干个数值的最大值。

```java
public class demo26 {
    public static void main(String... args) {
       double m = max(3.1,40.4,-5);
    }
  
    public static double max(double... values){
        double largest = Double.NEGATIVE_INFINITY;
        for(double v:values) if(v>largest) largest = v;
        return largest;
    }
}
```



## 5.6 枚举类



枚举类

```java
public enum Size{SMALL, MEDIUM, LARGE, EXTRA_LARGE}
```

实际上这个声明定义的类型是一个类，它刚好有4个实例，再次尽量不要构造新对象。

比较两个枚举类型值时，永远不要调用equals，而尽量使用"=="方法。

如果需要的话，枚举类型中可以添加构造器，方法和域。

```java
enum Size{
    SMALL("S"),MEDIUM("M"),LARGE("L"),EXTRA_LARGE("XL");
	  private String s;
  
    Size(String s) {
        this.s = s;
    }
    public String getAbbreviation(){
        return s;
    }
   
}
```

Size.SMALL.toString()方法：

toString的逆方法时静态方法valueOf。例如，语句

```
Size s = Enum.valueOf(Size.class,"SMALL");
```

可以将s设置为Size.SMALL

每个枚举类都有一个静态的values方法，将返回一个包含全部枚举类型的数组。

```java
Size[] vlaues = Size.values();
```





```java
package enums;

import java.util.Scanner;

public class EnumTest {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        System.out.println("Enter a size:{SMALL, MEDIUM, LARGE, EXTRA_LARGE}");
        String input = in.next().toUpperCase();

        Size size = Enum.valueOf(Size.class,input);
        System.out.println("size="+size);
        System.out.println("s="+size.getAbbreviation());
        if(size==Size.EXTRA_LARGE){
            System.out.println("Good job -- you paid attention");
        }
    }

}

enum Size{
    SMALL("S"),MEDIUM("M"),LARGE("L"),EXTRA_LARGE("XL");

    Size(String s) {
        this.s = s;
    }
    public String getAbbreviation(){
        return s;
    }
    private String s;

}

```





![image-20201016154642657](https://tva1.sinaimg.cn/large/007S8ZIlgy1gjr80salfoj31080e6wla.jpg)



## 5.7 反射



**反射库**提供了一个非常精心设计的工具集，以便能够动态操纵Java代码的程序。

能够分析类能力的程序称为反射。反射机制的功能极其强大，在下面可以看到，反射机制可以用来：

- 运行时分析类的能力
- 在运行时查看对象，例如，编写一个toString方法供所有类使用。
- 实现通用的数组操作代码。
- 利用Method对象。



反射时一种功能强大且复杂的机制，使用它的主要是工具的构造者，而不是应用程序员。



### 5.7.1 Class类





### 5.7.2  捕获异常





### 5.7.6 调用任意方法



## 5.8 继承的设计技巧

1. 将公共操作和域放在超类

2. 不要使用受保护的域protected
3. 使用继承实现“is-a”关系
4. 除非所有继承的方法都有意义，否则不要使用继承

5. 在覆盖方法时，不要改变预期的行为

6. 使用多态，而非类型信息

7. 不要过多地使用反射

