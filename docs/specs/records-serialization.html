<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc,fixuphtml" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Record Serialization (Preview)</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <link rel="stylesheet" href="../resources/jdk-default.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  <link rel="stylesheet" href="../resources/spec-changes.css" />
</head>
<body>
<header id="title-block-header">
<h1 class="title">Record Serialization (Preview)</h1>
<p class="subtitle">Changes to the Java® Object Serialization Specification Specification • Version 14.0.2+12-46</p>
</header>
<nav id="TOC" title="Table Of Contents">
<ul>
<li><a href="#system-architecture">1 - System Architecture</a><ul>
<li><a href="#overview">1.1 Overview</a></li>
<li><a href="#writing-to-an-object-stream"><strong>1.2 Writing to an Object Stream</strong></a></li>
<li><a href="#reading-from-an-object-stream">1.3 Reading from an Object Stream</a></li>
<li><a href="#object-streams-as-containers">1.4 Object Streams as Containers</a></li>
<li><a href="#defining-serializable-fields-for-a-class">1.5 Defining Serializable Fields for a Class</a></li>
<li><a href="#documenting-serializable-fields-and-data-for-a-class">1.6 Documenting Serializable Fields and Data for a Class</a></li>
<li><a href="#accessing-serializable-fields-of-a-class">1.7 Accessing Serializable Fields of a Class</a></li>
<li><a href="#the-objectoutput-interface">1.8 The ObjectOutput Interface</a></li>
<li><a href="#the-objectinput-interface">1.9 The ObjectInput Interface</a></li>
<li><a href="#the-serializable-interface">1.10 The Serializable Interface</a></li>
<li><a href="#the-externalizable-interface">1.11 The Externalizable Interface</a></li>
<li><a href="#serialization-of-enum-constants">1.12 Serialization of Enum Constants</a></li>
<li><a href="#serialization-of-records"><strong>1.13 Serialization of Records </strong></a></li>
<li><a href="#circular-references"><strong>1.14 Circular References </strong></a></li>
<li><a href="#protecting-sensitive-information">1.1<del>3</del><strong>5</strong> Protecting Sensitive Information</a></li>
</ul></li>
<li><a href="#object-output-classes">2 - Object Output Classes</a><ul>
<li><a href="#the-objectoutputstream-class"><strong>2.1 The ObjectOutputStream Class</strong></a></li>
<li><a href="#the-objectoutputstream.putfield-class">2.2 The ObjectOutputStream.PutField Class</a></li>
<li><a href="#the-writeobject-method">2.3 The writeObject Method</a></li>
<li><a href="#the-writeexternal-method">2.4 The writeExternal Method</a></li>
<li><a href="#the-writereplace-method">2.5 The writeReplace Method</a></li>
<li><a href="#the-useprotocolversion-method">2.6 The useProtocolVersion Method</a></li>
</ul></li>
<li><a href="#object-input-classes">3 - Object Input Classes</a><ul>
<li><a href="#the-objectinputstream-class"><strong>3.1 The ObjectInputStream Class</strong></a></li>
<li><a href="#the-objectinputstream.getfield-class">3.2 The ObjectInputStream.GetField Class</a></li>
<li><a href="#the-objectinputvalidation-interface">3.3 The ObjectInputValidation Interface</a></li>
<li><a href="#the-readobject-method">3.4 The readObject Method</a></li>
<li><a href="#the-readobjectnodata-method">3.5 The readObjectNoData Method</a></li>
<li><a href="#the-readexternal-method">3.6 The readExternal Method</a></li>
<li><a href="#the-readresolve-method">3.7 The readResolve Method</a></li>
</ul></li>
<li><a href="#class-descriptors">4 - Class Descriptors</a><ul>
<li><a href="#the-objectstreamclass-class">4.1 The ObjectStreamClass Class</a></li>
<li><a href="#dynamic-proxy-class-descriptors">4.2 Dynamic Proxy Class Descriptors</a></li>
<li><a href="#serialized-form">4.3 Serialized Form</a></li>
<li><a href="#the-objectstreamfield-class">4.4 The ObjectStreamField Class</a></li>
<li><a href="#inspecting-serializable-classes">4.5 Inspecting Serializable Classes</a></li>
<li><a href="#stream-unique-identifiers"><strong>4.6 Stream Unique Identifiers</strong></a></li>
</ul></li>
<li><a href="#versioning-of-serializable-objects">5 - Versioning of Serializable Objects</a><ul>
<li><a href="#overview-1">5.1 Overview</a></li>
<li><a href="#goals">5.2 Goals</a></li>
<li><a href="#assumptions">5.3 Assumptions</a></li>
<li><a href="#whos-responsible-for-versioning-of-streams">5.4 Who's Responsible for Versioning of Streams</a></li>
<li><a href="#compatible-java-type-evolution">5.5 Compatible Java Type Evolution</a></li>
<li><a href="#type-changes-affecting-serialization">5.6 Type Changes Affecting Serialization</a><ul>
<li><a href="#incompatible-changes">5.6.1 Incompatible Changes</a></li>
<li><a href="#compatible-changes"><strong>5.6.2 Compatible Changes</strong></a></li>
</ul></li>
</ul></li>
<li><a href="#object-serialization-stream-protocol">6 - Object Serialization Stream Protocol</a><ul>
<li><a href="#overview-2">6.1 Overview</a></li>
<li><a href="#stream-elements">6.2 Stream Elements</a></li>
<li><a href="#stream-protocol-versions">6.3 Stream Protocol Versions</a></li>
<li><a href="#grammar-for-the-stream-format">6.4 Grammar for the Stream Format</a><ul>
<li><a href="#rules-of-the-grammar">6.4.1 Rules of the Grammar</a></li>
<li><a href="#terminal-symbols-and-constants">6.4.2 Terminal Symbols and Constants</a><ul>
<li><a href="#example">Example</a></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
</nav>
<main><p>This document describes changes to the <a href="https://docs.oracle.com/en/java/javase/12/docs/specs/serialization/">Java Object Serialization Specification</a> to support serializable records. See JEP draft <a href="https://openjdk.java.net/jeps/8222777">8222777</a>.</p>
<p>Changes are described with respect to existing sections of the JLS. New text is indicated <strong>like this</strong> and deleted text is indicated <del>like this</del>. Explanation and discussion, as needed, is set aside in grey boxes.</p>
<hr />
<h1 id="system-architecture">1 - System Architecture</h1>
<h2 id="overview">1.1 Overview</h2>
<p>The ability to store and retrieve Java<sup>TM</sup> objects is essential to building all but the most transient applications. The key to storing and retrieving objects in a serialized form is representing the state of objects sufficient to reconstruct the object(s). Objects to be saved in the stream may support either the <code>Serializable</code> or the <code>Externalizable</code> interface. For Java<sup>TM</sup> objects, the serialized form must be able to identify and verify the Java<sup>TM</sup> class from which the contents of the object were saved and to restore the contents to a new instance. For serializable objects, the stream includes sufficient information to restore the fields in the stream to a compatible version of the class. For Externalizable objects, the class is solely responsible for the external format of its contents.</p>
<p>Objects to be stored and retrieved frequently refer to other objects. Those other objects must be stored and retrieved at the same time to maintain the relationships between the objects. When an object is stored, all of the objects that are reachable from that object are stored as well.</p>
<p>The goals for serializing Java<sup>TM</sup> objects are to:</p>
<ul>
<li>Have a simple yet extensible mechanism.</li>
<li>Maintain the Java<sup>TM</sup> object type and safety properties in the serialized form.</li>
<li>Be extensible to support marshaling and unmarshaling as needed for remote objects.</li>
<li>Be extensible to support simple persistence of Java<sup>TM</sup> objects.</li>
<li>Require per class implementation only for customization.</li>
<li>Allow the object to define its external format.</li>
</ul>
<h2 id="writing-to-an-object-stream"><strong>1.2 Writing to an Object Stream</strong></h2>
<div class="editorial">
<p>Minor rewording in this subsection</p>
</div>
<p>Writing objects and primitives to a stream is a straightforward process. For example:</p>
<pre><code>// Serialize today&#39;s date to a file.
    FileOutputStream f = new FileOutputStream(&quot;tmp&quot;);
    ObjectOutput s = new ObjectOutputStream(f);
    s.writeObject(&quot;Today&quot;);
    s.writeObject(new Date());
    s.flush();</code></pre>
<p>First an <code>OutputStream</code>, in this case a <code>FileOutputStream</code>, is needed to receive the bytes. Then an <code>ObjectOutputStream</code> is created that writes to the <code>FileOutputStream</code>. Next, the string &quot;Today&quot; and a Date object are written to the stream. More generally, objects are written with the <code>writeObject</code> method and primitives are written to the stream with the methods of <code>DataOutput</code>.</p>
<p>The <code>writeObject</code> method (see <a href="output.html#the-writeobject-method">Section 2.3, &quot;The writeObject Method&quot;</a>) serializes the specified object and traverses its references to other objects in the object graph recursively to create a complete serialized representation of the graph. Within a stream, the first reference to any object results in the object being serialized or externalized and the assignment of a handle for that object. Subsequent references to that object are encoded as the handle. <del>Using object handles preserves sharing and circular references that occur naturally in object graphs. Subsequent references to an object use only the handle allowing a very compact representation.</del> <strong>The use of handles preserves the sharing of objects that occurs naturally in object graphs, and allows for circular references between objects (that is, cycles in the graph).</strong></p>
<p>Special handling is required for arrays, enum constants, and objects of type <code>Class</code>, <code>ObjectStreamClass</code>, and <code>String</code>. Other objects must implement either the <code>Serializable</code> or the <code>Externalizable</code> interface to be saved in or restored from a stream.</p>
<p>Primitive data types are written to the stream with the methods in the <code>DataOutput</code> interface, such as <code>writeInt</code>, <code>writeFloat</code>, or <code>writeUTF</code>. Individual bytes and arrays of bytes are written with the methods of <code>OutputStream</code>. Except for serializable fields, primitive data is written to the stream in block-data records, with each record prefixed by a marker and an indication of the number of bytes in the record.</p>
<p><code>ObjectOutputStream</code> can be extended to customize the information about classes in the stream or to replace objects to be serialized. Refer to the <code>annotateClass</code> and <code>replaceObject</code> method descriptions for details.</p>
<h2 id="reading-from-an-object-stream">1.3 Reading from an Object Stream</h2>
<p>Reading an object from a stream, like writing, is straightforward:</p>
<pre><code>// Deserialize a string and date from a file.
    FileInputStream in = new FileInputStream(&quot;tmp&quot;);
    ObjectInputStream s = new ObjectInputStream(in);
    String today = (String)s.readObject();
    Date date = (Date)s.readObject();</code></pre>
<p>First an <code>InputStream</code>, in this case a <code>FileInputStream</code>, is needed as the source stream. Then an <code>ObjectInputStream</code> is created that reads from the <code>InputStream</code>. Next, the string &quot;Today&quot; and a Date object are read from the stream. Generally, objects are read with the <code>readObject</code> method and primitives are read from the stream with the methods of <code>DataInput</code>.</p>
<p>The <code>readObject</code> method deserializes the next object in the stream and traverses its references to other objects recursively to create the complete graph of objects serialized.</p>
<p>Primitive data types are read from the stream with the methods in the <code>DataInput</code> interface, such as <code>readInt</code>, <code>readFloat</code>, or <code>readUTF</code>. Individual bytes and arrays of bytes are read with the methods of <code>InputStream</code>. Except for serializable fields, primitive data is read from block-data records.</p>
<p><code>ObjectInputStream</code> can be extended to utilize customized information in the stream about classes or to replace objects that have been deserialized. Refer to the <code>resolveClass</code> and <code>resolveObject</code> method descriptions for details.</p>
<h2 id="object-streams-as-containers">1.4 Object Streams as Containers</h2>
<p>Object Serialization produces and consumes a stream of bytes that contain one or more primitives and objects. The objects written to the stream, in turn, refer to other objects, which are also represented in the stream. Object Serialization produces just one stream format that encodes and stores the contained objects.</p>
<p>Each object that acts as a container implements an interface which allows primitives and objects to be stored in or retrieved from it. These interfaces are the <code>ObjectOutput</code> and <code>ObjectInput</code> interfaces which:</p>
<ul>
<li>Provide a stream to write to and to read from</li>
<li>Handle requests to write primitive types and objects to the stream</li>
<li>Handle requests to read primitive types and objects from the stream</li>
</ul>
<p>Each object which is to be stored in a stream must explicitly allow itself to be stored and must implement the protocols needed to save and restore its state. Object Serialization defines two such protocols. The protocols allow the container to ask the object to write and read its state.</p>
<p>To be stored in an Object Stream, each object must implement either the <code>Serializable</code> or the <code>Externalizable</code> interface:</p>
<ul>
<li><p>For a <code>Serializable</code> class, Object Serialization can automatically save and restore fields of each class of an object and automatically handle classes that evolve by adding fields or supertypes. A serializable class can declare which of its fields are saved or restored, and write and read optional values and objects.</p></li>
<li><p>For an <code>Externalizable</code> class, Object Serialization delegates to the class complete control over its external format and how the state of the supertype(s) is saved and restored.</p></li>
</ul>
<h2 id="defining-serializable-fields-for-a-class">1.5 Defining Serializable Fields for a Class</h2>
<p>The serializable fields of a class can be defined two different ways. Default serializable fields of a class are defined to be the non-transient and non-static fields. This default computation can be overridden by declaring a special field in the <code>Serializable</code> class, <code>serialPersistentFields</code>. This field must be initialized with an array of <code>ObjectStreamField</code> objects that list the names and types of the serializable fields. The modifiers for the field are required to be private, static, and final. If the field's value is null or is otherwise not an instance of <code>ObjectStreamField[]</code>, or if the field does not have the required modifiers, then the behavior is as if the field were not declared at all.</p>
<p>For example, the following declaration duplicates the default behavior.</p>
<pre><code>class List implements Serializable {
    List next;

    private static final ObjectStreamField[] serialPersistentFields
                 = {new ObjectStreamField(&quot;next&quot;, List.class)};

}</code></pre>
<p>By using <code>serialPersistentFields</code> to define the Serializable fields for a class, there no longer is a limitation that a serializable field must be a field within the current definition of the <code>Serializable</code> class. The <code>writeObject</code> and <code>readObject</code> methods of the <code>Serializable</code> class can map the current implementation of the class to the serializable fields of the class using the interface that is described in <a href="#accessing-serializable-fields-of-a-class">Section 1.7, &quot;Accessing Serializable Fields of a Class&quot;</a>. Therefore, the fields for a <code>Serializable</code> class can change in a later release, as long as it maintains the mapping back to its Serializable fields that must remain compatible across release boundaries.</p>
<p><em>Note:</em> There is, however, a limitation to the use of this mechanism to specify serializable fields for inner classes. Inner classes can only contain final static fields that are initialized to constants or expressions built up from constants. Consequently, it is not possible to set <code>serialPersistentFields</code> for an inner class (though it is possible to set it for static member classes). For other restrictions pertaining to serialization of inner class instances, see section <a href="#the-serializable-interface">Section 1.10, &quot;The Serializable Interface&quot;</a>.</p>
<h2 id="documenting-serializable-fields-and-data-for-a-class">1.6 Documenting Serializable Fields and Data for a Class</h2>
<p>It is important to document the serializable state of a class to enable interoperability with alternative implementations of a Serializable class and to document class evolution. Documenting a serializable field gives one a final opportunity to review whether or not the field should be serializable. The serialization javadoc tags, <code>@serial</code>, <code>@serialField</code>, and <code>@serialData</code>, provide a way to document the serialized form for a Serializable class within the source code.</p>
<ul>
<li><p>The <code>@serial</code> tag should be placed in the javadoc comment for a default serializable field. The syntax is as follows: <code>@serial</code> <em>field-description</em> The optional <em>field-description</em> describes the meaning of the field and its acceptable values. The <em>field-description</em> can span multiple lines. When a field is added after the initial release, a <em><span class="citation" data-cites="since">@since</span></em> tag indicates the version the field was added. The <em>field-description</em> for <code>@serial</code> provides serialization-specific documentation and is appended to the javadoc comment for the field within the serialized form documentation.</p></li>
<li><p>The <code>@serialField</code> tag is used to document an <code>ObjectStreamField</code> component of a <code>serialPersistentFields</code> array. One of these tags should be used for each <code>ObjectStreamField</code> component. The syntax is as follows: <code>@serialField</code> <em>field-name field-type field-description</em></p></li>
<li><p>The <code>@serialData</code> tag describes the sequences and types of data written or read. The tag describes the sequence and type of optional data written by <code>writeObject</code> or all data written by the <code>Externalizable.writeExternal</code> method. The syntax is as follows: <code>@serialData</code> <em>data-description</em></p></li>
</ul>
<p>The javadoc application recognizes the serialization javadoc tags and generates a specification for each Serializable and Externalizable class. See <a href="examples.html#c.1-example-alternate-implementation-of-java.io.file">Section C.1, &quot;Example Alternate Implementation of java.io.File&quot;</a> for an example that uses these tags.</p>
<p>When a class is declared Serializable, the serializable state of the object is defined by serializable fields (by name and type) plus optional data. Optional data can only be written explicitly by the <code>writeObject</code> method of a <code>Serializable</code> class. Optional data can be read by the <code>Serializable</code> class' <code>readObject</code> method or serialization will skip unread optional data.</p>
<p>When a class is declared Externalizable, the data that is written to the stream by the class itself defines the serialized state. The class must specify the order, types, and meaning of each datum that is written to the stream. The class must handle its own evolution, so that it can continue to read data written by and write data that can be read by previous versions. The class must coordinate with the superclass when saving and restoring data. The location of the superclasses data in the stream must be specified.</p>
<p>The designer of a Serializable class must ensure that the information saved for the class is appropriate for persistence and follows the serialization-specified rules for interoperability and evolution. Class evolution is explained in greater detail in <a href="version.html">Chapter 5</a>, &quot;Versioning of Serializable Objects&quot;.</p>
<h2 id="accessing-serializable-fields-of-a-class">1.7 Accessing Serializable Fields of a Class</h2>
<p>Serialization provides two mechanisms for accessing the serializable fields in a stream:</p>
<ul>
<li>The default mechanism requires no customization</li>
<li>The Serializable Fields API allows a class to explicitly access/set the serializable fields by name and type</li>
</ul>
<p>The default mechanism is used automatically when reading or writing objects that implement the <code>Serializable</code> interface and do no further customization. The serializable fields are mapped to the corresponding fields of the class and values are either written to the stream from those fields or are read in and assigned respectively. If the class provides <code>writeObject</code> and <code>readObject</code> methods, the default mechanism can be invoked by calling <code>defaultWriteObject</code> and <code>defaultReadObject</code>. When the <code>writeObject</code> and <code>readObject</code> methods are implemented, the class has an opportunity to modify the serializable field values before they are written or after they are read.</p>
<p>When the default mechanism cannot be used, the serializable class can use the <code>putFields</code> method of <code>ObjectOutputStream</code> to put the values for the serializable fields into the stream. The <code>writeFields</code> method of <code>ObjectOutputStream</code> puts the values in the correct order, then writes them to the stream using the existing protocol for serialization. Correspondingly, the <code>readFields</code> method of <code>ObjectInputStream</code> reads the values from the stream and makes them available to the class by name in any order. See <a href="output.html#the-objectoutputstream.putfield-class">Section 2.2, &quot;The ObjectOutputStream.PutField Class&quot;</a> and <a href="input.html#the-objectinputstream.getfield-class">Section 3.2, &quot;The ObjectInputStream.GetField Class&quot;</a> for a detailed description of the Serializable Fields API.</p>
<h2 id="the-objectoutput-interface">1.8 The ObjectOutput Interface</h2>
<p>The <code>ObjectOutput</code> interface provides an abstract, stream-based interface to object storage. It extends the DataOutput interface so those methods can be used for writing primitive data types. Objects that implement this interface can be used to store primitives and objects.</p>
<pre><code>package java.io;

public interface ObjectOutput extends DataOutput
{
    public void writeObject(Object obj) throws IOException;
    public void write(int b) throws IOException;
    public void write(byte b[]) throws IOException;
    public void write(byte b[], int off, int len) throws IOException;
    public void flush() throws IOException;
    public void close() throws IOException;
}</code></pre>
<p><code>The</code> <code>writeObject</code> method is used to write an object. The exceptions thrown reflect errors while accessing the object or its fields, or exceptions that occur in writing to storage. If any exception is thrown, the underlying storage may be corrupted. If this occurs, refer to the object that is implementing this interface for more information.</p>
<h2 id="the-objectinput-interface">1.9 The ObjectInput Interface</h2>
<p>The <code>ObjectInput</code> interface provides an abstract stream based interface to object retrieval. It extends the <code>DataInput</code> interface so those methods for reading primitive data types are accessible in this interface.</p>
<pre><code>package java.io;

public interface ObjectInput extends DataInput
{
    public Object readObject()
        throws ClassNotFoundException, IOException;
    public int read() throws IOException;
    public int read(byte b[]) throws IOException;
    public int read(byte b[], int off, int len) throws IOException;
    public long skip(long n) throws IOException;
    public int available() throws IOException;
    public void close() throws IOException;
}</code></pre>
<p>The <code>readObject</code> method is used to read and return an object. The exceptions thrown reflect errors while accessing the objects or its fields or exceptions that occur in reading from the storage. If any exception is thrown, the underlying storage may be corrupted. If this occurs, refer to the object implementing this interface for additional information.</p>
<h2 id="the-serializable-interface">1.10 The Serializable Interface</h2>
<p>Object Serialization produces a stream with information about the Java<sup>TM</sup> classes for the objects which are being saved. For serializable objects, sufficient information is kept to restore those objects even if a different (but compatible) version of the implementation of the class is present. The <code>Serializable</code> interface is defined to identify classes which implement the serializable protocol:</p>
<pre><code>package java.io;

public interface Serializable {};</code></pre>
<p>A Serializable class must do the following:</p>
<ul>
<li><p>Implement the <code>java.io.Serializable</code> interface</p></li>
<li><p>Identify the fields that should be serializable</p>
<p>(Use the <code>serialPersistentFields</code> member to explicitly declare them serializable or use the transient keyword to denote nonserializable fields.)</p></li>
<li><p>Have access to the no-arg constructor of its first nonserializable superclass</p></li>
</ul>
<p>The class can optionally define the following methods:</p>
<ul>
<li><p>A <code>writeObject</code> method to control what information is saved or to append additional information to the stream</p></li>
<li><p>A <code>readObject</code> method either to read the information written by the corresponding <code>writeObject</code> method or to update the state of the object after it has been restored</p></li>
<li><p>A <code>writeReplace</code> method to allow a class to nominate a replacement object to be written to the stream</p>
<p>(See <a href="output.html#the-writereplace-method">Section 2.5, &quot;The writeReplace Method&quot;</a> for additional information.)</p></li>
<li><p>A <code>readResolve</code> method to allow a class to designate a replacement object for the object just read from the stream</p>
<p>(See <a href="input.html#the-readresolve-method">Section 3.7, &quot;The readResolve Method</a> for additional information.)</p></li>
</ul>
<p><code>ObjectOutputStream</code> and <code>ObjectInputStream</code> allow the serializable classes on which they operate to evolve (allow changes to the classes that are compatible with the earlier versions of the classes). See <a href="version.html#compatible-java-type-evolution">Section 5.5, &quot;Compatible Java Type Evolution&quot;</a> for information about the mechanism which is used to allow compatible changes.</p>
<p><em>Note:</em> Serialization of inner classes (i.e., nested classes that are not static member classes), including local and anonymous classes, is strongly discouraged for several reasons. Because inner classes declared in non-static contexts contain implicit non-transient references to enclosing class instances, serializing such an inner class instance will result in serialization of its associated outer class instance as well. Synthetic fields generated by <code>javac</code> (or other Java<sup>TM</sup> compilers) to implement inner classes are implementation dependent and may vary between compilers; differences in such fields can disrupt compatibility as well as result in conflicting default <code>serialVersionUID</code> values. The names assigned to local and anonymous inner classes are also implementation dependent and may differ between compilers. Since inner classes cannot declare static members other than compile-time constant fields, they cannot use the <code>serialPersistentFields</code> mechanism to designate serializable fields. Finally, because inner classes associated with outer instances do not have zero-argument constructors (constructors of such inner classes implicitly accept the enclosing instance as a prepended parameter), they cannot implement <code>Externalizable</code>. None of the issues listed above, however, apply to static member classes.</p>
<h2 id="the-externalizable-interface">1.11 The Externalizable Interface</h2>
<p>For Externalizable objects, only the identity of the class of the object is saved by the container; the class must save and restore the contents. The <code>Externalizable</code> interface is defined as follows:</p>
<pre><code>package java.io;

public interface Externalizable extends Serializable
{
    public void writeExternal(ObjectOutput out)
        throws IOException;

    public void readExternal(ObjectInput in)
        throws IOException, java.lang.ClassNotFoundException;
}</code></pre>
<p>The class of an Externalizable object must do the following:</p>
<ul>
<li><p>Implement the <code>java.io.Externalizable</code> interface</p></li>
<li><p>Implement a <code>writeExternal</code> method to save the state of the object</p>
<p>(It must explicitly coordinate with its supertype to save its state.)</p></li>
<li><p>Implement a <code>readExternal</code> method to read the data written by the <code>writeExternal</code> method from the stream and restore the state of the object</p>
<p>(It must explicitly coordinate with the supertype to save its state.)</p></li>
<li><p>Have the <code>writeExternal</code> and <code>readExternal</code> methods be solely responsible for the format, if an externally defined format is written</p>
<p><em>Note:</em> The <code>writeExternal</code> and <code>readExternal</code> methods are public and raise the risk that a client may be able to write or read information in the object other than by using its methods and fields. These methods must be used only when the information held by the object is not sensitive or when exposing it does not present a security risk.</p></li>
<li><p>Have a public no-arg constructor</p>
<p><em>Note:</em> Inner classes associated with enclosing instances cannot have no-arg constructors, since constructors of such classes implicitly accept the enclosing instance as a prepended parameter. Consequently the <code>Externalizable</code> interface mechanism cannot be used for inner classes and they should implement the <code>Serializable</code> interface, if they must be serialized. Several limitations exist for serializable inner classes as well, however; see <a href="#the-serializable-interface">Section 1.10, &quot;The Serializable Interface&quot;</a>, for a full enumeration.</p></li>
</ul>
<p>An Externalizable class can optionally define the following methods:</p>
<ul>
<li><p>A <code>writeReplace</code> method to allow a class to nominate a replacement object to be written to the stream</p>
<p>(See <a href="output.html#the-writereplace-method">Section 2.5, &quot;The writeReplace Method&quot;</a> for additional information.)</p></li>
<li><p>A <code>readResolve</code> method to allow a class to designate a replacement object for the object just read from the stream</p>
<p>(See <a href="input.html#the-readresolve-method">Section 3.7, &quot;The readResolve Method&quot;</a> for additional information.)</p></li>
</ul>
<h2 id="serialization-of-enum-constants">1.12 Serialization of Enum Constants</h2>
<p>Enum constants are serialized differently than ordinary serializable or externalizable objects. The serialized form of an enum constant consists solely of its name; field values of the constant are not present in the form. To serialize an enum constant, <code>ObjectOutputStream</code> writes the value returned by the enum constant's <code>name</code> method. To deserialize an enum constant, <code>ObjectInputStream</code> reads the constant name from the stream; the deserialized constant is then obtained by calling the <code>java.lang.Enum.valueOf</code> method, passing the constant's enum type along with the received constant name as arguments.</p>
<p>Like other serializable or externalizable objects, enum constants can function as the targets of back references appearing subsequently in the serialization stream.</p>
<p>The process by which enum constants are serialized cannot be customized: any class-specific <code>writeObject</code>, <code>readObject</code>, <code>readObjectNoData</code>, <code>writeReplace</code>, and <code>readResolve</code> methods defined by enum types are ignored during serialization and deserialization. Similarly, any <code>serialPersistentFields</code> or <code>serialVersionUID</code> field declarations are also ignored--all enum types have a fixed <code>serialVersionUID</code> of <code>0L</code>. Documenting serializable fields and data for enum types is unnecessary, since there is no variation in the type of data sent.</p>
<h2 id="serialization-of-records"><strong>1.13 Serialization of Records </strong></h2>
<div class="editorial">
<p>This is a new subsection</p>
</div>
<div class="inserted">
<p>Records are serialized differently than ordinary serializable or externalizable objects. The serialized form of a record object is a sequence of values derived from the record components. The stream format of a record object is the same as that of an ordinary object in the stream. During deserialization, if the local class equivalent of the specified stream class descriptor is a record class, then first the stream fields are read and reconstructed to serve as the record's component values; and second, a record object is created by invoking the record's <em>canonical</em> constructor with the component values as arguments (or the default value for component's type if a component value is absent from the stream).</p>
<p>Like other serializable or externalizable objects, record objects can function as the target of back references appearing subsequently in the serialization stream. However, a cycle in the graph where the record object is referred to, either directly or transitively, by one of its components, is not preserved. The record components are deserialized prior to the invocation of the record constructor, hence this limitation (see <a href="serial-arch.html#cyclic-references">Section 1.14, &quot;Circular References&quot;</a> for additional information).</p>
<p>The process by which record objects are serialized or externalized cannot be customized; any class-specific <code>writeObject</code>, <code>readObject</code>, <code>readObjectNoData</code>, <code>writeExternal</code>, and <code>readExternal</code> methods defined by record classes are ignored during serialization and deserialization. However, a substitute object to be serialized or a designate replacement may be specified, by the <code>writeReplace</code> and <code>readResolve</code> methods, respectively. Any <code>serialPersistentFields</code> field declaration is ignored. Documenting serializable fields and data for record classes is unnecessary, since there is no variation in the serial form, other than whether a substitute or replacement object is used. The <code>serialVersionUID</code> of a record class is <code>0L</code> unless explicitly declared. The requirement for matching serialVersionUID values is waived for record classes.</p>
</div>
<h2 id="circular-references"><strong>1.14 Circular References </strong></h2>
<div class="editorial">
<p>This is a new subsection</p>
</div>
<div class="inserted">
<p>As described in <a href="serial-arch.html#writing-to-an-object-stream">Section 1.2, &quot; Writing to an Object Stream&quot;</a>, the use of handles can preserve cyclic references that occur in object graphs.</p>
<p>A minimal contrived example, for illustration purposes only:</p>
<pre><code>    class Data implements Serializable {
        private static final long serialVersionUID = ...
        Object obj;
    }

    class Carrier implements Serializable {
        private static final long serialVersionUID = ...
        private final Data d;
        public Carrier(Data d) { this.d = d; }
        public Data d() { return d; }
    }

    // create an instance of both Data and Carrier, and a cycle between them
    Data d1 = new Data();
    Carrier c1 = new Carrier(d1);
    d1.obj = c1;

    // serialize
    ObjectOutputStream oos = new ObjectOutputStream(...);
    oos.writeObject(c1);

    // deserialize
    ObjectInputStream ois  = new ObjectInputStream(...);
    Carrier c2 = (Carrier) ois.readObject();</code></pre>
<p>When deserialized, the object, <code>c2</code>, will have its <code>d</code> field refer to an instance of <code>Data</code>, that will in turn have its <code>obj</code> field refer back to the same instance of <code>c2</code>. The identity of the object referred to by <code>c2</code> is equal to the identity of the object referred to by <code>c2.d().obj</code>, that is <code>c2 == c2.d().obj</code>.</p>
<p>The allocation of the object, <code>c2</code>, and the assignment of its handle, happen <em>before</em> the reconstruction of its field values (see <a href="input.html#the-objectinputstream-class">Section 3.1 &quot;The ObjectInputStream Class&quot;, step 12)</a>. This allows the field values (and their field values recursively) to refer to the handle for <code>c2</code> during deserialization. In this way, deserialization of ordinary objects supports cycles in the object graph.</p>
<p>Now consider if <code>Carrier</code> were a record class, as follows:</p>
<pre><code>    record Carrier(Data d) implements Serializable { }</code></pre>
<p>When deserialized, the object, <code>c2</code>, will have its <code>d</code> field refer to an instance of <code>Data</code>, that will in turn have its <code>obj</code> field refer to <code>null</code> (rather than referring to <code>c2</code>). The circular reference, through <code>d.obj</code>, in the original object graph, is not preserved during deserialization.</p>
<p>The allocation of the record object <code>c2</code>, and the assignment of its handle, happen <em>after</em> the reconstruction of its field values ( that is, the component values of the future record; see <a href="input.html#the-objectinputstream-class">Section 3.1 &quot;The ObjectInputStream Class&quot;, step 11</a>). While a handle for the record object is added to the set of known objects before the record component values are reconstructed, it has an initial value of <code>null</code>. The handle is assigned to the record object only after the record object has been constructed (through an invocation of its canonical constructor). Consequently, during deserialization of the record component values, references in the stream to the handle for the record object, will see the initial <code>null</code> value. As such, cycles targeting the record object from its components (or their fields transitively) are not preserved during deserialization.</p>
</div>
<h2 id="protecting-sensitive-information">1.1<del>3</del><strong>5</strong> Protecting Sensitive Information</h2>
<p>When developing a class that provides controlled access to resources, care must be taken to protect sensitive information and functions. During deserialization, the private state of the object is restored. For example, a file descriptor contains a handle that provides access to an operating system resource. Being able to forge a file descriptor would allow some forms of illegal access, since restoring state is done from a stream. Therefore, the serializing runtime must take the conservative approach and not trust the stream to contain only valid representations of objects. To avoid compromising a class, the sensitive state of an object must not be restored from the stream, or it must be reverified by the class. Several techniques are available to protect sensitive data in classes.</p>
<p>The easiest technique is to mark fields that contain sensitive data as <em>private transient</em>. Transient fields are not persistent and will not be saved by any persistence mechanism. Marking the field will prevent the state from appearing in the stream and from being restored during deserialization. Since writing and reading (of private fields) cannot be superseded outside of the class, the transient fields of the class are safe.</p>
<p>Particularly sensitive classes should not be serialized at all. To accomplish this, the object should not implement either the <code>Serializable</code> or the <code>Externalizable</code> interface.</p>
<p>Some classes may find it beneficial to allow writing and reading but specifically handle and revalidate the state as it is deserialized. The class should implement <code>writeObject</code> and <code>readObject</code> methods to save and restore only the appropriate state. If access should be denied, throwing a <code>NotSerializableException</code> will prevent further access.</p>
<hr />
<h1 id="object-output-classes">2 - Object Output Classes</h1>
<h2 id="the-objectoutputstream-class"><strong>2.1 The ObjectOutputStream Class</strong></h2>
<div class="editorial">
<p>An additional step has been added</p>
</div>
<p>Class <code>ObjectOutputStream</code> implements object serialization. It maintains the state of the stream including the set of objects already serialized. Its methods control the traversal of objects to be serialized to save the specified objects and the objects to which they refer.</p>
<pre><code>package java.io;

public class ObjectOutputStream
    extends OutputStream
    implements ObjectOutput, ObjectStreamConstants
{
    public ObjectOutputStream(OutputStream out)
        throws IOException;

    public final void writeObject(Object obj)
        throws IOException;

    public void writeUnshared(Object obj)
        throws IOException;

    public void defaultWriteObject()
        throws IOException, NotActiveException;

    public PutField putFields()
        throws IOException;

    public writeFields()
        throws IOException;

    public void reset() throws IOException;

    protected void annotateClass(Class cl) throws IOException;

    protected void writeClassDescriptor(ObjectStreamClass desc)
        throws IOException;

    protected Object replaceObject(Object obj) throws IOException;

    protected boolean enableReplaceObject(boolean enable)
        throws SecurityException;

    protected void writeStreamHeader() throws IOException;

    public void write(int data) throws IOException;

    public void write(byte b[]) throws IOException;

    public void write(byte b[], int off, int len) throws IOException;

    public void flush() throws IOException;

    protected void drain() throws IOException;

    public void close() throws IOException;

    public void writeBoolean(boolean data) throws IOException;

    public void writeByte(int data) throws IOException;

    public void writeShort(int data) throws IOException;

    public void writeChar(int data) throws IOException;

    public void writeInt(int data) throws IOException;

    public void writeLong(long data) throws IOException;

    public void writeFloat(float data) throws IOException;

    public void writeDouble(double data) throws IOException;

    public void writeBytes(String data) throws IOException;

    public void writeChars(String data) throws IOException;

    public void writeUTF(String data) throws IOException;

    // Inner class to provide access to serializable fields.
    abstract static public class PutField
    {
        public void put(String name, boolean value)
            throws IOException, IllegalArgumentException;

        public void put(String name, char data)
            throws IOException, IllegalArgumentException;

        public void put(String name, byte data)
            throws IOException, IllegalArgumentException;

        public void put(String name, short data)
            throws IOException, IllegalArgumentException;

        public void put(String name, int data)
            throws IOException, IllegalArgumentException;

        public void put(String name, long data)
            throws IOException, IllegalArgumentException;

        public void put(String name, float data)
            throws IOException, IllegalArgumentException;

        public void put(String name, double data)
            throws IOException, IllegalArgumentException;

        public void put(String name, Object data)
            throws IOException, IllegalArgumentException;
    }

    public void useProtocolVersion(int version) throws IOException;

    protected ObjectOutputStream()
        throws IOException;

     protected writeObjectOverride()
        throws NotActiveException, IOException;
}</code></pre>
<p>The single-argument <code>ObjectOutputStream</code> constructor creates an <code>ObjectOutputStream</code> that serializes objects to the given <code>OutputStream</code>. The constructor calls <code>writeStreamHeader</code> to write a magic number and version to the stream that will be read and verified by a corresponding call to <code>readStreamHeader</code> in the single-argument <code>ObjectInputStream</code> constructor. If a security manager is installed, this constructor checks for the <code>&quot;enableSubclassImplementation&quot;</code> <code>SerializablePermission</code> when invoked directly or indirectly by the constructor of a subclass which overrides the <code>putFields</code> and/or <code>writeUnshared</code> methods.</p>
<p>The <code>writeObject</code> method is used to serialize an object to the stream. An object is serialized as follows:</p>
<ol type="1">
<li><p>If a subclass is overriding the implementation, call the <code>writeObjectOverride</code> method and return. Overriding the implementation is described at the end of this section.</p></li>
<li><p>If there is data in the block-data buffer, the data is written to the stream and the buffer is reset.</p></li>
<li><p>If the object is null, null is put in the stream and <code>writeObject</code> returns.</p></li>
<li><p>If the object has been previously replaced, as described in Step 8, write the handle of the replacement to the stream and <code>writeObject</code> returns.</p></li>
<li><p>If the object has already been written to the stream, its handle is written to the stream and <code>writeObject</code> returns.</p></li>
<li><p>If the object is a <code>Class</code>, the corresponding <code>ObjectStreamClass</code> is written to the stream, a handle is assigned for the class, and <code>writeObject</code> returns.</p></li>
<li><p>If the object is an <code>ObjectStreamClass</code>, a handle is assigned to the object, after which it is written to the stream using one of the class descriptor formats described in <a href="class.html#serialized-form">Section 4.3, &quot;Serialized Form&quot;</a>. In versions 1.3 and later of the Java 2 SDK, Standard Edition, the <code>writeClassDescriptor</code> method is called to output the <code>ObjectStreamClass</code> if it represents a class that is not a dynamic proxy class, as determined by passing the associated <code>Class</code> object to the <code>isProxyClass</code> method of <code>java.lang.reflect.Proxy</code>. Afterwards, an annotation for the represented class is written: if the class is a dynamic proxy class, then the <code>annotateProxyClass</code> method is called; otherwise, the <code>annotateClass</code> method is called. The <code>writeObject</code> method then returns.</p></li>
<li><p>Process potential substitutions by the class of the object and/or by a subclass of <code>ObjectInputStream</code>.</p>
<ol type="a">
<li><p>If the class of an object is not an enum type and defines the appropriate <code>writeReplace</code> method, the method is called. Optionally, it can return a substitute object to be serialized.</p></li>
<li><p>Then, if enabled by calling the <code>enableReplaceObject</code> method, the <code>replaceObject</code> method is called to allow subclasses of <code>ObjectOutputStream</code> to substitute for the object being serialized. If the original object was replaced in the previous step, the <code>replaceObject</code> method is called with the replacement object.</p></li>
</ol>
<p>If the original object was replaced by either one or both steps above, the mapping from the original object to the replacement is recorded for later use in Step 4. Then, Steps 3 through 7 are repeated on the new object.</p>
<p>If the replacement object is not one of the types covered by Steps 3 through 7, processing resumes using the replacement object at Step 10.</p></li>
<li><p><a id="java-lang-string-encoding"></a> If the object is a <code>java.lang.String,</code> the string is written as length information followed by the contents of the string encoded in modified UTF-8. For details, refer to <a href="protocol.html#stream-elements">Section 6.2, &quot;Stream Elements&quot;</a>. A handle is assigned to the string, and <code>writeObject</code> returns.</p></li>
<li><p>If the object is an array, <code>writeObject</code> is called recursively to write the <code>ObjectStreamClass</code> of the array. The handle for the array is assigned. It is followed by the length of the array. Each element of the array is then written to the stream, after which <code>writeObject</code> returns.</p></li>
<li><p>If the object is an enum constant, the <code>ObjectStreamClass</code> for the enum type of the constant is written by recursively calling <code>writeObject</code>. It will appear in the stream only the first time it is referenced. A handle is assigned for the enum constant. Next, the value returned by the <code>name</code> method of the enum constant is written as a <code>String</code> object, as described in step 9. Note that if the same name string has appeared previously in the stream, a back reference to it will be written. The <code>writeObject</code> method then returns.</p></li>
</ol>
<div class="inserted">
<ol start="12" type="1">
<li><p>If the object is a record object, the <code>ObjectStreamClass</code> for the class of the record object is written by recursively calling <code>writeObject</code>. It will appear in the stream only the first time it is referenced. A handle is assigned for the record object.</p>
<p>The components of the record object are written to the stream.</p>
<pre><code> a.  If the record object is serializable or externalizable, the record
     components are written, as if by invoking the `defaultWriteObject`
     method.

 b.  If the object is neither serializable or externalizable, the
     `NotSerializableException` is thrown.</code></pre>
The <code>writeObject</code> method then returns.</li>
</ol>
</div>
<p>1<del>2</del><strong>3</strong>. For regular objects, the <code>ObjectStreamClass</code> for the class of the object is written by recursively calling <code>writeObject</code>. It will appear in the stream only the first time it is referenced. A handle is assigned for the object.</p>
<pre><code>    The contents of the object are written to the stream.

    a.  If the object is serializable, the highest serializable class is
        located. For that class, and each derived class, that class&#39;s fields
        are written. If the class does not have a `writeObject` method, the
        `defaultWriteObject` method is called to write the serializable fields
        to the stream. If the class does have a `writeObject` method, it is
        called. It may call `defaultWriteObject` or `putFields` and
        `writeFields` to save the state of the object, and then it can write
        other information to the stream.

    b.  If the object is externalizable, the `writeExternal` method of the
        object is called.

    c.  If the object is neither serializable or externalizable, the
        `NotSerializableException` is thrown.</code></pre>
<p>Exceptions may occur during the traversal or may occur in the underlying stream. For any subclass of <code>IOException</code>, the exception is written to the stream using the exception protocol and the stream state is discarded. If a second <code>IOException</code> is thrown while attempting to write the first exception into the stream, the stream is left in an unknown state and <code>StreamCorruptedException</code> is thrown from <code>writeObject</code>. For other exceptions, the stream is aborted and left in an unknown and unusable state.</p>
<p>The <code>writeUnshared</code> method writes an &quot;unshared&quot; object to the <code>ObjectOutputStream</code>. This method is identical to <code>writeObject</code>, except that it always writes the given object as a new, unique object in the stream (as opposed to a back-reference pointing to a previously serialized instance). Specifically:</p>
<ul>
<li><p>An object written via <code>writeUnshared</code> is always serialized in the same manner as a newly appearing object (an object that has not been written to the stream yet), regardless of whether or not the object has been written previously.</p></li>
<li><p>If <code>writeObject</code> is used to write an object that has been previously written with <code>writeUnshared</code>, the previous <code>writeUnshared</code> operation is treated as if it were a write of a separate object. In other words, <code>ObjectOutputStream</code> will never generate back-references to object data written by calls to <code>writeUnshared</code>.</p></li>
</ul>
<p>While writing an object via <code>writeUnshared</code> does not in itself guarantee a unique reference to the object when it is deserialized, it allows a single object to be defined multiple times in a stream, so that multiple calls to the <code>ObjectInputStream.readUnshared</code> method (see <a href="input.html#the-objectinputstream-class">Section 3.1, &quot;The ObjectInputStream Class&quot;</a>) by the receiver will not conflict. Note that the rules described above only apply to the base-level object written with <code>writeUnshared</code>, and not to any transitively referenced sub-objects in the object graph to be serialized.</p>
<p>The <code>defaultWriteObject</code> method implements the default serialization mechanism for the current class. This method may be called only from a class's <code>writeObject</code> method. The method writes all of the serializable fields of the current class to the stream. If called from outside the <code>writeObject</code> method, the <code>NotActiveException</code> is thrown.</p>
<p>The <code>putFields</code> method returns a <code>PutField</code> object the caller uses to set the values of the serializable fields in the stream. The fields may be set in any order. After all of the fields have been set, <code>writeFields</code> must be called to write the field values in the canonical order to the stream. If a field is not set, the default value appropriate for its type will be written to the stream. This method may only be called from within the <code>writeObject</code> method of a serializable class. It may not be called more than once or if <code>defaultWriteObject</code> has been called. Only after <code>writeFields</code> has been called can other data be written to the stream.</p>
<p>The <code>reset</code> method resets the stream state to be the same as if it had just been constructed. <code>Reset</code> will discard the state of any objects already written to the stream. The current point in the stream is marked as reset, so the corresponding <code>ObjectInputStream</code> will reset at the same point. Objects previously written to the stream will not be remembered as already having been written to the stream. They will be written to the stream again. This is useful when the contents of an object or objects must be sent again. <code>Reset</code> may not be called while objects are being serialized. If called inappropriately, an <code>IOException</code> is thrown.</p>
<p>Starting with the Java 2 SDK, Standard Edition, v1.3, the <code>writeClassDescriptor</code> method is called when an <code>ObjectStreamClass</code> needs to be serialized. <code>writeClassDescriptor</code> is responsible for writing a representation of the <code>ObjectStreamClass</code> to the serialization stream. Subclasses may override this method to customize the way in which class descriptors are written to the serialization stream. If this method is overridden, then the corresponding <code>readClassDescriptor</code> method in <code>ObjectInputStream</code> should also be overridden to reconstitute the class descriptor from its custom stream representation. By default, <code>writeClassDescriptor</code> writes class descriptors according to the format specified in <a href="protocol.html#grammar-for-the-stream-format">Section 6.4, &quot;Grammar for the Stream Format&quot;</a>. Note that this method will only be called if the <code>ObjectOutputStream</code> is not using the old serialization stream format (see <a href="protocol.html#stream-protocol-versions">Section 6.3, &quot;Stream Protocol Versions&quot;</a>). If the serialization stream is using the old format (<code>ObjectStreamConstants.PROTOCOL_VERSION_1</code>), the class descriptor will be written internally in a manner that cannot be overridden or customized.</p>
<p>The <code>annotateClass</code> method is called while a <code>Class</code> is being serialized, and after the class descriptor has been written to the stream. Subclasses may extend this method and write other information to the stream about the class. This information must be read by the <code>resolveClass</code> method in a corresponding <code>ObjectInputStream</code> subclass.</p>
<p>An <code>ObjectOutputStream</code> subclass can implement the <code>replaceObject</code> method to monitor or replace objects during serialization. Replacing objects must be enabled explicitly by calling <code>enableReplaceObject</code> before calling <code>writeObject</code> with the first object to be replaced. Once enabled, <code>replaceObject</code> is called for each object just prior to serializing the object for the first time. Note that the <code>replaceObject</code> method is not called for objects of the specially handled classes, <code>Class</code> and <code>ObjectStreamClass</code>. An implementation of a subclass may return a substitute object that will be serialized instead of the original. The substitute object must be serializable. All references in the stream to the original object will be replaced by the substitute object.</p>
<p>When objects are being replaced, the subclass must ensure that the substituted object is compatible with every field where the reference will be stored, or that a complementary substitution will be made during deserialization. Objects, whose type is not a subclass of the type of the field or array element, will later abort the deserialization by raising a <code>ClassCastException</code> and the reference will not be stored.</p>
<p>The <code>enableReplaceObject</code> method can be called by trusted subclasses of <code>ObjectOutputStream</code> to enable the substitution of one object for another during serialization. Replacing objects is disabled until <code>enableReplaceObject</code> is called with a <code>true</code> value. It may thereafter be disabled by setting it to <code>false</code>. The previous setting is returned. The <code>enableReplaceObject</code> method checks that the stream requesting the replacement can be trusted. To ensure that the private state of objects is not unintentionally exposed, only trusted stream subclasses may use <code>replaceObject</code>. Trusted classes are those classes that belong to a security protection domain with permission to enable Serializable substitution.</p>
<p>If the subclass of <code>ObjectOutputStream</code> is not considered part of the system domain, <code>SerializablePermission &quot;enableSubstitution&quot;</code> must be added to the security policy file. <code>AccessControlException</code> is thrown if the protection domain of the subclass of <code>ObjectInputStream</code> does not have permission to <code>&quot;enableSubstitution&quot;</code> by calling <code>enableReplaceObject</code>. See the document Java Security Architecture (JDK1.2) for additional information about the security model.</p>
<p>The <code>writeStreamHeader</code> method writes the magic number and version to the stream. This information must be read by the <code>readStreamHeader</code> method of <code>ObjectInputStream</code>. Subclasses may need to implement this method to identify the stream's unique format.</p>
<p>The <code>flush</code> method is used to empty any buffers being held by the stream and to forward the flush to the underlying stream. The <code>drain</code> method may be used by subclassers to empty only the <code>ObjectOutputStream</code>'s buffers without forcing the underlying stream to be flushed.</p>
<p>All of the write methods for primitive types encode their values using a <code>DataOutputStream</code> to put them in the standard stream format. The bytes are buffered into block data records so they can be distinguished from the encoding of objects. This buffering allows primitive data to be skipped if necessary for class versioning. It also allows the stream to be parsed without invoking class-specific methods.</p>
<p>To override the implementation of serialization, the subclass of <code>ObjectOutputStream</code> should call the protected no-arg <code>ObjectOutputStream</code>, constructor. There is a security check within the no-arg constructor for <code>SerializablePermission &quot;enableSubclassImplementation&quot;</code> to ensure that only trusted classes are allowed to override the default implementation. This constructor does not allocate any private data for <code>ObjectOutputStream</code> and sets a flag that indicates that the final <code>writeObject</code> method should invoke the <code>writeObjectOverride</code> method and return. All other <code>ObjectOutputStream</code> methods are not final and can be directly overridden by the subclass.</p>
<h2 id="the-objectoutputstream.putfield-class">2.2 The ObjectOutputStream.PutField Class</h2>
<p>Class <code>PutField</code> provides the API for setting values of the serializable fields for a class when the class does not use default serialization. Each method puts the specified named value into the stream. An <code>IllegalArgumentException</code> is thrown if <code>name</code> does not match the name of a serializable field for the class whose fields are being written, or if the type of the named field does not match the second parameter type of the specific <code>put</code> method invoked.</p>
<h2 id="the-writeobject-method">2.3 The writeObject Method</h2>
<p>For serializable objects, the <code>writeObject</code> method allows a class to control the serialization of its own fields. Here is its signature:</p>
<pre><code>private void writeObject(ObjectOutputStream stream)
    throws IOException;</code></pre>
<p>Each subclass of a serializable object may define its own <code>writeObject</code> method. If a class does not implement the method, the default serialization provided by <code>defaultWriteObject</code> will be used. When implemented, the class is only responsible for writing its own fields, not those of its supertypes or subtypes.</p>
<p>The class's <code>writeObject</code> method, if implemented, is responsible for saving the state of the class. Either <code>ObjectOutputStream</code>'s <code>defaultWriteObject</code> or <code>writeFields</code> method must be called once (and only once) before writing any optional data that will be needed by the corresponding <code>readObject</code> method to restore the state of the object; even if no optional data is written, <code>defaultWriteObject</code> or <code>writeFields</code> must still be invoked once. If <code>defaultWriteObject</code> or <code>writeFields</code> is not invoked once prior to the writing of optional data (if any), then the behavior of instance deserialization is undefined in cases where the <code>ObjectInputStream</code> cannot resolve the class which defined the <code>writeObject</code> method in question.</p>
<p>The responsibility for the format, structure, and versioning of the optional data lies completely with the class.</p>
<h2 id="the-writeexternal-method">2.4 The writeExternal Method</h2>
<p>Objects implementing <code>java.io.Externalizable</code> must implement the <code>writeExternal</code> method to save the entire state of the object. It must coordinate with its superclasses to save their state. All of the methods of <code>ObjectOutput</code> are available to save the object's primitive typed fields and object fields.</p>
<pre><code>public void writeExternal(ObjectOutput stream)
    throws IOException;</code></pre>
<p>A new default format for writing Externalizable data has been introduced in JDK 1.2. The new format specifies that primitive data will be written in block data mode by <code>writeExternal</code> methods. Additionally, a tag denoting the end of the External object is appended to the stream after the <code>writeExternal</code> method returns. The benefits of this format change are discussed in <a href="input.html#the-readexternal-method">Section 3.6, &quot;The readExternal Method&quot;</a>. Compatibility issues caused by this change are discussed in <a href="#the-useprotocolversion-method">Section 2.6, &quot;The useProtocolVersion Method&quot;</a>.</p>
<h2 id="the-writereplace-method">2.5 The writeReplace Method</h2>
<p>For Serializable and Externalizable classes, the <code>writeReplace</code> method allows a class of an object to nominate its own replacement in the stream before the object is written. By implementing the <code>writeReplace</code> method, a class can directly control the types and instances of its own instances being serialized.</p>
<p>The method is defined as follows:</p>
<pre><code>ANY-ACCESS-MODIFIER Object writeReplace()
             throws ObjectStreamException;</code></pre>
<p>The <code>writeReplace</code> method is called when <code>ObjectOutputStream</code> is preparing to write the object to the stream. The <code>ObjectOutputStream</code> checks whether the class defines the <code>writeReplace</code> method. If the method is defined, the <code>writeReplace</code> method is called to allow the object to designate its replacement in the stream. The object returned should be either of the same type as the object passed in or an object that when read and resolved will result in an object of a type that is compatible with all references to the object. If it is not, a <code>ClassCastException</code> will occur when the type mismatch is discovered.</p>
<h2 id="the-useprotocolversion-method">2.6 The useProtocolVersion Method</h2>
<p>Due to a stream protocol change that was not backwards compatible, a mechanism has been added to enable the current Virtual Machine to write a serialization stream that is readable by a previous release. Of course, the problems that are corrected by the new stream format will exist when using the backwards compatible protocol.</p>
<p>Stream protocol versions are discussed in <a href="protocol.html#stream-protocol-versions">Section 6.3, &quot;Stream Protocol Versions&quot;</a>.</p>
<hr />
<h1 id="object-input-classes">3 - Object Input Classes</h1>
<h2 id="the-objectinputstream-class"><strong>3.1 The ObjectInputStream Class</strong></h2>
<div class="editorial">
<p>An additional step has been added</p>
</div>
<p>Class <code>ObjectInputStream</code> implements object deserialization. It maintains the state of the stream including the set of objects already deserialized. Its methods allow primitive types and objects to be read from a stream written by <code>ObjectOutputStream</code>. It manages restoration of the object and the objects that it refers to from the stream.</p>
<pre><code>package java.io;

public class ObjectInputStream
    extends InputStream
    implements ObjectInput, ObjectStreamConstants
{
    public ObjectInputStream(InputStream in)
        throws StreamCorruptedException, IOException;

    public final Object readObject()
        throws OptionalDataException, ClassNotFoundException,
            IOException;

    public Object readUnshared()
        throws OptionalDataException, ClassNotFoundException,
            IOException;

    public void defaultReadObject()
        throws IOException, ClassNotFoundException,
            NotActiveException;

    public GetField readFields()
        throws IOException;

    public synchronized void registerValidation(
        ObjectInputValidation obj, int prio)
        throws NotActiveException, InvalidObjectException;

    protected ObjectStreamClass readClassDescriptor()
        throws IOException, ClassNotFoundException;

    protected Class resolveClass(ObjectStreamClass v)
        throws IOException, ClassNotFoundException;

    protected Object resolveObject(Object obj)
        throws IOException;

    protected boolean enableResolveObject(boolean enable)
        throws SecurityException;

    protected void readStreamHeader()
        throws IOException, StreamCorruptedException;

    public int read() throws IOException;

    public int read(byte[] data, int offset, int length)
        throws IOException

    public int available() throws IOException;

    public void close() throws IOException;

    public boolean readBoolean() throws IOException;

    public byte readByte() throws IOException;

    public int readUnsignedByte() throws IOException;

    public short readShort() throws IOException;

    public int readUnsignedShort() throws IOException;

    public char readChar() throws IOException;

    public int readInt() throws IOException;

    public long readLong() throws IOException;

    public float readFloat() throws IOException;

    public double readDouble() throws IOException;

    public void readFully(byte[] data) throws IOException;

    public void readFully(byte[] data, int offset, int size)
        throws IOException;

    public int skipBytes(int len) throws IOException;

    public String readLine() throws IOException;

    public String readUTF() throws IOException;

    // Class to provide access to serializable fields.
    static abstract public class GetField
    {
        public ObjectStreamClass getObjectStreamClass();

        public boolean defaulted(String name)
            throws IOException, IllegalArgumentException;

        public char get(String name, char default)
            throws IOException, IllegalArgumentException;

        public boolean get(String name, boolean default)
            throws IOException, IllegalArgumentException;

        public byte get(String name, byte default)
            throws IOException, IllegalArgumentException;

        public short get(String name, short default)
            throws IOException, IllegalArgumentException;

        public int get(String name, int default)
            throws IOException, IllegalArgumentException;

        public long get(String name, long default)
            throws IOException, IllegalArgumentException;

        public float get(String name, float default)
            throws IOException, IllegalArgumentException;

        public double get(String name, double default)
            throws IOException, IllegalArgumentException;

        public Object get(String name, Object default)
            throws IOException, IllegalArgumentException;
    }

    protected ObjectInputStream()
        throws StreamCorruptedException, IOException;

    protected readObjectOverride()
        throws OptionalDataException, ClassNotFoundException,
            IOException;
}</code></pre>
<p>The single-argument <code>ObjectInputStream</code> constructor requires an <code>InputStream</code>. The constructor calls <code>readStreamHeader</code> to read and verifies the header and version written by the corresponding <code>ObjectOutputStream.writeStreamHeader</code> method. If a security manager is installed, this constructor checks for the <code>&quot;enableSubclassImplementation&quot;</code> <code>SerializablePermission</code> when invoked directly or indirectly by the constructor of a subclass which overrides the <code>readFields</code> and/or <code>readUnshared</code> methods.</p>
<p><em>Note:</em> The <code>ObjectInputStream</code> constructor blocks until it completes reading the serialization stream header. Code which waits for an <code>ObjectInputStream</code> to be constructed before creating the corresponding <code>ObjectOutputStream</code> for that stream will deadlock, since the <code>ObjectInputStream</code> constructor will block until a header is written to the stream, and the header will not be written to the stream until the <code>ObjectOutputStream</code> constructor executes. This problem can be resolved by creating the <code>ObjectOutputStream</code> before the <code>ObjectInputStream</code>, or otherwise removing the timing dependency between completion of <code>ObjectInputStream</code> construction and the creation of the <code>ObjectOutputStream</code>.</p>
<p>The <code>readObject</code> method is used to deserialize an object from the stream. It reads from the stream to reconstruct an object.</p>
<ol type="1">
<li><p>If the <code>ObjectInputStream</code> subclass is overriding the implementation, call the <code>readObjectOverride</code> method and return. Reimplementation is described at the end of this section.</p></li>
<li><p>If a block data record occurs in the stream, throw a <code>BlockDataException</code> with the number of available bytes.</p></li>
<li><p>If the object in the stream is null, return null.</p></li>
<li><p>If the object in the stream is a handle to a previous object, return the object.</p></li>
<li><p>If the object in the stream is a <code>Class</code>, read its <code>ObjectStreamClass</code> descriptor, add it and its handle to the set of known objects, and return the corresponding <code>Class</code> object.</p></li>
<li><p>If the object in the stream is an <code>ObjectStreamClass</code>, read in its data according to the formats described in <a href="class.html#serialized-form">Section 4.3, &quot;Serialized Form&quot;</a>. Add it and its handle to the set of known objects. In versions 1.3 and later of the Java 2 SDK, Standard Edition, the <code>readClassDescriptor</code> method is called to read in the <code>ObjectStreamClass</code> if it represents a class that is not a dynamic proxy class, as indicated in the stream data. If the class descriptor represents a dynamic proxy class, call the <code>resolveProxyClass</code> method on the stream to get the local class for the descriptor; otherwise, call the <code>resolveClass</code> method on the stream to get the local class. If the class cannot be resolved, throw a ClassNotFoundException. Return the resulting <code>ObjectStreamClass</code> object.</p></li>
<li><p>If the object in the stream is a <code>String</code>, read its length information followed by the contents of the string encoded in modified UTF-8. For details, refer to <a href="protocol.html#stream-elements">Section 6.2, &quot;Stream Elements&quot;</a>. Add the <code>String</code> and its handle to the set of known objects, and proceed to Step 1<del>2</del><strong>3</strong>.</p></li>
<li><p>If the object in the stream is an array, read its <code>ObjectStreamClass</code> and the length of the array. Allocate the array, and add it and its handle in the set of known objects. Read each element using the appropriate method for its type and assign it to the array. Proceed to Step 1<del>2</del><strong>3</strong>.</p></li>
<li><p>If the object in the stream is an enum constant, read its <code>ObjectStreamClass</code> and the enum constant name. If the <code>ObjectStreamClass</code> represents a class that is not an enum type, an <code>InvalidClassException</code> is thrown. Obtain a reference to the enum constant by calling the <code>java.lang.Enum.valueOf</code> method, passing the enum type bound to the received <code>ObjectStreamClass</code> along with the received name as arguments. If the <code>valueOf</code> method throws an <code>IllegalArgumentException</code>, an <code>InvalidObjectException</code> is thrown with the <code>IllegalArgumentException</code> as its cause. Add the enum constant and its handle in the set of known objects, and proceed to Step 1<del>2</del><strong>3</strong>.</p></li>
<li><p>For all other objects, the <code>ObjectStreamClass</code> of the object is read from the stream. The local class for that <code>ObjectStreamClass</code> is retrieved. The class must be serializable or externalizable, and must not be an enum type. If the class does not satisfy these criteria, an <code>InvalidClassException</code> is thrown.</p></li>
</ol>
<div class="inserted">
<ol start="11" type="1">
<li><p>If the class is a record class. A handle, with an initial value of <code>null</code>, is added to the set of known objects.</p>
<p>The record object will be constructed by an invocation of its <em>canonical</em> constructor. The <em>canonical</em> constructor for record class, <code>R</code>, is found by, first building a method descriptor from the number, order, and declared types of the record R's components, as returned by <code>R::getRecordComponents</code>; and then locating R's declared constructor matching the descriptor. If the <em>canonical</em> constructor cannot be found, an <code>InvalidClassException</code> is thrown.</p>
<p>The contents are restored as follows:</p>
<ol type="a">
<li><p>Read and restore all the field values from the stream. Match the stream fields to that of the appropriate constructor parameter, used to initialize the record component. The matching is based on the equality of the name of the stream field and the name of the record component, their names must be identical. That is, for each record component, as returned by <code>Class::getRecordComponents</code>, first determine the components's name, <code>n</code>; and then find the stream value for the stream field whose name equals <code>n</code>. The concrete type of a stream value for a matched field, must be assignable (<code>Class::isAssignableFrom</code>) to that of the type of its matched record component, or else a <code>ClassCastException</code> will be thrown -- all matches are type-checked. Stream fields not matched are effectively discarded.</p></li>
<li>Invoke the record 's <em>canonical</em> constructor, with the matched stream field values. The stream field values are passed in the corresponding record component positions of the constructor parameters. Unmatched components have the default value appropriate for their type passed. If the constructor invocation throws an exception, an <code>InvalidObjectException</code> is thrown with that exception as its cause. Otherwise, the newly created record object is assigned to its handle of known objects. Proceed to Step 13.</li>
</ol></li>
</ol>
</div>
<p>1<del>1</del><strong>2</strong>. An instance of the class is allocated. The instance and its handle are added to the set of known objects. The contents restored appropriately:</p>
<pre><code>a.  For serializable objects, the no-arg constructor for the first
    non-serializable supertype is run. For serializable classes, the fields
    are initialized to the default value appropriate for its type. Then the
    fields of each class are restored by calling class-specific
    `readObject` methods, or if these are not defined, by calling the
    `defaultReadObject` method. Note that field initializers and
    constructors are not executed for serializable classes during
    deserialization. In the normal case, the version of the class that
    wrote the stream will be the same as the class reading the stream. In
    this case, all of the supertypes of the object in the stream will match
    the supertypes in the currently-loaded class. If the version of the
    class that wrote the stream had different supertypes than the loaded
    class, the `ObjectInputStream` must be more careful about restoring or
    initializing the state of the differing classes. It must step through
    the classes, matching the available data in the stream with the classes
    of the object being restored. Data for classes that occur in the
    stream, but do not occur in the object, is discarded. For classes that
    occur in the object, but not in the stream, the class fields are set to
    default values by default serialization.

b.  For externalizable objects, the no-arg constructor for the class is run
    and then the `readExternal` method is called to restore the contents of
    the object.</code></pre>
<p>1<del>2</del><strong>3</strong>. Process potential substitutions by the class of the object and/or by a subclass of <code>ObjectInputStream</code>:</p>
<pre><code>a.  If the class of the object is not an enum type and defines the
    appropriate `readResolve` method, the method is called to allow the
    object to replace itself.

b.  Then if previously enabled by `enableResolveObject,` the
    `resolveObject` method is called to allow subclasses of the stream to
    examine and replace the object. If the previous step did replace the
    original object, the `resolveObject` method is called with the
    replacement object. If a replacement took place, the table of known
    objects is updated so the replacement object is associated with the
    handle. The replacement object is then returned from `readObject`.</code></pre>
<p>All of the methods for reading primitives types only consume bytes from the block data records in the stream. If a read for primitive data occurs when the next item in the stream is an object, the read methods return <em>-1</em> or the <code>EOFException</code> as appropriate. The value of a primitive type is read by a <code>DataInputStream</code> from the block data record.</p>
<p>The exceptions thrown reflect errors during the traversal or exceptions that occur on the underlying stream. If any exception is thrown, the underlying stream is left in an unknown and unusable state.</p>
<p>When the reset token occurs in the stream, all of the state of the stream is discarded. The set of known objects is cleared.</p>
<p>When the exception token occurs in the stream, the exception is read and a new <code>WriteAbortedException</code> is thrown with the terminating exception as an argument. The stream context is reset as described earlier.</p>
<p>The <code>readUnshared</code> method is used to read &quot;unshared&quot; objects from the stream. This method is identical to <code>readObject</code>, except that it prevents subsequent calls to <code>readObject</code> and <code>readUnshared</code> from returning additional references to the deserialized instance returned by the original call to <code>readUnshared</code>. Specifically:</p>
<ul>
<li><p>If <code>readUnshared</code> is called to deserialize a back-reference (the stream representation of an object which has been written previously to the stream), an <code>ObjectStreamException</code> will be thrown.</p></li>
<li><p>If <code>readUnshared</code> returns successfully, then any subsequent attempts to deserialize back-references to the stream handle deserialized by <code>readUnshared</code> will cause an <code>ObjectStreamException</code> to be thrown.</p></li>
</ul>
<p>Deserializing an object via <code>readUnshared</code> invalidates the stream handle associated with the returned object. Note that this in itself does not always guarantee that the reference returned by <code>readUnshared</code> is unique; the deserialized object may define a <code>readResolve</code> method which returns an object visible to other parties, or <code>readUnshared</code> may return a <code>Class</code> object or enum constant obtainable elsewhere in the stream or through external means. If the deserialized object defines a <code>readResolve</code> method and the invocation of that method returns an array, then <code>readUnshared</code> returns a shallow clone of that array; this guarantees that the returned array object is unique and cannot be obtained a second time from an invocation of <code>readObject</code> or <code>readUnshared</code> on the <code>ObjectInputStream</code>, even if the underlying data stream has been manipulated.</p>
<p>The <code>defaultReadObject</code> method is used to read the fields and object from the stream. It uses the class descriptor in the stream to read the fields in the canonical order by name and type from the stream. The values are assigned to the matching fields by name in the current class. Details of the versioning mechanism can be found in <a href="version.html#compatible-java-type-evolution">Section 5.5, &quot;Compatible Java Type Evolution&quot;</a>. Any field of the object that does not appear in the stream is set to its default value. Values that appear in the stream, but not in the object, are discarded. This occurs primarily when a later version of a class has written additional fields that do not occur in the earlier version. This method may only be called from the <code>readObject</code> method while restoring the fields of a class. When called at any other time, the <code>NotActiveException</code> is thrown.</p>
<p>The <code>readFields</code> method reads the values of the serializable fields from the stream and makes them available via the <code>GetField</code> class. The <code>readFields</code> method is only callable from within the <code>readObject</code> method of a serializable class. It cannot be called more than once or if <code>defaultReadObject</code> has been called. The <code>GetFields</code> object uses the current object's <code>ObjectStreamClass</code> to verify the fields that can be retrieved for this class. The <code>GetFields</code> object returned by <code>readFields</code> is only valid during this call to the classes <code>readObject</code> method. The fields may be retrieved in any order. Additional data may only be read directly from stream after <code>readFields</code> has been called.</p>
<p>The <code>registerValidation</code> method can be called to request a callback when the entire graph has been restored but before the object is returned to the original caller of <code>readObject</code>. The order of validate callbacks can be controlled using the priority. Callbacks registered with higher values are called before those with lower values. The object to be validated must support the <code>ObjectInputValidation</code> interface and implement the <code>validateObject</code> method. It is only correct to register validations during a call to a class's <code>readObject</code> method. Otherwise, a <code>NotActiveException</code> is thrown. If the callback object supplied to <code>registerValidation</code> is null, an <code>InvalidObjectException</code> is thrown.</p>
<p>Starting with the Java SDK, Standard Edition, v1.3, the <code>readClassDescriptor</code> method is used to read in all <code>ObjectStreamClass</code> objects. <code>readClassDescriptor</code> is called when the <code>ObjectInputStream</code> expects a class descriptor as the next item in the serialization stream. Subclasses of <code>ObjectInputStream</code> may override this method to read in class descriptors that have been written in non-standard formats (by subclasses of <code>ObjectOutputStream</code> which have overridden the <code>writeClassDescriptor</code> method). By default, this method reads class descriptors according to the format described in <a href="protocol.html#grammar-for-the-stream-format">Section 6.4, &quot;Grammar for the Stream Format&quot;</a>.</p>
<p>The <code>resolveClass</code> method is called while a class is being deserialized, and after the class descriptor has been read. Subclasses may extend this method to read other information about the class written by the corresponding subclass of <code>ObjectOutputStream</code>. The method must find and return the class with the given name and <code>serialVersionUID</code>. The default implementation locates the class by calling the class loader of the closest caller of <code>readObject</code> that has a class loader. If the class cannot be found <code>ClassNotFoundException</code> should be thrown. Prior to JDK 1.1.6, the <code>resolveClass</code> method was required to return the same fully qualified class name as the class name in the stream. In order to accommodate package renaming across releases, <code>method</code> <code>resolveClass</code> only needs to return a class with the same base class name and <code>SerialVersionUID</code> in JDK 1.1.6 and later versions.</p>
<p>The <code>resolveObject</code> method is used by trusted subclasses to monitor or substitute one object for another during deserialization. Resolving objects must be enabled explicitly by calling <code>enableResolveObject</code> before calling <code>readObject</code> for the first object to be resolved. Once enabled, <code>resolveObject</code> is called once for each serializable object just prior to the first time it is being returned from <code>readObject</code>. Note that the <code>resolveObject</code> method is not called for objects of the specially handled classes, <code>Class</code>, <code>ObjectStreamClass</code>, <code>String</code>, and arrays. A subclass's implementation of <code>resolveObject</code> may return a substitute object that will be assigned or returned instead of the original. The object returned must be of a type that is consistent and assignable to every reference of the original object or else a <code>ClassCastException</code> will be thrown. All assignments are type-checked. All references in the stream to the original object will be replaced by references to the substitute object.</p>
<p>The <code>enableResolveObject</code> method is called by trusted subclasses of <code>ObjectOutputStream</code> to enable the monitoring or substitution of one object for another during deserialization. Replacing objects is disabled until <code>enableResolveObject</code> is called with a <code>true</code> value. It may thereafter be disabled by setting it to <code>false</code>. The previous setting is returned. The <code>enableResolveObject</code> method checks if the stream has permission to request substitution during serialization. To ensure that the private state of objects is not unintentionally exposed, only trusted streams may use <code>resolveObject</code>. Trusted classes are those classes with a class loader equal to null or belong to a security protection domain that provides permission to enable substitution.</p>
<p>If the subclass of <code>ObjectInputStream</code> is not considered part of the system domain, a line has to be added to the security policy file to provide to a subclass of <code>ObjectInputStream</code> permission to call <code>enableResolveObject</code>. The <code>SerializablePermission</code> to add is <code>&quot;enableSubstitution&quot;</code>. <code>AccessControlException</code> is thrown if the protection domain of the subclass of <code>ObjectStreamClass</code> does not have permission to <code>&quot;enableSubstitution&quot;</code> by calling <code>enableResolveObject</code>. See the document Java Security Architecture (JDK 1.2) for additional information about the security model.</p>
<p>The <code>readStreamHeader</code> method reads and verifies the magic number and version of the stream. If they do not match, the <code>StreamCorruptedMismatch</code> is thrown.</p>
<p>To override the implementation of deserialization, a subclass of <code>ObjectInputStream</code> should call the protected no-arg <code>ObjectInputStream</code>, constructor. There is a security check within the no-arg constructor for <code>SerializablePermission &quot;enableSubclassImplementation&quot;</code> to ensure that only trusted classes are allowed to override the default implementation. This constructor does not allocate any private data for <code>ObjectInputStream</code> and sets a flag that indicates that the final <code>readObject</code> method should invoke the <code>readObjectOverride</code> method and return. All other <code>ObjectInputStream</code> methods are not final and can be directly overridden by the subclass.</p>
<h2 id="the-objectinputstream.getfield-class">3.2 The ObjectInputStream.GetField Class</h2>
<p>The class <code>ObjectInputStream.GetField</code> provides the API for getting the values of serializable fields. The protocol of the stream is the same as used by <code>defaultReadObject.</code> Using <code>readFields</code> to access the serializable fields does not change the format of the stream. It only provides an alternate API to access the values which does not require the class to have the corresponding non-transient and non-static fields for each named serializable field. The serializable fields are those declared using <code>serialPersistentFields</code> or if it is not declared the non-transient and non-static fields of the object. When the stream is read the available serializable fields are those written to the stream when the object was serialized. If the class that wrote the stream is a different version not all fields will correspond to the serializable fields of the current class. The available fields can be retrieved from the <code>ObjectStreamClass</code> of the <code>GetField</code> object.</p>
<p>The <code>getObjectStreamClass</code> method returns an <code>ObjectStreamClass</code> object representing the class in the stream. It contains the list of serializable fields.</p>
<p>The <code>defaulted</code> method returns <em>true</em> if the field is not present in the stream. An <code>IllegalArgumentException</code> is thrown if the requested field is not a serializable field of the current class.</p>
<p>Each <code>get</code> method returns the specified serializable field from the stream. I/O exceptions will be thrown if the underlying stream throws an exception. An <code>IllegalArgumentException</code> is thrown if the name or type does not match the name and type of an field serializable field of the current class. The default value is returned if the stream does not contain an explicit value for the field.</p>
<h2 id="the-objectinputvalidation-interface">3.3 The ObjectInputValidation Interface</h2>
<p>This interface allows an object to be called when a complete graph of objects has been deserialized. If the object cannot be made valid, it should throw the <code>ObjectInvalidException</code>. Any exception that occurs during a call to <code>validateObject</code> will terminate the validation process, and the <code>InvalidObjectException</code> will be thrown.</p>
<pre><code>package java.io;

public interface ObjectInputValidation
{
    public void validateObject()
        throws InvalidObjectException;
}</code></pre>
<h2 id="the-readobject-method">3.4 The readObject Method</h2>
<p>For serializable objects, the <code>readObject</code> method allows a class to control the deserialization of its own fields. Here is its signature:</p>
<pre><code>private void readObject(ObjectInputStream stream)
    throws IOException, ClassNotFoundException;</code></pre>
<p>Each subclass of a serializable object may define its own <code>readObject</code> method. If a class does not implement the method, the default serialization provided by <code>defaultReadObject</code> will be used. When implemented, the class is only responsible for restoring its own fields, not those of its supertypes or subtypes.</p>
<p>The <code>readObject</code> method of the class, if implemented, is responsible for restoring the state of the class. The values of every field of the object whether transient or not, static or not are set to the default value for the fields type. Either <code>ObjectInputStream</code>'s <code>defaultReadObject</code> or <code>readFields</code> method must be called once (and only once) before reading any optional data written by the corresponding <code>writeObject</code> method; even if no optional data is read, <code>defaultReadObject</code> or <code>readFields</code> must still be invoked once. If the <code>readObject</code> method of the class attempts to read more data than is present in the optional part of the stream for this class, the stream will return <code>-1</code> for bytewise reads, throw an <code>EOFException</code> for primitive data reads (e.g., <code>readInt</code>, <code>readFloat</code>), or throw an <code>OptionalDataException</code> with the <code>eof</code> field set to <code>true</code> for object reads.</p>
<p>The responsibility for the format, structure, and versioning of the optional data lies completely with the class. The <code>@serialData</code> javadoc tag within the javadoc comment for the <code>readObject</code> method should be used to document the format and structure of the optional data.</p>
<p>If the class being restored is not present in the stream being read, then its <code>readObjectNoData</code> method, if defined, is invoked (instead of <code>readObject</code>); otherwise, its fields are initialized to the appropriate default values. For further detail, see <a href="#the-readobjectnodata-method">Section 3.5, &quot;The readObjectNoData Method&quot;</a>.</p>
<p>Reading an object from the <code>ObjectInputStream</code> is analogous to creating a new object. Just as a new object's constructors are invoked in the order from the superclass to the subclass, an object being read from a stream is deserialized from superclass to subclass. The <code>readObject</code> or <code>readObjectNoData</code> method is called instead of the constructor for each <code>Serializable</code> subclass during deserialization.</p>
<p>One last similarity between a constructor and a <code>readObject</code> method is that both provide the opportunity to invoke a method on an object that is not fully constructed. Any overridable (neither private, static nor final) method called while an object is being constructed can potentially be overridden by a subclass. Methods called during the construction phase of an object are resolved by the actual type of the object, not the type currently being initialized by either its constructor or <code>readObject</code>/<code>readObjectNoData</code> method. Therefore, calling an overridable method from within a <code>readObject</code> or <code>readObjectNoData</code> method may result in the unintentional invocation of a subclass method before the superclass has been fully initialized.</p>
<h2 id="the-readobjectnodata-method">3.5 The readObjectNoData Method</h2>
<p>For serializable objects, the <code>readObjectNoData</code> method allows a class to control the initialization of its own fields in the event that a subclass instance is deserialized and the serialization stream does not list the class in question as a superclass of the deserialized object. This may occur in cases where the receiving party uses a different version of the deserialized instance's class than the sending party, and the receiver's version extends classes that are not extended by the sender's version. This may also occur if the serialization stream has been tampered; hence, <code>readObjectNoData</code> is useful for initializing deserialized objects properly despite a &quot;hostile&quot; or incomplete source stream.</p>
<pre><code>private void readObjectNoData() throws ObjectStreamException;</code></pre>
<p>Each serializable class may define its own <code>readObjectNoData</code> method. If a serializable class does not define a <code>readObjectNoData</code> method, then in the circumstances listed above the fields of the class will be initialized to their default values (as listed in The Java Language Specification); this behavior is consistent with that of <code>ObjectInputStream</code> prior to version 1.4 of the Java 2 SDK, Standard Edition, when support for <code>readObjectNoData</code> methods was introduced. If a serializable class does define a <code>readObjectNoData</code> method and the aforementioned conditions arise, then <code>readObjectNoData</code> will be invoked at the point during deserialization when a class-defined <code>readObject</code> method would otherwise be called had the class in question been listed by the stream as a superclass of the instance being deserialized.</p>
<h2 id="the-readexternal-method">3.6 The readExternal Method</h2>
<p>Objects implementing <code>java.io.Externalizable</code> must implement the <code>readExternal</code> method to restore the entire state of the object. It must coordinate with its superclasses to restore their state. All of the methods of <code>ObjectInput</code> are available to restore the object's primitive typed fields and object fields.</p>
<pre><code>public void readExternal(ObjectInput stream)
    throws IOException;</code></pre>
<p><em>Note:</em> The <code>readExternal</code> method is public, and it raises the risk of a client being able to overwrite an existing object from a stream. The class may add its own checks to insure that this is only called when appropriate.</p>
<p>A new stream protocol version has been introduced in JDK 1.2 to correct a problem with <code>Externalizable</code> objects. The old definition of <code>Externalizable</code> objects required the local virtual machine to find a <code>readExternal</code> method to be able to properly read an <code>Externalizable</code> object from the stream. The new format adds enough information to the stream protocol so serialization can skip an <code>Externalizable</code> object when the local <code>readExternal</code> method is not available. Due to class evolution rules, serialization must be able to skip an <code>Externalizable</code> object in the input stream if there is not a mapping for the object using the local classes.</p>
<p>An additional benefit of the new <code>Externalizable</code> stream format is that <code>ObjectInputStream</code> can detect attempts to read more External data than is available, and can also skip by any data that is left unconsumed by a <code>readExternal</code> method. The behavior of <code>ObjectInputStream</code> in response to a read past the end of External data is the same as the behavior when a class-defined <code>readObject</code> method attempts to read past the end of its optional data: bytewise reads will return <code>-1</code>, primitive reads will throw <code>EOFException</code>s, and object reads will throw <code>OptionalDataException</code>s with the <code>eof</code> field set to <code>true</code>.</p>
<p>Due to the format change, JDK 1.1.6 and earlier releases are not able to read the new format. <code>StreamCorruptedException</code> is thrown when JDK 1.1.6 or earlier attempts to read an <code>Externalizable</code> object from a stream written in <code>PROTOCOL_VERSION_2</code>. Compatibility issues are discussed in more detail in <a href="protocol.html#stream-protocol-versions">Section 6.3, &quot;Stream Protocol Versions&quot;</a>.</p>
<h2 id="the-readresolve-method">3.7 The readResolve Method</h2>
<p>For Serializable and Externalizable classes, the <code>readResolve</code> method allows a class to replace/resolve the object read from the stream before it is returned to the caller. By implementing the <code>readResolve</code> method, a class can directly control the types and instances of its own instances being deserialized. The method is defined as follows:</p>
<pre><code>ANY-ACCESS-MODIFIER Object readResolve()
            throws ObjectStreamException;</code></pre>
<p>The <code>readResolve</code> method is called when <code>ObjectInputStream</code> has read an object from the stream and is preparing to return it to the caller. <code>ObjectInputStream</code> checks whether the class of the object defines the <code>readResolve</code> method. If the method is defined, the <code>readResolve</code> method is called to allow the object in the stream to designate the object to be returned. The object returned should be of a type that is compatible with all uses. If it is not compatible, a <code>ClassCastException</code> will be thrown when the type mismatch is discovered.</p>
<p>For example, a <code>Symbol</code> class could be created for which only a single instance of each symbol binding existed within a virtual machine. The <code>readResolve</code> method would be implemented to determine if that symbol was already defined and substitute the preexisting equivalent <code>Symbol</code> object to maintain the identity constraint. In this way the uniqueness of <code>Symbol</code> objects can be maintained across serialization.</p>
<p><em>Note:</em> The <code>readResolve</code> method is not invoked on the object until the object is fully constructed, so any references to this object in its object graph will not be updated to the new object nominated by <code>readResolve</code>. However, during the serialization of an object with the <code>writeReplace</code> method, all references to the original object in the replacement object's object graph are replaced with references to the replacement object. Therefore in cases where an object being serialized nominates a replacement object whose object graph has a reference to the original object, deserialization will result in an incorrect graph of objects. Furthermore, if the reference types of the object being read (nominated by <code>writeReplace</code>) and the original object are not compatible, the construction of the object graph will raise a <code>ClassCastException</code>.</p>
<hr />
<h1 id="class-descriptors">4 - Class Descriptors</h1>
<h2 id="the-objectstreamclass-class">4.1 The ObjectStreamClass Class</h2>
<p>The <code>ObjectStreamClass</code> provides information about classes that are saved in a Serialization stream. The descriptor provides the fully-qualified name of the class and its serialization version UID. A <code>SerialVersionUID</code> identifies the unique original class version for which this class is capable of writing streams and from which it can read.</p>
<pre><code>package java.io;

public class ObjectStreamClass
{
    public static ObjectStreamClass lookup(Class cl);

        public static ObjectStreamClass lookupAny(Class cl);

    public String getName();

    public Class forClass();

    public ObjectStreamField[] getFields();

    public long getSerialVersionUID();

    public String toString();
}</code></pre>
<p>The <code>lookup</code> method returns the <code>ObjectStreamClass</code> descriptor for the specified class in the virtual machine. If the class has defined <code>serialVersionUID</code> it is retrieved from the class. If the <code>serialVersionUID</code> is not defined by the class, it is computed from the definition of the class in the virtual machine. <em>I</em>f the specified class is not serializable or externalizable, <em>null</em> is returned.</p>
<p>The <code>lookupAny</code> method behaves like the <code>lookup</code> method, except that it returns the descriptor for any class, regardless of whether it implements <code>Serializable</code>. The <code>serialVersionUID</code> of a class that does not implement <code>Serializable</code> is <em>0L.</em></p>
<p>The <code>getName</code> method returns the name of the class, in the same format that is used by the <code>Class.getName</code> method.</p>
<p>The <code>forClass</code> method returns the <code>Class</code> in the local virtual machine if one was found by <code>ObjectInputStream.resolveClass</code> method. Otherwise, it returns <em>null</em>.</p>
<p>The <code>getFields</code> method returns an array of <code>ObjectStreamField</code> objects that represent the serializable fields of this class.</p>
<p>The <code>getSerialVersionUID</code> method returns the <code>serialVersionUID</code> of this class. Refer to <a href="#stream-unique-identifiers">Section 4.6, &quot;Stream Unique Identifiers&quot;</a>. If not specified by the class, the value returned is a hash computed from the class's name, interfaces, methods, and fields using the Secure Hash Algorithm (SHA) as defined by the National Institute of Standards.</p>
<p>The <code>toString</code> method returns a printable representation of the class descriptor including the name of the class and the <code>serialVersionUID</code>.</p>
<h2 id="dynamic-proxy-class-descriptors">4.2 Dynamic Proxy Class Descriptors</h2>
<p>ObjectStreamClass descriptors are also used to provide information about dynamic proxy classes (e.g., classes obtained via calls to the getProxyClass method of java.lang.reflect.Proxy) saved in a serialization stream. A dynamic proxy class itself has no serializable fields and a serialVersionUID of 0L. In other words, when the Class object for a dynamic proxy class is passed to the static lookup method of ObjectStreamClass, the returned ObjectStreamClass instance will have the following properties:</p>
<ul>
<li>Invoking its getSerialVersionUID method will return 0L.</li>
<li>Invoking its getFields method will return an array of length zero.</li>
<li>Invoking its getField method with any String argument will return null.</li>
</ul>
<h2 id="serialized-form">4.3 Serialized Form</h2>
<p>The serialized form of an ObjectStreamClass instance depends on whether or not the Class object it represents is serializable, externalizable, or a dynamic proxy class.</p>
<p>When an <code>ObjectStreamClass</code> instance that does not represent a dynamic proxy class is written to the stream, it writes the class name and <code>serialVersionUID</code>, flags, and the number of fields. Depending on the class, additional information may be written:</p>
<ul>
<li><p>For non-serializable classes, the number of fields is always zero. Neither the <code>SC_SERIALIZABLE</code> nor the <code>SC_EXTERNALIZABLE</code> flag bits are set.</p></li>
<li><p>For serializable classes, the <code>SC_SERIALIZABLE</code> flag is set, the number of fields counts the number of serializable fields and is followed by a descriptor for each serializable field. The descriptors are written in canonical order. The descriptors for primitive typed fields are written first sorted by field name followed by descriptors for the object typed fields sorted by field name. The names are sorted using <code>String.compareTo</code>. For details of the format, refer to <a href="protocol.html#grammar-for-the-stream-format">Section 6.4, &quot;Grammar for the Stream Format&quot;</a>.</p></li>
<li><p>For externalizable classes, flags includes the <code>SC_EXTERNALIZABLE</code> flag, and the number of fields is always zero.</p></li>
<li><p>For enum types, flags includes the <code>SC_ENUM</code> flag, and the number of fields is always zero.</p></li>
</ul>
<p>When an ObjectOutputStream serializes the ObjectStreamClass descriptor for a dynamic proxy class, as determined by passing its Class object to the isProxyClass method of java.lang.reflect.Proxy, it writes the number of interfaces that the dynamic proxy class implements, followed by the interface names. Interfaces are listed in the order that they are returned by invoking the getInterfaces method on the Class object of the dynamic proxy class.</p>
<p>The serialized representations of ObjectStreamClass descriptors for dynamic proxy classes and non-dynamic proxy classes are differentiated through the use of different typecodes (<code>TC_PROXYCLASSDESC</code> and <code>TC_CLASSDESC</code>, respectively); for a more detailed specification of the grammar, see <a href="protocol.html#grammar-for-the-stream-format">Section 6.4, &quot;Grammar for the Stream Format&quot;</a>.</p>
<h2 id="the-objectstreamfield-class">4.4 The ObjectStreamField Class</h2>
<p>An <code>ObjectStreamField</code> represents a serializable field of a serializable class. The serializable fields of a class can be retrieved from the <code>ObjectStreamClass</code>.</p>
<p>The special static serializable field, <code>serialPersistentFields</code>, is an array of <code>ObjectStreamField</code> components that is used to override the default serializable fields.</p>
<pre><code>package java.io;

public class ObjectStreamField implements Comparable {

    public ObjectStreamField(String fieldName,
                             Class fieldType);

    public ObjectStreamField(String fieldName,
                             Class fieldType,
                             boolean unshared);

    public String getName();

    public Class getType();

    public String getTypeString();

    public char getTypeCode();

    public boolean isPrimitive();

    public boolean isUnshared();

    public int getOffset();

    protected void setOffset(int offset);

    public int compareTo(Object obj);

    public String toString();
}</code></pre>
<p><code>ObjectStreamField</code> objects are used to specify the serializable fields of a class or to describe the fields present in a stream. Its constructors accept arguments describing the field to represent: a string specifying the name of the field, a <code>Class</code> object specifying the type of the field, and a <code>boolean</code> flag (implicitly <code>false</code> for the two-argument constructor) indicating whether or not values of the represented field should be read and written as &quot;unshared&quot; objects if default serialization/deserialization is in use (see the descriptions of the <code>ObjectInputStream.readUnshared</code> and <code>ObjectOutputStream.writeUnshared</code> methods in <a href="input.html#the-objectinputstream-class">Section 3.1, &quot;The ObjectInputStream Class&quot;</a> and <a href="output.html#the-objectoutputstream-class">Section 2.1, &quot;The ObjectOutputStream Class&quot;</a>, respectively).</p>
<p>The <code>getName</code> method returns the name of the serializable field.</p>
<p>The <code>getType</code> method returns the type of the field.</p>
<p>The <code>getTypeString</code> method returns the type signature of the field.</p>
<p>The <code>getTypeCode</code> method returns a character encoding of the field type ('<code>B</code>' for <code>byte</code>, '<code>C</code>' for <code>char</code>, '<code>D</code>' for <code>double</code>, '<code>F</code>' for <code>float</code>, '<code>I</code>' for <code>int</code>, '<code>J</code>' for <code>long</code>, '<code>L</code>' for non-array object types, '<code>S</code>' for <code>short</code>, '<code>Z</code>' for <code>boolean</code>, and '<code>[</code>' for arrays).</p>
<p>The <code>isPrimitive</code> method returns <code>true</code> if the field is of primitive type, or <code>false</code> otherwise.</p>
<p>The <code>isUnshared</code> method returns <code>true</code> if values of the field should be written as &quot;unshared&quot; objects, or <code>false</code> otherwise.</p>
<p>The <code>getOffset</code> method returns the offset of the field's value within instance data of the class defining the field.</p>
<p>The <code>setOffset</code> method allows <code>ObjectStreamField</code> subclasses to modify the offset value returned by the <code>getOffset</code> method.</p>
<p>The <code>compareTo</code> method compares <code>ObjectStreamFields</code> for use in sorting. Primitive fields are ranked as &quot;smaller&quot; than non-primitive fields; fields otherwise equal are ranked alphabetically.</p>
<p>The <code>toString</code> method returns a printable representation with name and type.</p>
<h2 id="inspecting-serializable-classes">4.5 Inspecting Serializable Classes</h2>
<p>The program <em>serialver</em> can be used to find out if a class is serializable and to get its <code>serialVersionUID</code>.</p>
<p>When invoked on the command line with one or more class names, serialver prints the <code>serialVersionUID</code> for each class in a form suitable for copying into an evolving class. When invoked with no arguments, it prints a usage line.</p>
<h2 id="stream-unique-identifiers"><strong>4.6 Stream Unique Identifiers</strong></h2>
<div class="editorial">
<p>Minor changes for record SerialVersionUID</p>
</div>
<p>Each versioned class must identify the original class version for which it is capable of writing streams and from which it can read. For example, a versioned class must declare:</p>
<pre><code>private static final long serialVersionUID = 3487495895819393L;</code></pre>
<p>The stream-unique identifier is a 64-bit hash of the class name, interface class names, methods, and fields. The value must be declared in all versions of a class except the first. It may be declared in the original class but is not required. The value is fixed for all compatible classes. If the SUID is not declared for a class, the value defaults to the hash for that class. The <code>serialVersionUID</code> for dynamic proxy classes and enum types always have the value <em>0L</em>. Array classes cannot declare an explicit <code>serialVersionUID</code>, so they always have the default computed value, but the requirement for matching <code>serialVersionUID</code> values is waived for array classes. <strong>Record classes have a default <code>serialVersionUID</code> value of <code>0L</code>, but can declare an explicit <code>serialVersionUID</code>. The requirement for matching <code>serialVersionUID</code> values is waived for record classes.</strong></p>
<p><em>Note:</em> It is strongly recommended that all serializable classes explicitly declare <code>serialVersionUID</code> values, since the default <code>serialVersionUID</code> computation is highly sensitive to class details that may vary depending on compiler implementations, and can thus result in unexpected <code>serialVersionUID</code> conflicts during deserialization, causing deserialization to fail.</p>
<p>The initial version of an <code>Externalizable</code> class must output a stream data format that is extensible in the future. The initial version of the method <code>readExternal</code> has to be able to read the output format of all future versions of the method <code>writeExternal</code>.</p>
<p>The <code>serialVersionUID</code> is computed using the signature of a stream of bytes that reflect the class definition. The National Institute of Standards and Technology (NIST) Secure Hash Algorithm (SHA-1) is used to compute a signature for the stream. The first two 32-bit quantities are used to form a 64-bit hash. A <code>java.lang.DataOutputStream</code> is used to convert primitive data types to a sequence of bytes. The values input to the stream are defined by the Java Virtual Machine (VM) specification for classes. Class modifiers may include the <code>ACC_PUBLIC</code>, <code>ACC_FINAL</code>, <code>ACC_INTERFACE</code>, and <code>ACC_ABSTRACT</code> flags; other flags are ignored and do not affect <code>serialVersionUID</code> computation. Similarly, for field modifiers, only the <code>ACC_PUBLIC</code>, <code>ACC_PRIVATE</code>, <code>ACC_PROTECTED</code>, <code>ACC_STATIC</code>, <code>ACC_FINAL</code>, <code>ACC_VOLATILE</code>, and <code>ACC_TRANSIENT</code> flags are used when computing <code>serialVersionUID</code> values. For constructor and method modifiers, only the <code>ACC_PUBLIC</code>, <code>ACC_PRIVATE</code>, <code>ACC_PROTECTED</code>, <code>ACC_STATIC</code>, <code>ACC_FINAL</code>, <code>ACC_SYNCHRONIZED</code>, <code>ACC_NATIVE</code>, <code>ACC_ABSTRACT</code> and <code>ACC_STRICT</code> flags are used. Names and descriptors are written in the format used by the <code>java.io.DataOutputStream.writeUTF</code> method.</p>
<p>The sequence of items in the stream is as follows:</p>
<ol type="1">
<li><p>The class name.</p></li>
<li><p>The class modifiers written as a 32-bit integer.</p></li>
<li><p>The name of each interface sorted by name.</p></li>
<li><p>For each field of the class sorted by field name (except <code>private static</code> and <code>private transient</code> fields:</p>
<ol type="a">
<li><p>The name of the field.</p></li>
<li><p>The modifiers of the field written as a 32-bit integer.</p></li>
<li><p>The descriptor of the field.</p></li>
</ol></li>
<li><p>If a class initializer exists, write out the following:</p>
<ol type="a">
<li><p>The name of the method, <code>&lt;clinit&gt;</code>.</p></li>
<li><p>The modifier of the method, <code>java.lang.reflect.Modifier.STATIC</code>, written as a 32-bit integer.</p></li>
<li><p>The descriptor of the method, <code>()V</code>.</p></li>
</ol></li>
<li><p>For each non-<code>private</code> constructor sorted by method name and signature:</p>
<ol type="a">
<li><p>The name of the method, <code>&lt;init&gt;</code>.</p></li>
<li><p>The modifiers of the method written as a 32-bit integer.</p></li>
<li><p>The descriptor of the method.</p></li>
</ol></li>
<li><p>For each non-<code>private</code> method sorted by method name and signature:</p>
<ol type="a">
<li><p>The name of the method.</p></li>
<li><p>The modifiers of the method written as a 32-bit integer.</p></li>
<li><p>The descriptor of the method.</p></li>
</ol></li>
<li><p>The SHA-1 algorithm is executed on the stream of bytes produced by <code>DataOutputStream</code> and produces five 32-bit values <code>sha[0..4]</code>.</p></li>
<li><p>The hash value is assembled from the first and second 32-bit values of the SHA-1 message digest. If the result of the message digest, the five 32-bit words <code>H0 H1 H2 H3 H4</code>, is in an array of five <code>int</code> values named <code>sha</code>, the hash value would be computed as follows:</p></li>
</ol>
<pre><code>      long hash = ((sha[0] &gt;&gt;&gt; 24) &amp; 0xFF) |
                  ((sha[0] &gt;&gt;&gt; 16) &amp; 0xFF) &lt;&lt; 8 |
                  ((sha[0] &gt;&gt;&gt; 8) &amp; 0xFF) &lt;&lt; 16 |
                  ((sha[0] &gt;&gt;&gt; 0) &amp; 0xFF) &lt;&lt; 24 |
                  ((sha[1] &gt;&gt;&gt; 24) &amp; 0xFF) &lt;&lt; 32 |
                  ((sha[1] &gt;&gt;&gt; 16) &amp; 0xFF) &lt;&lt; 40 |
                  ((sha[1] &gt;&gt;&gt; 8) &amp; 0xFF) &lt;&lt; 48 |
                  ((sha[1] &gt;&gt;&gt; 0) &amp; 0xFF) &lt;&lt; 56;</code></pre>
<hr />
<h1 id="versioning-of-serializable-objects">5 - Versioning of Serializable Objects</h1>
<h2 id="overview-1">5.1 Overview</h2>
<p>When Java objects use serialization to save state in files, or as blobs in databases, the potential arises that the version of a class reading the data is different than the version that wrote the data.</p>
<p>Versioning raises some fundamental questions about the identity of a class, including what constitutes a compatible change. A <em>compatible change</em> is a change that does not affect the contract between the class and its callers.</p>
<p>This section describes the goals, assumptions, and a solution that attempts to address this problem by restricting the kinds of changes allowed and by carefully choosing the mechanisms.</p>
<p>The proposed solution provides a mechanism for &quot;automatic&quot; handling of classes that evolve by adding fields and adding classes. Serialization will handle versioning without class-specific methods to be implemented for each version. The stream format can be traversed without invoking class-specific methods.</p>
<h2 id="goals">5.2 Goals</h2>
<p>The goals are to:</p>
<ul>
<li><p>Support bidirectional communication between different versions of a class operating in different virtual machines by:</p>
<ul>
<li><p>Defining a mechanism that allows Java classes to read streams written by older versions of the same class.</p></li>
<li><p>Defining a mechanism that allows Java classes to write streams intended to be read by older versions of the same class.</p></li>
</ul></li>
<li><p>Provide default serialization for persistence and for RMI.</p></li>
<li><p>Perform well and produce compact streams in simple cases, so that RMI can use serialization.</p></li>
<li><p>Be able to identify and load classes that match the exact class used to write the stream.</p></li>
<li><p>Keep the overhead low for nonversioned classes.</p></li>
<li><p>Use a stream format that allows the traversal of the stream without having to invoke methods specific to the objects saved in the stream.</p></li>
</ul>
<h2 id="assumptions">5.3 Assumptions</h2>
<p>The assumptions are that:</p>
<ul>
<li><p>Versioning will only apply to serializable classes since it must control the stream format to achieve it goals. Externalizable classes will be responsible for their own versioning which is tied to the external format.</p></li>
<li><p>All data and objects must be read from, or skipped in, the stream in the same order as they were written.</p></li>
<li><p>Classes evolve individually as well as in concert with supertypes and subtypes.</p></li>
<li><p>Classes are identified by name. Two classes with the same name may be different versions or completely different classes that can be distinguished only by comparing their interfaces or by comparing hashes of the interfaces.</p></li>
<li><p>Default serialization will not perform any type conversions.</p></li>
<li><p>The stream format only needs to support a linear sequence of type changes, not arbitrary branching of a type.</p></li>
</ul>
<h2 id="whos-responsible-for-versioning-of-streams">5.4 Who's Responsible for Versioning of Streams</h2>
<p>In the evolution of classes, it is the responsibility of the evolved (later version) class to maintain the contract established by the nonevolved class. This takes two forms. First, the evolved class must not break the existing assumptions about the interface provided by the original version, so that the evolved class can be used in place of the original. Secondly, when communicating with the original (or previous) versions, the evolved class must provide sufficient and equivalent information to allow the earlier version to continue to satisfy the nonevolved contract.</p>
<blockquote>
<figure>
<img src="images/version.gif" alt="Private serialization protocol and contract with supertype relationships between evolved and nonevolved classes and their instances" /><figcaption><em>Private serialization protocol and contract with supertype relationships between evolved and nonevolved classes and their instances</em></figcaption>
</figure>
</blockquote>
<p>For the purposes of the discussion here, each class implements and extends the interface or contract defined by its supertype. New versions of a class, for example <code>foo'</code>, must continue to satisfy the contract for <code>foo</code> and may extend the interface or modify its implementation.</p>
<p>Communication between objects via serialization is not part of the contract defined by these interfaces. Serialization is a private protocol between the implementations. It is the responsibility of the implementations to communicate sufficiently to allow each implementation to continue to satisfy the contract expected by its clients.</p>
<h2 id="compatible-java-type-evolution">5.5 Compatible Java Type Evolution</h2>
<p>The Java Language Specification discusses binary compatibility of Java classes as those classes evolve. Most of the flexibility of binary compatibility comes from the use of late binding of symbolic references for the names of classes, interfaces, fields, methods, and so on.</p>
<p>The following are the principle aspects of the design for versioning of serialized object streams.</p>
<ul>
<li><p>The default serialization mechanism will use a symbolic model for binding the fields in the stream to the fields in the corresponding class in the virtual machine.</p></li>
<li><p>Each class referenced in the stream will uniquely identify itself, its supertype, and the types and names of each serializable field written to the stream. The fields are ordered with the primitive types first sorted by field name, followed by the object fields sorted by field name.</p></li>
<li><p>Two types of data may occur in the stream for each class: required data (corresponding directly to the serializable fields of the object); and optional data (consisting of an arbitrary sequence of primitives and objects). The stream format defines how the required and optional data occur in the stream so that the whole class, the required, or the optional parts can be skipped if necessary.</p>
<ul>
<li><p>The required data consists of the fields of the object in the order defined by the class descriptor.</p></li>
<li><p>The optional data is written to the stream and does not correspond directly to fields of the class. The class itself is responsible for the length, types, and versioning of this optional information.</p></li>
</ul></li>
<li><p>If defined for a class, the <code>writeObject</code>/<code>readObject</code> methods supersede the default mechanism to write/read the state of the class. These methods write and read the optional data for a class. The required data is written by calling <code>defaultWriteObject</code> and read by calling <code>defaultReadObject</code>.</p></li>
<li><p>The stream format of each class is identified by the use of a Stream Unique Identifier (SUID). By default, this is the hash of the class. All later versions of the class must declare the Stream Unique Identifier (SUID) that they are compatible with. This guards against classes with the same name that might inadvertently be identified as being versions of a single class.</p></li>
<li><p>Subtypes of <code>ObjectOutputStream</code> and <code>ObjectInputStream</code> may include their own information identifying the class using the <code>annotateClass</code> method; for example, <code>MarshalOutputStream</code> embeds the URL of the class.</p></li>
</ul>
<h2 id="type-changes-affecting-serialization">5.6 Type Changes Affecting Serialization</h2>
<p>With these concepts, we can now describe how the design will cope with the different cases of an evolving class. The cases are described in terms of a stream written by some version of a class. When the stream is read back by the same version of the class, there is no loss of information or functionality. The stream is the only source of information about the original class. Its class descriptions, while a subset of the original class description, are sufficient to match up the data in the stream with the version of the class being reconstituted.</p>
<p>The descriptions are from the perspective of the stream being read in order to reconstitute either an earlier or later version of the class. In the parlance of RPC systems, this is a &quot;receiver makes right&quot; system. The writer writes its data in the most suitable form and the receiver must interpret that information to extract the parts it needs and to fill in the parts that are not available.</p>
<h3 id="incompatible-changes">5.6.1 Incompatible Changes</h3>
<p>Incompatible changes to classes are those changes for which the guarantee of interoperability cannot be maintained. The incompatible changes that may occur while evolving a class are:</p>
<ul>
<li><p>Deleting fields - If a field is deleted in a class, the stream written will not contain its value. When the stream is read by an earlier class, the value of the field will be set to the default value because no value is available in the stream. However, this default value may adversely impair the ability of the earlier version to fulfill its contract.</p></li>
<li><p>Moving classes up or down the hierarchy - This cannot be allowed since the data in the stream appears in the wrong sequence.</p></li>
<li><p>Changing a nonstatic field to static or a nontransient field to transient - When relying on default serialization, this change is equivalent to deleting a field from the class. This version of the class will not write that data to the stream, so it will not be available to be read by earlier versions of the class. As when deleting a field, the field of the earlier version will be initialized to the default value, which can cause the class to fail in unexpected ways.</p></li>
<li><p>Changing the declared type of a primitive field - Each version of the class writes the data with its declared type. Earlier versions of the class attempting to read the field will fail because the type of the data in the stream does not match the type of the field.</p></li>
<li><p>Changing the <code>writeObject</code> or <code>readObject</code> method so that it no longer writes or reads the default field data or changing it so that it attempts to write it or read it when the previous version did not. The default field data must consistently either appear or not appear in the stream.</p></li>
<li><p>Changing a class from <code>Serializable</code> to <code>Externalizable</code> or vice versa is an incompatible change since the stream will contain data that is incompatible with the implementation of the available class.</p></li>
<li><p>Changing a class from a non-enum type to an enum type or vice versa since the stream will contain data that is incompatible with the implementation of the available class.</p></li>
<li><p>Removing either <code>Serializable</code> or <code>Externalizable</code> is an incompatible change since when written it will no longer supply the fields needed by older versions of the class.</p></li>
<li><p>Adding the <code>writeReplace</code> or <code>readResolve</code> method to a class is incompatible if the behavior would produce an object that is incompatible with any older version of the class.</p></li>
</ul>
<h3 id="compatible-changes"><strong>5.6.2 Compatible Changes</strong></h3>
<div class="editorial">
<p>Addition of class&lt;-&gt;record compatible changes</p>
</div>
<p>The compatible changes to a class are handled as follows:</p>
<ul>
<li><p>Adding fields - When the class being reconstituted has a field that does not occur in the stream, that field in the object will be initialized to the default value for its type. If class-specific initialization is needed, the class may provide a readObject method that can initialize the field to nondefault values.</p></li>
<li><p>Adding classes - The stream will contain the type hierarchy of each object in the stream. Comparing this hierarchy in the stream with the current class can detect additional classes. Since there is no information in the stream from which to initialize the object, the class's fields will be initialized to the default values.</p></li>
<li><p>Removing classes - Comparing the class hierarchy in the stream with that of the current class can detect that a class has been deleted. In this case, the fields and objects corresponding to that class are read from the stream. Primitive fields are discarded, but the objects referenced by the deleted class are created, since they may be referred to later in the stream. They will be garbage-collected when the stream is garbage-collected or reset.</p></li>
<li><p>Adding <code>writeObject</code>/<code>readObject</code> methods - If the version reading the stream has these methods then <code>readObject</code> is expected, as usual, to read the required data written to the stream by the default serialization. It should call <code>defaultReadObject</code> first before reading any optional data. The <code>writeObject</code> method is expected as usual to call <code>defaultWriteObject</code> to write the required data and then may write optional data.</p></li>
<li><p>Removing <code>writeObject</code>/<code>readObject</code> methods - If the class reading the stream does not have these methods, the required data will be read by default serialization, and the optional data will be discarded.</p></li>
<li><p>Adding <code>java.io.Serializable</code> - This is equivalent to adding types. There will be no values in the stream for this class so its fields will be initialized to default values. The support for subclassing nonserializable classes requires that the class's supertype have a no-arg constructor and the class itself will be initialized to default values. If the no-arg constructor is not available, the <code>InvalidClassException</code> is thrown.</p></li>
<li><p>Changing the access to a field - The access modifiers public, package, protected, and private have no effect on the ability of serialization to assign values to the fields.</p></li>
<li><p>Changing a field from static to nonstatic or transient to nontransient - When relying on default serialization to compute the serializable fields, this change is equivalent to adding a field to the class. The new field will be written to the stream but earlier classes will ignore the value since serialization will not assign values to static or transient fields.</p></li>
</ul>
<div class="inserted">
<ul>
<li><p>Adding or removing a record component - When the record object being reconstituted has a record component that does not occur in the stream, the record class's canonical constructor will be passed the default value for its type. If specific initialization is needed, the constructor can initialize the component to a non-default value. Stream field values not passed to the canonical constructor are effectively discarded.</p></li>
<li><p>Changing a class from an ordinary class to a record class - A class that is suitable to be converted from an ordinary class to a record class, and relies on default serialization, may be changed to a record class. The ordinary class should have <code>java.lang.Object</code> as its direct superclass, or otherwise have no serializable state in its superclasses. The name and type of the record class's components must match that of the name and type of the ordinary class's serializable fields. Record objects are reconstructed through the record class's canonical constructor. If the canonical constructor throws an exception, say while checking invariants, then an <code>InvalidObjectException</code> is thrown.</p></li>
<li>Changing a class from a record class to an ordinary class - A record class that relies on default serialization, may be changed to an ordinary class. The ordinary class must declare an explicit <code>serialVersionUID</code>, whose value is the same as that of the prior record class's <code>serialVersionUID</code>, or <code>0L</code> if the prior record class does not have an explicit <code>serialVersionUID</code> declaration. The name and type of the ordinary class's serializable fields must match that of the name and type of the prior record class's components.</li>
</ul>
</div>
<hr />
<h1 id="object-serialization-stream-protocol">6 - Object Serialization Stream Protocol</h1>
<h2 id="overview-2">6.1 Overview</h2>
<p>The stream format satisfies the following design goals:</p>
<ul>
<li>Is compact and is structured for efficient reading.</li>
<li>Allows skipping through the stream using only the knowledge of the structure and format of the stream. Does not require invoking any per class code.</li>
<li>Requires only stream access to the data.</li>
</ul>
<h2 id="stream-elements">6.2 Stream Elements</h2>
<p>A basic structure is needed to represent objects in a stream. Each attribute of the object needs to be represented: its classes, its fields, and data written and later read by class-specific methods. The representation of objects in the stream can be described with a grammar. There are special representations for null objects, new objects, classes, arrays, strings, and back references to any object already in the stream. Each object written to the stream is assigned a handle that is used to refer back to the object. Handles are assigned sequentially starting from 0x7E0000. The handles restart at 0x7E0000 when the stream is reset.</p>
<p>A class object is represented by the following:</p>
<ul>
<li>Its <code>ObjectStreamClass</code> object.</li>
</ul>
<p>An <code>ObjectStreamClass</code> object for a Class that is not a dynamic proxy class is represented by the following:</p>
<ul>
<li><p>The Stream Unique Identifier (SUID) of compatible classes.</p></li>
<li><p>A set of flags indicating various properties of the class, such as whether the class defines a <code>writeObject</code> method, and whether the class is serializable, externalizable, or an enum type</p></li>
<li><p>The number of serializable fields</p></li>
<li><p>The array of fields of the class that are serialized by the default mechanismFor arrays and object fields, the type of the field is included as a string which must be in &quot;field descriptor&quot; format (e.g., &quot;<code>Ljava/lang/Object;</code>&quot;) as specified in The Java Virtual Machine Specification.</p></li>
<li><p>Optional block-data records or objects written by the <code>annotateClass</code> method</p></li>
<li><p>The <code>ObjectStreamClass</code> of its supertype (null if the superclass is not serializable)</p></li>
</ul>
<p>An <code>ObjectStreamClass</code> object for a dynamic proxy class is represented by the following:</p>
<ul>
<li><p>The number of interfaces that the dynamic proxy class implements</p></li>
<li><p>The names of all of the interfaces implemented by the dynamic proxy class, listed in the order that they are returned by invoking the <code>getInterfaces</code> method on the Class object.</p></li>
<li><p>Optional block-data records or objects written by the <code>annotateProxyClass</code> method.</p></li>
<li><p>The ObjectStreamClass of its supertype, <code>java.lang.reflect.Proxy</code>.</p></li>
</ul>
<p>The representation of <code>String</code> objects consists of length information followed by the contents of the string encoded in modified UTF-8. The modified UTF-8 encoding is the same as used in the Java Virtual Machine and in the <code>java.io.DataInput</code> and <code>DataOutput</code> interfaces; it differs from standard UTF-8 in the representation of supplementary characters and of the null character. The form of the length information depends on the length of the string in modified UTF-8 encoding. If the modified UTF-8 encoding of the given <code>String</code> is less than 65536 bytes in length, the length is written as 2 bytes representing an unsigned 16-bit integer. Starting with the Java 2 platform, Standard Edition, v1.3, if the length of the string in modified UTF-8 encoding is 65536 bytes or more, the length is written in 8 bytes representing a signed 64-bit integer. The typecode preceding the <code>String</code> in the serialization stream indicates which format was used to write the <code>String</code>.</p>
<p>Arrays are represented by the following:</p>
<ul>
<li><p>Their <code>ObjectStreamClass</code> object.</p></li>
<li><p>The number of elements.</p></li>
<li><p>The sequence of values. The type of the values is implicit in the type of the array. for example the values of a byte array are of type byte.</p></li>
</ul>
<p>Enum constants are represented by the following:</p>
<ul>
<li><p>The <code>ObjectStreamClass</code> object of the constant's base enum type.</p></li>
<li><p>The constant's name string.</p></li>
</ul>
<p>New objects in the stream are represented by the following:</p>
<ul>
<li><p>The most derived class of the object.</p></li>
<li><p>Data for each serializable class of the object, with the highest superclass first. For each class the stream contains the following:</p>
<ul>
<li><p>The serializable fields.See <a href="serial-arch.html#defining-serializable-fields-for-a-class">Section 1.5, &quot;Defining Serializable Fields for a Class&quot;</a>.</p></li>
<li><p>If the class has <code>writeObject</code>/<code>readObject</code> methods, there may be optional objects and/or block-data records of primitive types written by the <code>writeObject</code> method followed by an <code>endBlockData</code> code.</p></li>
</ul></li>
</ul>
<p>All primitive data written by classes is buffered and wrapped in block-data records, regardless if the data is written to the stream within a <code>writeObject</code> method or written directly to the stream from outside a <code>writeObject</code> method. This data can only be read by the corresponding <code>readObject</code> methods or be read directly from the stream. Objects written by the <code>writeObject</code> method terminate any previous block-data record and are written either as regular objects or null or back references, as appropriate. The block-data records allow error recovery to discard any optional data. When called from within a class, the stream can discard any data or objects until the <code>endBlockData</code>.</p>
<h2 id="stream-protocol-versions">6.3 Stream Protocol Versions</h2>
<p>It was necessary to make a change to the serialization stream format in JDK 1.2 that is not backwards compatible to all minor releases of JDK 1.1. To provide for cases where backwards compatibility is required, a capability has been added to indicate what <code>PROTOCOL_VERSION</code> to use when writing a serialization stream. The method <code>ObjectOutputStream.useProtocolVersion</code> takes as a parameter the protocol version to use to write the serialization stream.</p>
<p>The Stream Protocol Versions are as follows:</p>
<ul>
<li><p><code>ObjectStreamConstants.PROTOCOL_VERSION_1</code>: Indicates the initial stream format.</p></li>
<li><p><code>ObjectStreamConstants.PROTOCOL_VERSION_2</code>: Indicates the new external data format. Primitive data is written in block data mode and is terminated with <code>TC_ENDBLOCKDATA</code>.</p>
<p>Block data boundaries have been standardized. Primitive data written in block data mode is normalized to not exceed 1024 byte chunks. The benefit of this change was to tighten the specification of serialized data format within the stream. This change is fully backward and forward compatible.</p></li>
</ul>
<p>JDK 1.2 defaults to writing <code>PROTOCOL_VERSION_2</code>.</p>
<p>JDK 1.1 defaults to writing <code>PROTOCOL_VERSION_1</code>.</p>
<p>JDK 1.1.7 and greater can read both versions.</p>
<p>Releases prior to JDK 1.1.7 can only read <code>PROTOCOL_VERSION_1</code>.</p>
<h2 id="grammar-for-the-stream-format">6.4 Grammar for the Stream Format</h2>
<p>The table below contains the grammar for the stream format. Nonterminal symbols are shown in italics. Terminal symbols in a <em>fixed width font</em>. Definitions of nonterminals are followed by a &quot;:&quot;. The definition is followed by one or more alternatives, each on a separate line. The following table describes the notation:</p>
<table style="width:98%;">
<colgroup>
<col style="width: 18%" />
<col style="width: 78%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;"><em>Notation</em></th>
<th style="text-align: left;"><em>Meaning</em></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<th style="font-weight: normal; text-align: left;" scope="row">(<em>datatype</em>)</th>
<td style="text-align: left;">This token has the data type specified, such as byte.</td>
</tr>
<tr class="even">
<th style="font-weight: normal; text-align: left;" scope="row"><em>token</em>[n]</th>
<td style="text-align: left;">A predefined number of occurrences of the token, that is an array.</td>
</tr>
<tr class="odd">
<th style="font-weight: normal; text-align: left;" scope="row"><em>x0001</em></th>
<td style="text-align: left;">A literal value expressed in hexadecimal. The number of hex digits reflects the size of the value.</td>
</tr>
<tr class="even">
<th style="font-weight: normal; text-align: left;" scope="row">&lt;<em>xxx</em>&gt;</th>
<td style="text-align: left;">A value read from the stream used to indicate the length of an array.</td>
</tr>
</tbody>
</table>
<p>Note that the symbol (utf) is used to designate a string written using 2-byte length information, and (long-utf) is used to designate a string written using 8-byte length information. For details, refer to <a href="#stream-elements">Section 6.2, &quot;Stream Elements&quot;</a>.</p>
<h3 id="rules-of-the-grammar">6.4.1 Rules of the Grammar</h3>
<p>A Serialized stream is represented by any stream satisfying the <em>stream</em> rule.</p>
<pre><code>stream:
  magic version contents

contents:
  content
  contents content

content:
  object
  blockdata

object:
  newObject
  newClass
  newArray
  newString
  newEnum
  newClassDesc
  prevObject
  nullReference
  exception
  TC_RESET

newClass:
  TC_CLASS classDesc newHandle

classDesc:
  newClassDesc
  nullReference
  (ClassDesc)prevObject      // an object required to be of type ClassDesc

superClassDesc:
  classDesc

newClassDesc:
  TC_CLASSDESC className serialVersionUID newHandle classDescInfo
  TC_PROXYCLASSDESC newHandle proxyClassDescInfo

classDescInfo:
  classDescFlags fields classAnnotation superClassDesc

className:
  (utf)

serialVersionUID:
  (long)

classDescFlags:
  (byte)                  // Defined in Terminal Symbols and Constants

proxyClassDescInfo:
  (int)&lt;count&gt; proxyInterfaceName[count] classAnnotation
      superClassDesc

proxyInterfaceName:
  (utf)

fields:
  (short)&lt;count&gt; fieldDesc[count]

fieldDesc:
  primitiveDesc
  objectDesc

primitiveDesc:
  prim_typecode fieldName

objectDesc:
  obj_typecode fieldName className1

fieldName:
  (utf)

className1:
  (String)object             // String containing the field&#39;s type,
                             // in field descriptor format

classAnnotation:
  endBlockData
  contents endBlockData      // contents written by annotateClass

prim_typecode:
  &#39;B&#39;       // byte
  &#39;C&#39;       // char
  &#39;D&#39;       // double
  &#39;F&#39;       // float
  &#39;I&#39;       // integer
  &#39;J&#39;       // long
  &#39;S&#39;       // short
  &#39;Z&#39;       // boolean

obj_typecode:
  &#39;[&#39;       // array
  &#39;L&#39;       // object

newArray:
  TC_ARRAY classDesc newHandle (int)&lt;size&gt; values[size]

newObject:
  TC_OBJECT classDesc newHandle classdata[]  // data for each class

classdata:
  nowrclass                 // SC_SERIALIZABLE &amp; classDescFlag &amp;&amp;
                            // !(SC_WRITE_METHOD &amp; classDescFlags)
  wrclass objectAnnotation  // SC_SERIALIZABLE &amp; classDescFlag &amp;&amp;
                            // SC_WRITE_METHOD &amp; classDescFlags
  externalContents          // SC_EXTERNALIZABLE &amp; classDescFlag &amp;&amp;
                            // !(SC_BLOCKDATA  &amp; classDescFlags
  objectAnnotation          // SC_EXTERNALIZABLE &amp; classDescFlag&amp;&amp;
                            // SC_BLOCKDATA &amp; classDescFlags

nowrclass:
  values                    // fields in order of class descriptor

wrclass:
  nowrclass

objectAnnotation:
  endBlockData
  contents endBlockData     // contents written by writeObject
                            // or writeExternal PROTOCOL_VERSION_2.

blockdata:
  blockdatashort
  blockdatalong

blockdatashort:
  TC_BLOCKDATA (unsigned byte)&lt;size&gt; (byte)[size]

blockdatalong:
  TC_BLOCKDATALONG (int)&lt;size&gt; (byte)[size]

endBlockData:
  TC_ENDBLOCKDATA

externalContent:         // Only parseable by readExternal
  (bytes)                // primitive data
   object

externalContents:         // externalContent written by
  externalContent         // writeExternal in PROTOCOL_VERSION_1.
  externalContents externalContent

newString:
  TC_STRING newHandle (utf)
  TC_LONGSTRING newHandle (long-utf)

newEnum:
  TC_ENUM classDesc newHandle enumConstantName

enumConstantName:
  (String)object

prevObject:
  TC_REFERENCE (int)handle

nullReference:
  TC_NULL

exception:
  TC_EXCEPTION reset (Throwable)object reset

magic:
  STREAM_MAGIC

version:
  STREAM_VERSION

values:          // The size and types are described by the
                 // classDesc for the current object

newHandle:       // The next number in sequence is assigned
                 // to the object being serialized or deserialized

reset:           // The set of known objects is discarded
                 // so the objects of the exception do not
                 // overlap with the previously sent objects
                 // or with objects that may be sent after
                 // the exception</code></pre>
<h3 id="terminal-symbols-and-constants">6.4.2 Terminal Symbols and Constants</h3>
<p>The following symbols in <code>java.io.ObjectStreamConstants</code> define the terminal and constant values expected in a stream.</p>
<pre><code>final static short STREAM_MAGIC = (short)0xaced;
final static short STREAM_VERSION = 5;
final static byte TC_NULL = (byte)0x70;
final static byte TC_REFERENCE = (byte)0x71;
final static byte TC_CLASSDESC = (byte)0x72;
final static byte TC_OBJECT = (byte)0x73;
final static byte TC_STRING = (byte)0x74;
final static byte TC_ARRAY = (byte)0x75;
final static byte TC_CLASS = (byte)0x76;
final static byte TC_BLOCKDATA = (byte)0x77;
final static byte TC_ENDBLOCKDATA = (byte)0x78;
final static byte TC_RESET = (byte)0x79;
final static byte TC_BLOCKDATALONG = (byte)0x7A;
final static byte TC_EXCEPTION = (byte)0x7B;
final static byte TC_LONGSTRING = (byte) 0x7C;
final static byte TC_PROXYCLASSDESC = (byte) 0x7D;
final static byte TC_ENUM = (byte) 0x7E;
final static  int   baseWireHandle = 0x7E0000;</code></pre>
<p>The flag byte <em>classDescFlags</em> may include values of</p>
<pre><code>final static byte SC_WRITE_METHOD = 0x01; //if SC_SERIALIZABLE
final static byte SC_BLOCK_DATA = 0x08;    //if SC_EXTERNALIZABLE
final static byte SC_SERIALIZABLE = 0x02;
final static byte SC_EXTERNALIZABLE = 0x04;
final static byte SC_ENUM = 0x10;</code></pre>
<p>The flag <code>SC_WRITE_METHOD</code> is set if the Serializable class writing the stream had a <code>writeObject</code> method that may have written additional data to the stream. In this case a <code>TC_ENDBLOCKDATA</code> marker is always expected to terminate the data for that class.</p>
<p>The flag <code>SC_BLOCKDATA</code> is set if the <code>Externalizable</code> class is written into the stream using <code>STREAM_PROTOCOL_2</code>. By default, this is the protocol used to write <code>Externalizable</code> objects into the stream in JDK 1.2. JDK 1.1 writes <code>STREAM_PROTOCOL_1</code>.</p>
<p>The flag <code>SC_SERIALIZABLE</code> is set if the class that wrote the stream extended <code>java.io.Serializable</code> but not <code>java.io.Externalizable</code>, the class reading the stream must also extend <code>java.io.Serializable</code> and the default serialization mechanism is to be used.</p>
<p>The flag <code>SC_EXTERNALIZABLE</code> is set if the class that wrote the stream extended <code>java.io.Externalizable</code>, the class reading the data must also extend <code>Externalizable</code> and the data will be read using its <code>writeExternal</code> and <code>readExternal</code> methods.</p>
<p>The flag <code>SC_ENUM</code> is set if the class that wrote the stream was an enum type. The receiver's corresponding class must also be an enum type. Data for constants of the enum type will be written and read as described in <a href="serial-arch.html#serialization-of-enum-constants">Section 1.12, &quot;Serialization of Enum Constants&quot;</a>.</p>
<h4 id="example">Example</h4>
<p>Consider the case of an original class and two instances in a linked list:</p>
<pre><code>class List implements java.io.Serializable {
    int value;
    List next;
    public static void main(String[] args) {
        try {
            List list1 = new List();
            List list2 = new List();
            list1.value = 17;
            list1.next = list2;
            list2.value = 19;
            list2.next = null;

            ByteArrayOutputStream o = new ByteArrayOutputStream();
            ObjectOutputStream out = new ObjectOutputStream(o);
            out.writeObject(list1);
            out.writeObject(list2);
            out.flush();
            ...
        } catch (Exception ex) {
            ex.printStackTrace();
        }
    }
}</code></pre>
<p>The resulting stream contains:</p>
<pre><code>    00: ac ed 00 05 73 72 00 04 4c 69 73 74 69 c8 8a 15 &gt;....sr..Listi...&lt;
    10: 40 16 ae 68 02 00 02 49 00 05 76 61 6c 75 65 4c &gt;Z......I..valueL&lt;
    20: 00 04 6e 65 78 74 74 00 06 4c 4c 69 73 74 3b 78 &gt;..nextt..LList;x&lt;
    30: 70 00 00 00 11 73 71 00 7e 00 00 00 00 00 13 70 &gt;p....sq.~......p&lt;
    40: 71 00 7e 00 03                                  &gt;q.~..&lt;</code></pre>
</main><footer class="legal-footer"><hr/><a href="../legal/copyright.html">Copyright</a> &copy; 1993, 2020, Oracle and/or its affiliates, 500 Oracle Parkway, Redwood Shores, CA 94065 USA.<br>All rights reserved. Use is subject to <a href="https://www.oracle.com/technetwork/java/javase/terms/license/java14.0.2speclicense.html">license terms</a> and the <a href="https://www.oracle.com/technetwork/java/redist-137594.html">documentation redistribution policy</a>. <!-- Version 14.0.2+12-46 --></footer>
</body>
</html>