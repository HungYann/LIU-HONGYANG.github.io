<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc,fixuphtml" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Records</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(data-line-number);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="../resources/jdk-default.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  <link rel="stylesheet" href="../resources/spec-changes.css" />
</head>
<body>
<header id="title-block-header">
<h1 class="title">Records</h1>
<p class="subtitle">Changes to the Java® Language Specification • Version 14.0.2+12-46</p>
</header>
<nav id="TOC" title="Table Of Contents">
<ul>
<li><a href="#jls-1">Chapter 1: Introduction</a><ul>
<li><a href="#jls-1.1">1.1 Organization of the Specification</a></li>
<li><a href="#jls-1.5">1.5 Preview Features</a></li>
</ul></li>
<li><a href="#jls-3">Chapter 3: Lexical Structure</a><ul>
<li><a href="#jls-3.8">3.8 Identifiers</a></li>
<li><a href="#jls-3.9">3.9 Keywords</a></li>
</ul></li>
<li><a href="#jls-4">Chapter 4: Types, Values, and Variables</a><ul>
<li><a href="#jls-4.11">4.11 Where Types Are Used</a></li>
<li><a href="#jls-4.12">4.12 Variables</a><ul>
<li><a href="#jls-4.12.3">4.12.3 Kinds of Variables</a></li>
<li><a href="#jls-4.12.4">4.12.4 <code>final</code> Variables</a></li>
</ul></li>
</ul></li>
<li><a href="#jls-6">Chapter 6: Names</a><ul>
<li><a href="#jls-6.1">6.1 Declarations</a></li>
<li><a href="#jls-6.5">6.5 Determining the Meaning of a Name</a><ul>
<li><a href="#jls-6.5.1">6.5.1 Syntactic Classification of a Name According to Context</a></li>
</ul></li>
</ul></li>
<li><a href="#jls-7">Chapter 7: Packages and Modules</a><ul>
<li><a href="#jls-7.5">7.5 Import Declarations</a><ul>
<li><a href="#jls-7.5.1">7.5.1 Single-Type-Import Declarations</a></li>
<li><a href="#jls-7.5.2">7.5.2 Type-Import-on-Demand Declarations</a></li>
<li><a href="#jls-7.5.3">7.5.3 Single-Static-Import Declarations</a></li>
<li><a href="#jls-7.5.4">7.5.4 Static-Import-on-Demand Declarations</a></li>
</ul></li>
</ul></li>
<li><a href="#jls-8">Chapter 8: Classes</a><ul>
<li><a href="#jls-8.1">8.1 Class Declarations</a><ul>
<li><a href="#jls-8.1.4">8.1.4 Superclasses and Subclasses</a></li>
</ul></li>
<li><a href="#jls-8.5">8.5 Member Type Declarations</a><ul>
<li><a href="#jls-8.5.1">8.5.1 Static Member Type Declarations</a></li>
</ul></li>
<li><a href="#jls-8.8">8.8 Constructor Declarations</a></li>
<li><a href="#jls-8.10"><strong>8.10 Record Types</strong></a><ul>
<li><a href="#jls-8.10.1"><strong>8.10.1 Record Components</strong></a></li>
<li><a href="#jls-8.10.2"><strong>8.10.2 Record Bodies</strong></a></li>
<li><a href="#jls-8.10.3"><strong>8.10.3 Record Members</strong></a></li>
<li><a href="#jls-8.10.4"><strong>8.10.4 Record Constructor Declarations</strong></a></li>
<li><a href="#jls-8.10.5"><strong>8.10.5 Compact Record Constructor Declarations</strong></a></li>
</ul></li>
</ul></li>
<li><a href="#jls-9">Chapter 9: Interfaces</a><ul>
<li><a href="#jls-9.6">9.6 Annotation Types</a><ul>
<li><a href="#jls-9.6.4">9.6.4 Predefined Annotation Types</a><ul>
<li><a href="#jls-9.6.4.1">9.6.4.1 <code>@Target</code></a></li>
</ul></li>
</ul></li>
<li><a href="#jls-9.7">9.7 Annotations</a><ul>
<li><a href="#jls-9.7.4">9.7.4 Where Annotations May Appear</a></li>
</ul></li>
</ul></li>
<li><a href="#jls-10">Chapter 10: Arrays</a><ul>
<li><a href="#jls-10.2">10.2 Array Variables</a></li>
</ul></li>
<li><a href="#jls-13">Chapter 13: Binary Compatibility</a><ul>
<li><a href="#jls-13.1">13.1 The Form of a Binary</a></li>
<li><a href="#jls-13.4">13.4 Evolution of Classes</a><ul>
<li><a href="#jls-13.4.27"><strong>13.4.27 Evolution of Records</strong></a></li>
</ul></li>
</ul></li>
<li><a href="#jls-14">Chapter 14: Blocks and Statements</a><ul>
<li><a href="#jls-14.2">14.2 Blocks</a></li>
<li><a href="#jls-14.3">14.3 Local Class Declarations</a></li>
</ul></li>
</ul>
</nav>
<main><p>This document describes changes to the <a href="https://docs.oracle.com/javase/specs/jls/se13/html">Java Language Specification</a> to support <em>records</em>, a preview feature of Java SE 14. See <a href="https://openjdk.java.net/jeps/359">JEP 359</a> for an overview of the feature.</p>
<p>A <a href="records-jvms.html">companion document</a> describes the changes needed to the <a href="https://docs.oracle.com/javase/specs/jvms/se13/html">Java Virtual Machine Specification</a> to support records.</p>
<p>Changes are described with respect to existing sections of the JLS. New text is indicated <strong>like this</strong> and deleted text is indicated <del>like this</del>. Explanation and discussion, as needed, is set aside in grey boxes.</p>
<h2 id="jls-1">Chapter 1: Introduction</h2>
<h3 id="jls-1.1">1.1 Organization of the Specification</h3>
<p>Chapter 2 describes grammars and the notation used to present the lexical and syntactic grammars for the language.</p>
<p>Chapter 3 describes the lexical structure of the Java programming language, which is based on C and C++. The language is written in the Unicode character set. It supports the writing of Unicode characters on systems that support only ASCII.</p>
<p>Chapter 4 describes types, values, and variables. Types are subdivided into primitive types and reference types.</p>
<p>The primitive types are defined to be the same on all machines and in all implementations, and are various sizes of two's-complement integers, single- and double-precision IEEE 754 standard floating-point numbers, a <code>boolean</code> type, and a Unicode character <code>char</code> type. Values of the primitive types do not share state.</p>
<p>Reference types are the class types, the interface types, and the array types. The reference types are implemented by dynamically created objects that are either instances of classes or arrays. Many references to each object can exist. All objects (including arrays) support the methods of the class <code>Object</code>, which is the (single) root of the class hierarchy. A predefined <code>String</code> class supports Unicode character strings. Classes exist for wrapping primitive values inside of objects. In many cases, wrapping and unwrapping is performed automatically by the compiler (in which case, wrapping is called boxing, and unwrapping is called unboxing). Class and interface declarations may be generic, that is, they may be parameterized by other reference types. Such declarations may then be invoked with specific type arguments.</p>
<p>Variables are typed storage locations. A variable of a primitive type holds a value of that exact primitive type. A variable of a class type can hold a null reference or a reference to an object whose type is that class type or any subclass of that class type. A variable of an interface type can hold a null reference or a reference to an instance of any class that implements the interface. A variable of an array type can hold a null reference or a reference to an array. A variable of class type <code>Object</code> can hold a null reference or a reference to any object, whether class instance or array.</p>
<p>Chapter 5 describes conversions and numeric promotions. Conversions change the compile-time type and, sometimes, the value of an expression. These conversions include the boxing and unboxing conversions between primitive types and reference types. Numeric promotions are used to convert the operands of a numeric operator to a common type where an operation can be performed. There are no loopholes in the language; casts on reference types are checked at run time to ensure type safety.</p>
<p>Chapter 6 describes declarations and names, and how to determine what names mean (that is, which declaration a name denotes). The Java programming language does not require classes and interfaces, or their members, to be declared before they are used. Declaration order is significant only for local variables, local classes, and the order of field initializers in a class or interface. Recommended naming conventions that make for more readable programs are described here.</p>
<p>Chapter 7 describes the structure of a program, which is organized into packages. The members of a package are classes, interfaces, and subpackages. Packages, and consequently their members, have names in a hierarchical name space; the Internet domain name system can usually be used to form unique package names. Compilation units contain declarations of the classes and interfaces that are members of a given package, and may import classes and interfaces from other packages to give them short names.</p>
<p>Packages may be grouped into modules that serve as building blocks in the construction of very large programs. The declaration of a module specifies which other modules (and thus packages, and thus classes and interfaces) are required in order to compile and run code in its own packages.</p>
<p>The Java programming language supports limitations on external access to the members of packages, classes, and interfaces. The members of a package may be accessible solely by other members in the same package, or by members in other packages of the same module, or by members of packages in different modules. Similar constraints apply to the members of classes and interfaces.</p>
<p>Chapter 8 describes classes. The members of classes are classes, interfaces, fields (variables) and methods. Class variables exist once per class. Class methods operate without reference to a specific object. Instance variables are dynamically created in objects that are instances of classes. Instance methods are invoked on instances of classes; such instances become the current object <code>this</code> during their execution, supporting the object-oriented programming style.</p>
<p>Classes support single inheritance, in which each class has a single superclass. Each class inherits members from its superclass, and ultimately from the class <code>Object</code>. Variables of a class type can reference an instance of that class or of any subclass of that class, allowing new types to be used with existing methods, polymorphically.</p>
<p>Classes support concurrent programming with <code>synchronized</code> methods. Methods declare the checked exceptions that can arise from their execution, which allows compile-time checking to ensure that exceptional conditions are handled. Objects can declare a <code>finalize</code> method that will be invoked before the objects are discarded by the garbage collector, allowing the objects to clean up their state.</p>
<p>For simplicity, the language has neither declaration &quot;headers&quot; separate from the implementation of a class nor separate type and class hierarchies.</p>
<p><strong>Enums are a special kind of class that support the definition of small sets of values which can then be used in a type safe manner.</strong> <del>A special form of classes, enums, support the definition of small sets of values and their manipulation in a type safe manner.</del> Unlike enumerations in other languages, enums are objects and may have their own methods.</p>
<p><strong>Records are another special kind of class that support the compact expression of simple objects that serve as aggregates of values.</strong></p>
<p>Chapter 9 describes interfaces. The members of interfaces are classes, interfaces, constant fields, and methods. Classes that are otherwise unrelated can implement the same interface. A variable of an interface type can contain a reference to any object that implements the interface.</p>
<p>Classes and interfaces support multiple inheritance from interfaces. A class that implements one or more interfaces may inherit instance methods from both its superclass and its superinterfaces.</p>
<p>Annotation types are specialized interfaces used to annotate declarations. Such annotations are not permitted to affect the semantics of programs in the Java programming language in any way. However, they provide useful input to various tools.</p>
<p>Chapter 10 describes arrays. Array accesses include bounds checking. Arrays are dynamically created objects and may be assigned to variables of type <code>Object</code>. The language supports arrays of arrays, rather than multidimensional arrays.</p>
<p>Chapter 11 describes exceptions, which are nonresuming and fully integrated with the language semantics and concurrency mechanisms. There are three kinds of exceptions: checked exceptions, run-time exceptions, and errors. The compiler ensures that checked exceptions are properly handled by requiring that a method or constructor can result in a checked exception only if the method or constructor declares it. This provides compile-time checking that exception handlers exist, and aids programming in the large. Most user-defined exceptions should be checked exceptions. Invalid operations in the program detected by the Java Virtual Machine result in run-time exceptions, such as <code>NullPointerException</code>. Errors result from failures detected by the Java Virtual Machine, such as <code>OutOfMemoryError</code>. Most simple programs do not try to handle errors.</p>
<p>Chapter 12 describes activities that occur during execution of a program. A program is normally stored as binary files representing compiled classes and interfaces. These binary files can be loaded into a Java Virtual Machine, linked to other classes and interfaces, and initialized.</p>
<p>After initialization, class methods and class variables may be used. Some classes may be instantiated to create new objects of the class type. Objects that are class instances also contain an instance of each superclass of the class, and object creation involves recursive creation of these superclass instances.</p>
<p>When an object is no longer referenced, it may be reclaimed by the garbage collector. If an object declares a finalizer, the finalizer is executed before the object is reclaimed to give the object a last chance to clean up resources that would not otherwise be released. When a class is no longer needed, it may be unloaded.</p>
<p>Chapter 13 describes binary compatibility, specifying the impact of changes to types on other types that use the changed types but have not been recompiled. These considerations are of interest to developers of types that are to be widely distributed, in a continuing series of versions, often through the Internet. Good program development environments automatically recompile dependent code whenever a type is changed, so most programmers need not be concerned about these details.</p>
<p>Chapter 14 describes blocks and statements, which are based on C and C++. The language has no <code>goto</code> statement, but includes labeled <code>break</code> and <code>continue</code> statements. Unlike C, the Java programming language requires <code>boolean</code> (or <code>Boolean</code>) expressions in control-flow statements, and does not convert types to <code>boolean</code> implicitly (except through unboxing), in the hope of catching more errors at compile time. A <code>synchronized</code> statement provides basic object-level monitor locking. A <code>try</code> statement can include <code>catch</code> and <code>finally</code> clauses to protect against non-local control transfers.</p>
<p>Chapter 15 describes expressions. This document fully specifies the (apparent) order of evaluation of expressions, for increased determinism and portability. Overloaded methods and constructors are resolved at compile time by picking the most specific method or constructor from those which are applicable.</p>
<p>Chapter 16 describes the precise way in which the language ensures that local variables are definitely set before use. While all other variables are automatically initialized to a default value, the Java programming language does not automatically initialize local variables in order to avoid masking programming errors.</p>
<p>Chapter 17 describes the semantics of threads and locks, which are based on the monitor-based concurrency originally introduced with the Mesa programming language. The Java programming language specifies a memory model for shared-memory multiprocessors that supports high-performance implementations.</p>
<p>Chapter 18 describes a variety of type inference algorithms used to test applicability of generic methods and to infer types in a generic method invocation.</p>
<p>Chapter 19 presents a syntactic grammar for the language.</p>
<h3 id="jls-1.5">1.5 Preview Features</h3>
<div class="editorial">
<p>The following text will be added to the description of the preview feature: Record Types.</p>
</div>
<div class="inserted">
<p>The following are essential API elements associated with Record Types:</p>
<ul>
<li>The class <code>java.lang.Record</code>.</li>
<li>The enum constant <code>RECORD_COMPONENT</code> in <code>java.lang.annotation.ElementType</code>.</li>
</ul>
</div>
<h2 id="jls-3">Chapter 3: Lexical Structure</h2>
<h3 id="jls-3.8">3.8 Identifiers</h3>
<p>An <em>identifier</em> is an unlimited-length sequence of <em>Java letters</em> and <em>Java digits</em>, the first of which must be a <em>Java letter</em>.</p>
<dl>
<dt><em>Identifier:</em></dt>
<dd><em>IdentifierChars</em> <em>but not a</em> <em>Keyword</em> <em>or</em> <em>BooleanLiteral</em> <em>or</em> <em>NullLiteral</em>
</dd>
<dt><em>IdentifierChars:</em></dt>
<dd><em>JavaLetter</em> {<em>JavaLetterOrDigit</em>}
</dd>
<dt><em>JavaLetter:</em></dt>
<dd><em>any Unicode character that is a &quot;Java letter&quot;</em>
</dd>
<dt><em>JavaLetterOrDigit:</em></dt>
<dd><em>any Unicode character that is a &quot;Java letter-or-digit&quot;</em>
</dd>
</dl>
<p>A &quot;Java letter&quot; is a character for which the method <code>Character.isJavaIdentifierStart(int)</code> returns true.</p>
<p>A &quot;Java letter-or-digit&quot; is a character for which the method <code>Character.isJavaIdentifierPart(int)</code> returns true.</p>
<blockquote>
<p>The &quot;Java letters&quot; include uppercase and lowercase ASCII Latin letters <code>A-Z</code> (<code>\u0041-\u005a</code>), and <code>a-z</code> (<code>\u0061-\u007a</code>), and, for historical reasons, the ASCII dollar sign (<code>$</code>, or <code>\u0024</code>) and underscore (<code>_</code>, or <code>\u005f</code>). The dollar sign should be used only in mechanically generated source code or, rarely, to access pre-existing names on legacy systems. The underscore may be used in identifiers formed of two or more characters, but it cannot be used as a one-character identifier due to being a keyword.</p>
</blockquote>
<blockquote>
<p>The &quot;Java digits&quot; include the ASCII digits <code>0-9</code> (<code>\u0030-\u0039</code>).</p>
</blockquote>
<p>Letters and digits may be drawn from the entire Unicode character set, which supports most writing scripts in use in the world today, including the large sets for Chinese, Japanese, and Korean. This allows programmers to use identifiers in their programs that are written in their native languages.</p>
<p>An identifier cannot have the same spelling (Unicode character sequence) as a keyword (<a href="#jls-3.9">3.9</a>), boolean literal (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-3.html#jls-3.10.3">3.10.3</a>), or the null literal (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-3.html#jls-3.10.7">3.10.7</a>), or a compile-time error occurs.</p>
<p>Two identifiers are the same only if, after ignoring characters that are ignorable, the identifiers have the same Unicode character for each letter or digit. An ignorable character is a character for which the method <code>Character.isIdentifierIgnorable(int)</code> returns true. Identifiers that have the same external appearance may yet be different.</p>
<blockquote>
<p>For example, the identifiers consisting of the single letters LATIN CAPITAL LETTER A (<code>A</code>, <code>\u0041</code>), LATIN SMALL LETTER A (<code>a</code>, <code>\u0061</code>), GREEK CAPITAL LETTER ALPHA (<code>A</code>, <code>\u0391</code>), CYRILLIC SMALL LETTER A (<code>a</code>, <code>\u0430</code>) and MATHEMATICAL BOLD ITALIC SMALL A (<code>a</code>, <code>\ud835\udc82</code>) are all different.</p>
<p>Unicode composite characters are different from their canonical equivalent decomposed characters. For example, a LATIN CAPITAL LETTER A ACUTE (<code>Á</code>, <code>\u00c1</code>) is different from a LATIN CAPITAL LETTER A (<code>A</code>, <code>\u0041</code>) immediately followed by a NON-SPACING ACUTE (<code>´</code>, <code>\u0301</code>) in identifiers. See The Unicode Standard, Section 3.11 &quot;Normalization Forms&quot;.</p>
</blockquote>
<blockquote>
<p>Examples of identifiers are:</p>
<ul>
<li><code>String</code></li>
<li><code>i3</code></li>
<li>αρετη</li>
<li><code>MAX_VALUE</code></li>
<li><code>isLetterOrDigit</code></li>
</ul>
</blockquote>
<p><strong>The identifiers <code>var</code> and <code>record</code> are <em>restricted identifiers</em> because they are not allowed in some contexts.</strong></p>
<div class="editorial">
<p>In another JEP (<a href="http://cr.openjdk.java.net/~gbierman/jep361/jep361-20190927/specs/switch-expressions-jls.html">JEP 361: Switch Expressions</a>) targetting JDK14, it is proposed to additionally make the identifier <code>yield</code> a restricted identifier.</p>
</div>
<p>A <em>type identifier</em> is an identifier that is <del>not</del> <strong>neither</strong> the character sequence <code>var</code> <strong>nor the character sequence <code>record</code></strong>.</p>
<dl>
<dt><em>TypeIdentifier:</em></dt>
<dd><em>Identifier</em> <em>but not</em> <code>var</code> <strong>or <code>record</code></strong>
</dd>
</dl>
<blockquote>
<p>Type identifiers are used in certain contexts involving the declaration or use of types. For example, the name of a class must be a <em>TypeIdentifier</em>, so it is illegal to declare a class named <code>var</code> <strong>or <code>record</code></strong> (<a href="#jls-8.1">8.1</a>).</p>
</blockquote>
<h3 id="jls-3.9">3.9 Keywords</h3>
<p>51 character sequences, formed from ASCII letters, are reserved for use as keywords and cannot be used as identifiers (<a href="#jls-3.8">3.8</a>).</p>
<dl>
<dt><em>Keyword:</em></dt>
<dd>(one of)
</dd>
<dd><code>abstract continue for new switch</code><br />
<code>assert default if package synchronized</code><br />
<code>boolean do goto private this</code><br />
<code>break double implements protected throw</code><br />
<code>byte else import public throws</code><br />
<code>case enum instanceof return transient</code><br />
<code>catch extends int short try</code><br />
<code>char final interface static void</code><br />
<code>class finally long strictfp volatile</code><br />
<code>const float native super while</code><br />
<code>_</code> (underscore)
</dd>
</dl>
<blockquote>
<p>The keywords <code>const</code> and <code>goto</code> are reserved, even though they are not currently used. This may allow a Java compiler to produce better error messages if these C++ keywords incorrectly appear in programs.</p>
</blockquote>
<blockquote>
<p>A variety of character sequences are sometimes assumed, incorrectly, to be keywords:</p>
</blockquote>
<blockquote>
<ul>
<li><p><code>true</code> and <code>false</code> are not keywords, but rather boolean literals (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-3.html#jls-3.10.3">3.10.3</a>).</p></li>
<li><p><code>null</code> is not a keyword, but rather the null literal (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-3.html#jls-3.10.7">3.10.7</a>).</p></li>
<li><p><del><code>var</code> is not a keyword, but rather an identifier with</del> <strong>The restricted identifiers <code>var</code> and <code>record</code> are not keywords. <code>var</code> has</strong> special meaning as the type of a local variable declaration (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-14.html#jls-14.4">14.4</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-14.html#jls-14.14.1">14.14.1</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-14.html#jls-14.14.2">14.14.2</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-14.html#jls-14.20.3">14.20.3</a>) and the type of a lambda formal parameter (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.27.1">15.27.1</a>). <strong><code>record</code> has a special meaning in a record type declaration (<a href="#jls-8.10">8.10</a>).</strong></p></li>
</ul>
</blockquote>
<p>A further ten character sequences are <em>restricted keywords</em>: <code>open</code>, <code>module</code>, <code>requires</code>, <code>transitive</code>, <code>exports</code>, <code>opens</code>, <code>to</code>, <code>uses</code>, <code>provides</code>, and <code>with</code>. These character sequences are tokenized as keywords solely where they appear as terminals in the <em>ModuleDeclaration</em>, <em>ModuleDirective</em>, and <em>RequiresModifier</em> productions (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-7.html#jls-7.7">7.7</a>). They are tokenized as identifiers everywhere else, for compatibility with programs written before the introduction of restricted keywords. There is one exception: immediately to the right of the character sequence <code>requires</code> in the <em>ModuleDirective</em> production, the character sequence <code>transitive</code> is tokenized as a keyword unless it is followed by a separator, in which case it is tokenized as an identifier.</p>
<h2 id="jls-4">Chapter 4: Types, Values, and Variables</h2>
<h3 id="jls-4.11">4.11 Where Types Are Used</h3>
<p>Types are used in most kinds of declaration and in certain kinds of expression. Specifically, there are <del>16</del> <strong>17</strong> <em>type contexts</em> where types are used:</p>
<ul>
<li><p>In declarations:</p>
<ol type="1">
<li><p>A type in the <code>extends</code> or <code>implements</code> clause of a class declaration (<a href="#jls-8.1.4">8.1.4</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.1.5">8.1.5</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.5">8.5</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-9.html#jls-9.5">9.5</a>)</p></li>
<li><p>A type in the <code>extends</code> clause of an interface declaration (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-9.html#jls-9.1.3">9.1.3</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.5">8.5</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-9.html#jls-9.5">9.5</a>)</p></li>
<li><p>The return type of a method (including the type of an element of an annotation type) (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.4.5">8.4.5</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-9.html#jls-9.4">9.4</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-9.html#jls-9.6.1">9.6.1</a>)</p></li>
<li><p>A type in the <code>throws</code> clause of a method or constructor (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.4.6">8.4.6</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.8.5">8.8.5</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-9.html#jls-9.4">9.4</a>)</p></li>
<li><p>A type in the <code>extends</code> clause of a type parameter declaration of a generic class, interface, method, or constructor (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.1.2">8.1.2</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-9.html#jls-9.1.2">9.1.2</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.4.4">8.4.4</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.8.4">8.8.4</a>)</p></li>
<li><p>The type in a field declaration of a class or interface (including an enum constant) (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.3">8.3</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-9.html#jls-9.3">9.3</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.9.1">8.9.1</a>)</p></li>
<li><p>The type in a formal parameter declaration of a method, constructor, or lambda expression (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.4.1">8.4.1</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.8.1">8.8.1</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-9.html#jls-9.4">9.4</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.27.1">15.27.1</a>)</p></li>
<li><p>The type of the receiver parameter of a method (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.4">8.4</a>)</p></li>
<li><p>The type in a local variable declaration (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-14.html#jls-14.4">14.4</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-14.html#jls-14.14.1">14.14.1</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-14.html#jls-14.14.2">14.14.2</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-14.html#jls-14.20.3">14.20.3</a>)</p></li>
<li><p>The type in an exception parameter declaration (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-14.html#jls-14.20">14.20</a>)</p></li>
<li><p><strong>The type of a record component in a record type declaration (<a href="#jls-8.10.1">8.10.1</a>)</strong></p></li>
</ol></li>
<li><p>In expressions:</p>
<ol type="1">
<li><p>A type in the explicit type argument list to an explicit constructor invocation statement or class instance creation expression or method invocation expression (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.8.7.1">8.8.7.1</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.9">15.9</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.12">15.12</a>)</p></li>
<li><p>In an unqualified class instance creation expression, as the class type to be instantiated (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.9">15.9</a>) or as the direct superclass or direct superinterface of an anonymous class to be instantiated (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.9.5">15.9.5</a>)</p></li>
<li><p>The element type in an array creation expression (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.10.1">15.10.1</a>)</p></li>
<li><p>The type in the cast operator of a cast expression (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.16">15.16</a>)</p></li>
<li><p>The type that follows the <code>instanceof</code> relational operator (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.20.2">15.20.2</a>)</p></li>
<li><p>In a method reference expression (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.13">15.13</a>), as the reference type to search for a member method or as the class type or array type to construct.</p></li>
</ol></li>
</ul>
<p>Also, types are used as:</p>
<ul>
<li><p>The element type of an array type in any of the above contexts; and</p></li>
<li><p>A non-wildcard type argument, or a bound of a wildcard type argument, of a parameterized type in any of the above contexts.</p></li>
</ul>
<p>Finally, there are three special terms in the Java programming language which denote the use of a type:</p>
<ul>
<li><p>An unbounded wildcard (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-4.html#jls-4.5.1">4.5.1</a>)</p></li>
<li><p>The <code>...</code> in the type of a variable arity parameter (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.4.1">8.4.1</a>), to indicate an array type</p></li>
<li><p>The simple name of a type in a constructor declaration (<a href="#jls-8.8">8.8</a>), to indicate the class of the constructed object</p></li>
</ul>
<p>The meaning of types in type contexts is given by:</p>
<ul>
<li><p><a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-4.html#jls-4.2">4.2</a>, for primitive types</p></li>
<li><p><a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-4.html#jls-4.4">4.4</a>, for type parameters</p></li>
<li><p><a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-4.html#jls-4.5">4.5</a>, for class and interface types that are parameterized, or appear either as type arguments in a parameterized type or as bounds of wildcard type arguments in a parameterized type</p></li>
<li><p><a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-4.html#jls-4.8">4.8</a>, for class and interface types that are raw</p></li>
<li><p><a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-4.html#jls-4.9">4.9</a>, for intersection types in the bounds of type parameters</p></li>
<li><p><a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-6.html#jls-6.5">6.5</a>, for class and interface types in contexts where genericity is unimportant (<a href="#jls-6.1">6.1</a>)</p></li>
<li><p><a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-10.html#jls-10.1">10.1</a>, for array types</p></li>
</ul>
<p>Some type contexts restrict how a reference type may be parameterized:</p>
<ul>
<li><p>The following type contexts require that if a type is a parameterized reference type, it has no wildcard type arguments:</p>
<ul>
<li><p>In an <code>extends</code> or <code>implements</code> clause of a class declaration (<a href="#jls-8.1.4">8.1.4</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.1.5">8.1.5</a>)</p></li>
<li><p>In an <code>extends</code> clause of an interface declaration (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-9.html#jls-9.1.3">9.1.3</a>)</p></li>
<li><p>In an unqualified class instance creation expression, as the class type to be instantiated (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.9">15.9</a>) or as the direct superclass or direct superinterface of an anonymous class to be instantiated (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.9.5">15.9.5</a>)</p></li>
<li><p>In a method reference expression (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.13">15.13</a>), as the reference type to search for a member method or as the class type or array type to construct.</p></li>
</ul>
<p>In addition, no wildcard type arguments are permitted in the explicit type argument list to an explicit constructor invocation statement or class instance creation expression or method invocation expression or method reference expression (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.8.7.1">8.8.7.1</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.9">15.9</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.12">15.12</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.13">15.13</a>).</p></li>
<li><p>The following type contexts require that if a type is a parameterized reference type, it has only unbounded wildcard type arguments (i.e. it is a reifiable type) :</p>
<ul>
<li><p>As the element type in an array creation expression (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.10.1">15.10.1</a>)</p></li>
<li><p>As the type that follows the <code>instanceof</code> relational operator (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.20.2">15.20.2</a>)</p></li>
</ul></li>
<li><p>The following type contexts disallow a parameterized reference type altogether, because they involve exceptions and the type of an exception is non-generic (<a href="#jls-6.1">6.1</a>):</p>
<ul>
<li><p>As the type of an exception that can be thrown by a method or constructor (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.4.6">8.4.6</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.8.5">8.8.5</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-9.html#jls-9.4">9.4</a>)</p></li>
<li><p>In an exception parameter declaration (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-14.html#jls-14.20">14.20</a>)</p></li>
</ul></li>
</ul>
<blockquote>
<p>In any type context where a type is used, it is possible to annotate the keyword denoting a primitive type or the <em>Identifier</em> denoting the simple name of a reference type. It is also possible to annotate an array type by writing an annotation to the left of the <code>[</code> at the desired level of nesting in the array type. Annotations in these locations are called <em>type annotations</em>, and are specified in <a href="#jls-9.7.4">9.7.4</a>. Here are some examples:</p>
</blockquote>
<blockquote>
<ul>
<li><p><code>@Foo int[] f;</code> annotates the primitive type <code>int</code></p></li>
<li><p><code>int @Foo [] f;</code> annotates the array type <code>int[]</code></p></li>
<li><p><code>int @Foo [][] f;</code> annotates the array type <code>int[][]</code></p></li>
<li><p><code>int[] @Foo [] f;</code> annotates the array type <code>int[]</code> which is the component type of the array type <code>int[][]</code></p></li>
</ul>
</blockquote>
<blockquote>
<p><del>Five</del> <strong>Six</strong> of the <em>type contexts</em> which appear in declarations occupy the same syntactic real estate as a number of <em>declaration contexts</em> (<a href="#jls-9.6.4.1">9.6.4.1</a>):</p>
</blockquote>
<blockquote>
<ul>
<li><p>The return type of a method (including the type of an element of an annotation type)</p></li>
<li><p>The type in a field declaration of a class or interface (including an enum constant)</p></li>
<li><p><strong>The type in a record component declaration of a record type</strong></p></li>
<li><p>The type in a formal parameter declaration of a method, constructor, or lambda expression</p></li>
<li><p>The type in a local variable declaration</p></li>
<li><p>The type in an exception parameter declaration</p></li>
</ul>
</blockquote>
<blockquote>
<p>The fact that the same syntactic location in a program can be both a type context and a declaration context arises because the modifiers for a declaration immediately precede the type of the declared entity. <a href="#jls-9.7.4">9.7.4</a> explains how an annotation in such a location is deemed to appear in a type context or a declaration context or both.</p>
</blockquote>
<div class="example">
<p>Example 4.11-1. Usage of a Type</p>
<pre><code>import java.util.Random;
import java.util.Collection;
import java.util.ArrayList;

class MiscMath&lt;T extends Number&gt; {
    int divisor;
    MiscMath(int divisor) { this.divisor = divisor; }
    float ratio(long l) {
        try {
            l /= divisor;
        } catch (Exception e) {
            if (e instanceof ArithmeticException)
                l = Long.MAX_VALUE;
            else
                l = 0;
        }
        return (float)l;
    }
    double gausser() {
        Random r = new Random();
        double[] val = new double[2];
        val[0] = r.nextGaussian();
        val[1] = r.nextGaussian();
        return (val[0] + val[1]) / 2;
    }
    Collection&lt;Number&gt; fromArray(Number[] na) {
        Collection&lt;Number&gt; cn = new ArrayList&lt;Number&gt;();
        for (Number n : na) cn.add(n);
        return cn;
    }
    &lt;S&gt; void loop(S s) { this.&lt;S&gt;loop(s); }  
}</code></pre>
<p>In this example, types are used in declarations of the following:</p>
<ul>
<li><p>Imported types (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-7.html#jls-7.5">7.5</a>); here the type <code>Random</code>, imported from the type <code>java.util.Random</code> of the package <code>java.util</code>, is declared</p></li>
<li><p>Fields, which are the class variables and instance variables of classes (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.3">8.3</a>), and constants of interfaces (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-9.html#jls-9.3">9.3</a>); here the field <code>divisor</code> in the class <code>MiscMath</code> is declared to be of type <code>int</code></p></li>
<li><p>Method parameters (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.4.1">8.4.1</a>); here the parameter <code>l</code> of the method <code>ratio</code> is declared to be of type <code>long</code></p></li>
<li><p>Method results (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.4">8.4</a>); here the result of the method <code>ratio</code> is declared to be of type <code>float</code>, and the result of the method <code>gausser</code> is declared to be of type <code>double</code></p></li>
<li><p>Constructor parameters (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.8.1">8.8.1</a>); here the parameter of the constructor for <code>MiscMath</code> is declared to be of type <code>int</code></p></li>
<li><p>Local variables (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-14.html#jls-14.4">14.4</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-14.html#jls-14.14">14.14</a>); the local variables <code>r</code> and <code>val</code> of the method <code>gausser</code> are declared to be of types <code>Random</code> and <code>double[]</code> (array of <code>double</code>)</p></li>
<li><p>Exception parameters (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-14.html#jls-14.20">14.20</a>); here the exception parameter <code>e</code> of the <code>catch</code> clause is declared to be of type <code>Exception</code></p></li>
<li><p>Type parameters (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-4.html#jls-4.4">4.4</a>); here the type parameter of <code>MiscMath</code> is a type variable <code>T</code> with the type <code>Number</code> as its declared bound</p></li>
<li><p>In any declaration that uses a parameterized type; here the type <code>Number</code> is used as a type argument (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-4.html#jls-4.5.1">4.5.1</a>) in the parameterized type <code>Collection&lt;Number&gt;</code>.</p></li>
</ul>
<p>and in expressions of the following kinds:</p>
<ul>
<li><p>Class instance creations (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.9">15.9</a>); here a local variable <code>r</code> of method <code>gausser</code> is initialized by a class instance creation expression that uses the type <code>Random</code></p></li>
<li><p>Generic class (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.1.2">8.1.2</a>) instance creations (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.9">15.9</a>); here <code>Number</code> is used as a type argument in the expression <code>new ArrayList&lt;Number&gt;()</code></p></li>
<li><p>Array creations (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.10.1">15.10.1</a>); here the local variable <code>val</code> of method <code>gausser</code> is initialized by an array creation expression that creates an array of <code>double</code> with size 2</p></li>
<li><p>Generic method (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.4.4">8.4.4</a>) or constructor (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.8.4">8.8.4</a>) invocations (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.12">15.12</a>); here the method <code>loop</code> calls itself with an explicit type argument <code>S</code></p></li>
<li><p>Casts (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.16">15.16</a>); here the <code>return</code> statement of the method <code>ratio</code> uses the <code>float</code> type in a cast</p></li>
<li><p>The <code>instanceof</code> operator (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.20.2">15.20.2</a>); here the <code>instanceof</code> operator tests whether <code>e</code> is assignment-compatible with the type <code>ArithmeticException</code></p></li>
</ul>
</div>
<h3 id="jls-4.12">4.12 Variables</h3>
<h4 id="jls-4.12.3">4.12.3 Kinds of Variables</h4>
<p>There are eight kinds of variables:</p>
<ol type="1">
<li><p>A <em>class variable</em> is a field declared using the keyword <code>static</code> within a class declaration (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.3.1.1">8.3.1.1</a>), or with or without the keyword <code>static</code> within an interface declaration (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-9.html#jls-9.3">9.3</a>).</p>
<p>A class variable is created when its class or interface is prepared (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-12.html#jls-12.3.2">12.3.2</a>) and is initialized to a default value (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-4.html#jls-4.12.">4.12.5</a>). The class variable effectively ceases to exist when its class or interface is unloaded (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-12.html#jls-12.7">12.7</a>).</p></li>
<li><p>An <em>instance variable</em> is a field declared <strong>explicitly or implicitly</strong> within a class declaration without using the keyword <code>static</code> (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.3.1.1">8.3.1.1</a>).</p>
<p>If a class <em>T</em> has a field <code>a</code> that is an instance variable, then a new instance variable <code>a</code> is created and initialized to a default value (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-4.html#jls-4.12.">4.12.5</a>) as part of each newly created object of class <em>T</em> or of any class that is a subclass of <em>T</em> (<a href="#jls-8.1.4">8.1.4</a>). The instance variable effectively ceases to exist when the object of which it is a field is no longer referenced, after any necessary finalization of the object (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-12.html#jls-12.6">12.6</a>) has been completed.</p></li>
<li><p><em>Array components</em> are unnamed variables that are created and initialized to default values (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-4.html#jls-4.12.">4.12.5</a>) whenever a new object that is an array is created (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-10.html">10</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.10.2">15.10.2</a>). The array components effectively cease to exist when the array is no longer referenced.</p></li>
<li><p><em>Method parameters</em> (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.4.1">8.4.1</a>) name argument values passed to a method.</p>
<p>For every parameter declared in a method declaration, a new parameter variable is created each time that method is invoked (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.12">15.12</a>). The new variable is initialized with the corresponding argument value from the method invocation. The method parameter effectively ceases to exist when the execution of the body of the method is complete.</p></li>
<li><p><em>Constructor parameters</em> (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.8.1">8.8.1</a>) name argument values passed to a constructor.</p>
<p>For every parameter declared in a constructor declaration, a new parameter variable is created each time a class instance creation expression (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.9">15.9</a>) or explicit constructor invocation (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.8.7">8.8.7</a>) invokes that constructor. The new variable is initialized with the corresponding argument value from the creation expression or constructor invocation. The constructor parameter effectively ceases to exist when the execution of the body of the constructor is complete.</p></li>
<li><p><em>Lambda parameters</em> (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.27.1">15.27.1</a>) name argument values passed to a lambda expression body (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.27.2">15.27.2</a>).</p>
<p>For every parameter declared in a lambda expression, a new parameter variable is created each time a method implemented by the lambda body is invoked (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.12">15.12</a>). The new variable is initialized with the corresponding argument value from the method invocation. The lambda parameter effectively ceases to exist when the execution of the lambda expression body is complete.</p></li>
<li><p>An <em>exception parameter</em> is created each time an exception is caught by a <code>catch</code> clause of a <code>try</code> statement (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-14.html#jls-14.20">14.20</a>).</p>
<p>The new variable is initialized with the actual object associated with the exception (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-11.html#jls-11.3">11.3</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-14.html#jls-14.18">14.18</a>). The exception parameter effectively ceases to exist when execution of the block associated with the <code>catch</code> clause is complete.</p></li>
<li><p><em>Local variables</em> are declared by local variable declaration statements (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-14.html#jls-14.4">14.4</a>).</p>
<p>Whenever the flow of control enters a block (<a href="#jls-14.2">14.2</a>) or <code>for</code> statement (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-14.html#jls-14.14">14.14</a>), a new variable is created for each local variable declared in a local variable declaration statement immediately contained within that block or <code>for</code> statement.</p>
<p>A local variable declaration statement may contain an expression which initializes the variable. The local variable with an initializing expression is not initialized, however, until the local variable declaration statement that declares it is executed. (The rules of definite assignment (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-16.html">16</a>) prevent the value of a local variable from being used before it has been initialized or otherwise assigned a value.) The local variable effectively ceases to exist when the execution of the block or for statement is complete.</p>
<blockquote>
<p>Were it not for one exceptional situation, a local variable could always be regarded as being created when its local variable declaration statement is executed. The exceptional situation involves the <code>switch</code> statement (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-14.html#jls-14.11">14.11</a>), where it is possible for control to enter a block but bypass execution of a local variable declaration statement. Because of the restrictions imposed by the rules of definite assignment (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-16.html">16</a>), however, the local variable declared by such a bypassed local variable declaration statement cannot be used before it has been definitely assigned a value by an assignment expression (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.26">15.26</a>).</p>
</blockquote></li>
</ol>
<div class="example">
<p>Example 4.12.3-1. Different Kinds of Variables</p>
<pre><code>class Point {
    static int numPoints;   // numPoints is a class variable
    int x, y;               // x and y are instance variables
    int[] w = new int[10];  // w[0] is an array component
    int setX(int x) {       // x is a method parameter
        int oldx = this.x;  // oldx is a local variable
        this.x = x;
        return oldx;
    }
}</code></pre>
</div>
<h4 id="jls-4.12.4">4.12.4 <code>final</code> Variables</h4>
<p>A variable can be declared <code>final</code>. A <code>final</code> variable may only be assigned to once. It is a compile-time error if a <code>final</code> variable is assigned to unless it is definitely unassigned immediately prior to the assignment (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-16.html">16</a>).</p>
<p>Once a <code>final</code> variable has been assigned, it always contains the same value. If a <code>final</code> variable holds a reference to an object, then the state of the object may be changed by operations on the object, but the variable will always refer to the same object. This applies also to arrays, because arrays are objects; if a <code>final</code> variable holds a reference to an array, then the components of the array may be changed by operations on the array, but the variable will always refer to the same array.</p>
<p>A <em>blank <code>final</code></em> is a <code>final</code> variable whose declaration lacks an initializer.</p>
<p>A <em>constant variable</em> is a <code>final</code> variable of primitive type or type <code>String</code> that is initialized with a constant expression (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.28">15.28</a>). Whether a variable is a constant variable or not may have implications with respect to class initialization (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-12.html#jls-12.4.1">12.4.1</a>), binary compatibility (<a href="#jls-13.1">13.1</a>), reachability (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-14.html#jls-14.21">14.21</a>), and definite assignment (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-16.html#jls-16.1.1">16.1.1</a>).</p>
<p><del>Three</del> <strong>Four</strong> kinds of variable are implicitly declared <code>final</code>: a field of an interface (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-9.html#jls-9.3">9.3</a>), a local variable declared as a resource of a <code>try</code>-with-resources statement (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-14.html#jls-14.20.3">14.20.3</a>), <del>and</del> an exception parameter of a multi-<code>catch</code> clause (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-14.html#jls-14.20">14.20</a>)<strong>, and the field corresponding to a record component (<a href="#jls-8.10.1">8.10.1</a>)</strong>. An exception parameter of a uni-<code>catch</code> clause is never implicitly declared <code>final</code>, but may be effectively final.</p>
<div class="example">
<p>Example 4.12.4-1. Final Variables</p>
<p>Declaring a variable <code>final</code> can serve as useful documentation that its value will not change and can help avoid programming errors. In this program:</p>
<pre><code>class Point {
    int x, y;
    int useCount;
    Point(int x, int y) { this.x = x; this.y = y; }
    static final Point origin = new Point(0, 0);
}</code></pre>
<p>the class <code>Point</code> declares a <code>final</code> class variable <code>origin</code>. The <code>origin</code> variable holds a reference to an object that is an instance of class <code>Point</code> whose coordinates are (0, 0). The value of the variable <code>Point.origin</code> can never change, so it always refers to the same <code>Point</code> object, the one created by its initializer. However, an operation on this <code>Point</code> object might change its state - for example, modifying its <code>useCount</code> or even, misleadingly, its <code>x</code> or <code>y</code> coordinate.</p>
</div>
<p>Certain variables that are not declared <code>final</code> are instead considered <em>effectively final</em>:</p>
<ul>
<li><p>A local variable whose declarator has an initializer (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-14.html#jls-14.4.2">14.4.2</a>) is <em>effectively final</em> if all of the following are true:</p>
<ul>
<li><p>It is not declared <code>final</code>.</p></li>
<li><p>It never occurs as the left hand side in an assignment expression (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.26">15.26</a>). (Note that the local variable declarator containing the initializer is <em>not</em> an assignment expression.)</p></li>
<li><p>It never occurs as the operand of a prefix or postfix increment or decrement operator (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.14">15.14</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.15">15.15</a>).</p></li>
</ul></li>
<li><p>A local variable whose declarator lacks an initializer is <em>effectively final</em> if all of the following are true:</p>
<ul>
<li><p>It is not declared <code>final</code>.</p></li>
<li><p>Whenever it occurs as the left hand side in an assignment expression, it is definitely unassigned and not definitely assigned before the assignment; that is, it is definitely unassigned and not definitely assigned after the right hand side of the assignment expression (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-16.html">16</a>).</p></li>
<li><p>It never occurs as the operand of a prefix or postfix increment or decrement operator.</p></li>
</ul></li>
<li><p>A method, constructor, lambda, or exception parameter (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.4.1">8.4.1</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.8.1">8.8.1</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-9.html#jls-9.4">9.4</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.27.1">15.27.1</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-14.html#jls-14.20">14.20</a>) is treated, for the purpose of determining whether it is <em>effectively final</em>, as a local variable whose declarator has an initializer.</p></li>
</ul>
<p>If a variable is effectively final, adding the <code>final</code> modifier to its declaration will not introduce any compile-time errors. Conversely, a local variable or parameter that is declared <code>final</code> in a valid program becomes effectively final if the <code>final</code> modifier is removed.</p>
<h2 id="jls-6">Chapter 6: Names</h2>
<p>Names are used to refer to entities declared in a program.</p>
<p>A declared entity (<a href="#jls-6.1">6.1</a>) is a package, class type (normal<strong>,</strong> <del>or</del> enum<strong>, or record</strong>), interface type (normal or annotation type), member (class, interface, field, or method) of a reference type, type parameter (of a class, interface, method or constructor), parameter (to a method, constructor, or exception handler), or local variable.</p>
<p>Names in programs are either <em>simple</em>, consisting of a single identifier, or <em>qualified</em>, consisting of a sequence of identifiers separated by &quot;<code>.</code>&quot; tokens (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-6.html#jls-6.2">6.2</a>).</p>
<p>Every declaration that introduces a name has a <em>scope</em> (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-6.html#jls-6.3">6.3</a>), which is the part of the program text within which the declared entity can be referred to by a simple name.</p>
<p>A qualified name <em>N.x</em> may be used to refer to a <em>member</em> of a package or reference type, where <em>N</em> is a simple or qualified name and <em>x</em> is an identifier. If <em>N</em> names a package, then <em>x</em> is a member of that package, which is either a class or interface type or a subpackage. If <em>N</em> names a reference type or a variable of a reference type, then <em>x</em> names a member of that type, which is either a class, an interface, a field, or a method.</p>
<p>In determining the meaning of a name (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-6.html#jls-6.5">6.5</a>), the context of the occurrence is used to disambiguate among packages, types, variables, and methods with the same name.</p>
<p>Access control (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-6.html#jls-6.6">6.6</a>) can be specified in a class, interface, method, or field declaration to control when <em>access</em> to a member is allowed. Access is a different concept from scope. Access specifies the part of the program text within which the declared entity can be referred to by a qualified name. Access to a declared entity is also relevant in a field access expression (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.11">15.11</a>), a method invocation expression in which the method is not specified by a simple name (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.12">15.12</a>), a method reference expression (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.13">15.13</a>), or a qualified class instance creation expression (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.9">15.9</a>). In the absence of an access modifier, most declarations have package access, allowing access anywhere within the package that contains its declaration; other possibilities are <code>public</code>, <code>protected</code>, and <code>private</code>.</p>
<p>Fully qualified and canonical names (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-6.html#jls-6.7">6.7</a>) are also discussed in this chapter.</p>
<h3 id="jls-6.1">6.1 Declarations</h3>
<p>A <em>declaration</em> introduces an entity into a program and includes an identifier (<a href="#jls-3.8">3.8</a>) that can be used in a name to refer to this entity. The identifier is constrained to be a type identifier when the entity being introduced is a class, interface, or type parameter.</p>
<p>A declared entity is one of the following:</p>
<ul>
<li><p>A module, declared in a <code>module</code> declaration (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-7.html#jls-7.7">7.7</a>)</p></li>
<li><p>A package, declared in a <code>package</code> declaration (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-7.html#jls-7.4">7.4</a>)</p></li>
<li><p>An imported type, declared in a single-type-import declaration or a type-import-on-demand declaration (<a href="#jls-7.5.1">7.5.1</a>, <a href="#jls-7.5.2">7.5.2</a>)</p></li>
<li><p>An imported <code>static</code> member, declared in a single-static-import declaration or a static-import-on-demand declaration (<a href="#jls-7.5.3">7.5.3</a>, <a href="#jls-7.5.4">7.5.4</a>)</p></li>
<li><p>A class, declared in a class type declaration (<a href="#jls-8.1">8.1</a>)</p></li>
<li><p>An interface, declared in an interface type declaration (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-9.html#jls-9.1">9.1</a>)</p></li>
<li><p>A type parameter, declared as part of the declaration of a generic class, interface, method, or constructor (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.1.2">8.1.2</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-9.html#jls-9.1.2">9.1.2</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.4.4">8.4.4</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.8.4">8.8.4</a>)</p></li>
<li><p>A member of a reference type (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.2">8.2</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-9.html#jls-9.2">9.2</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.9.3">8.9.3</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-9.html#jls-9.6">9.6</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-10.html#jls-10.7">10.7</a>), one of the following:</p>
<ul>
<li><p>A member class (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.5">8.5</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-9.html#jls-9.5">9.5</a>)</p></li>
<li><p>A member interface (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.5">8.5</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-9.html#jls-9.5">9.5</a>)</p></li>
<li><p>An enum constant (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.9">8.9</a>)</p></li>
<li><p>A field, one of the following:</p>
<ul>
<li><p>A field declared in a class type or enum type (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.3">8.3</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.9.2">8.9.2</a>)</p></li>
<li><p>A field declared in an interface type or annotation type (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-9.html#jls-9.3">9.3</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-9.html#jls-9.6.1">9.6.1</a>)</p></li>
<li><p><strong>A field corresponding to a record component declared in a record type (<a href="#jls-8.10.3">8.10.3</a>)</strong></p></li>
<li><p>The field <code>length</code>, which is implicitly a member of every array type (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-10.html#jls-10.7">10.7</a>)</p></li>
</ul></li>
<li><p>A method, one of the following:</p>
<ul>
<li><p>A method (<code>abstract</code> or otherwise) declared in a class type<strong>,</strong> <del>or</del> enum type<strong>, or record type</strong> (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.4">8.4</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.9.2">8.9.2</a><strong>, <a href="#jls-8.10.3">8.10.3</a></strong>)</p></li>
<li><p>A method (<code>abstract</code> or otherwise) declared in an interface type or annotation type (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-9.html#jls-9.4">9.4</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-9.html#jls-9.6.1">9.6.1</a>)</p></li>
</ul></li>
</ul></li>
<li><p>A parameter, one of the following:</p>
<ul>
<li><p>A formal parameter of a method or constructor of a class type<strong>,</strong> <del>or</del> enum type<strong>, or record type</strong> (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.4.1">8.4.1</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.8.1">8.8.1</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.9.2">8.9.2</a><strong>, <a href="#jls-8.10.3">8.10.3</a></strong>), or of a lambda expression (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.27.1">15.27.1</a>)</p></li>
<li><p>A formal parameter of an <code>abstract</code> method of an interface type or annotation type (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-9.html#jls-9.4">9.4</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-9.html#jls-9.6.1">9.6.1</a>)</p></li>
<li><p>An exception parameter of an exception handler declared in a <code>catch</code> clause of a <code>try</code> statement (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-14.html#jls-14.20">14.20</a>)</p></li>
</ul></li>
<li><p>A local variable, one of the following:</p>
<ul>
<li><p>A local variable declared in a block (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-14.html#jls-14.4">14.4</a>)</p></li>
<li><p>A local variable declared in a <code>for</code> statement (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-14.html#jls-14.14">14.14</a>)</p></li>
</ul></li>
</ul>
<p>Constructors (<a href="#jls-8.8">8.8</a>) are also introduced by declarations, but use the name of the class in which they are declared rather than introducing a new name.</p>
<p>The declaration of a type which is not generic (<code>class C ...</code>) declares one entity: a non-generic type (<code>C</code>). A non-generic type is not a raw type, despite the syntactic similarity. In contrast, the declaration of a generic type (<code>class C&lt;T&gt; ...</code> or <code>interface C&lt;T&gt; ...</code>) declares two entities: a generic type (<code>C&lt;T&gt;</code>) and a corresponding non-generic type (<code>C</code>). In this case, the meaning of the term <code>C</code> depends on the context where it appears:</p>
<ul>
<li><p>If genericity is unimportant, as in the <em>non-generic contexts</em> identified below, the identifier <code>C</code> denotes the non-generic type <code>C</code>.</p></li>
<li><p>If genericity is important, as in all contexts from <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-6.html#jls-6.5">6.5</a> except the non-generic contexts, the identifier <code>C</code> denotes either:</p>
<ul>
<li><p>The raw type <code>C</code> which is the erasure (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-4.html#jls-4.6">4.6</a>) of the generic type <code>C&lt;T&gt;</code>; or</p></li>
<li><p>A parameterized type which is a particular parameterization (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-4.html#jls-4.5">4.5</a>) of the generic type <code>C&lt;T&gt;</code>.</p></li>
</ul></li>
</ul>
<p>The 14 non-generic contexts are as follows:</p>
<ol type="1">
<li><p>In a <code>uses</code> or <code>provides</code> directive in a module declaration (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-7.html#jls-7.7.">7.7.1</a>)</p></li>
<li><p>In a single-type-import declaration (<a href="#jls-7.5.1">7.5.1</a>)</p></li>
<li><p>To the left of the <code>.</code> in a single-static-import declaration (<a href="#jls-7.5.3">7.5.3</a>)</p></li>
<li><p>To the left of the <code>.</code> in a static-import-on-demand declaration (<a href="#jls-7.5.4">7.5.4</a>)</p></li>
<li><p>To the left of the <code>(</code> in a constructor declaration (<a href="#jls-8.8">8.8</a>)</p></li>
<li><p>After the <code>@</code> sign in an annotation (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-9.html#jls-9.7">9.7</a>)</p></li>
<li><p>To the left of <code>.class</code> in a class literal (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.8.2">15.8.2</a>)</p></li>
<li><p>To the left of <code>.this</code> in a qualified <code>this</code> expression (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.8.4">15.8.4</a>)</p></li>
<li><p>To the left of <code>.super</code> in a qualified superclass field access expression (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.11.2">15.11.2</a>)</p></li>
<li><p>To the left of <code>.</code><em>Identifier</em> or <code>.super.</code><em>Identifier</em> in a qualified method invocation expression (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.12">15.12</a>)</p></li>
<li><p>To the left of <code>.super::</code> in a method reference expression (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.13">15.13</a>)</p></li>
<li><p>In a qualified expression name in a postfix expression or a <code>try</code>-with-resources statement (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.14.1">15.14.1</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-14.html#jls-14.20.3">14.20.3</a>)</p></li>
<li><p>In a <code>throws</code> clause of a method or constructor (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.4.6">8.4.6</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.8.5">8.8.5</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-9.html#jls-9.4">9.4</a>)</p></li>
<li><p>In an exception parameter declaration (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-14.html#jls-14.20">14.20</a>)</p></li>
</ol>
<p>The first eleven non-generic contexts correspond to the first eleven syntactic contexts for a <em>TypeName</em> in <a href="#jls-6.5.1">6.5.1</a>. The twelfth non-generic context is where a qualified <em>ExpressionName</em> such as <code>C.x</code> may include a <em>TypeName</em> <code>C</code> to denote static member access. The common use of <em>TypeName</em> in these twelve contexts is significant: it indicates that these contexts involve a less-than-first-class use of a type. In contrast, the thirteenth and fourteenth non-generic contexts employ <em>ClassType</em>, indicating that <code>throws</code> and <code>catch</code> clauses use types in a first-class way, in line with, say, field declarations. The characterization of these two contexts as non-generic is due to the fact that an exception type cannot be parameterized.</p>
<blockquote>
<p>Note that the <em>ClassType</em> production allows annotations, so it is possible to annotate the use of a type in a <code>throws</code> or <code>catch</code> clause, whereas the <em>TypeName</em> production disallows annotations, so it is not possible to annotate the name of a type in, say, a single-type-import declaration.</p>
</blockquote>
<blockquote>
<p><em>Naming Conventions</em></p>
</blockquote>
<blockquote>
<p>The class libraries of the Java SE Platform attempt to use, whenever possible, names chosen according to the conventions presented below. These conventions help to make code more readable and avoid certain kinds of name conflicts.</p>
</blockquote>
<blockquote>
<p>We recommend these conventions for use in all programs written in the Java programming language. However, these conventions should not be followed slavishly if long-held conventional usage dictates otherwise. So, for example, the <code>sin</code> and <code>cos</code> methods of the class <code>java.lang.Math</code> have mathematically conventional names, even though these method names flout the convention suggested here because they are short and are not verbs.</p>
</blockquote>
<blockquote>
<p><em>Package Names and Module Names</em></p>
</blockquote>
<blockquote>
<p>Developers should take steps to avoid the possibility of two published packages having the same name by choosing <em>unique package names</em> for packages that are widely distributed. This allows packages to be easily and automatically installed and catalogued. This section specifies a suggested convention for generating such unique package names. Implementations of the Java SE Platform are encouraged to provide automatic support for converting a set of packages from local and casual package names to the unique name format described here.</p>
</blockquote>
<blockquote>
<p>If unique package names are not used, then package name conflicts may arise far from the point of creation of either of the conflicting packages. This may create a situation that is difficult or impossible for the user or programmer to resolve. The classes <code>ClassLoader</code> and <code>ModuleLayer</code> can be used to isolate packages with the same name from each other in those cases where the packages will have constrained interactions, but not in a way that is transparent to a naïve program.</p>
</blockquote>
<blockquote>
<p>You form a unique package name by first having (or belonging to an organization that has) an Internet domain name, such as <code>oracle.com</code>. You then reverse this name, component by component, to obtain, in this example, <code>com.oracle</code>, and use this as a prefix for your package names, using a convention developed within your organization to further administer package names. Such a convention might specify that certain package name components be division, department, project, machine, or login names.</p>
</blockquote>
<div class="example">
<p>Example 6.1-1. Unique Package Names</p>
<pre><code>com.nighthacks.scrabble.dictionary
org.openjdk.compiler.source.tree
net.jcip.annotations
edu.cmu.cs.bovik.cheese
gov.whitehouse.socks.mousefinder</code></pre>
</div>
<blockquote>
<p>The first component of a unique package name is always written in all-lowercase ASCII letters and should be one of the top level domain names, such as <code>com</code>, <code>edu</code>, <code>gov</code>, <code>mil</code>, <code>net</code>, or <code>org</code>, or one of the English two-letter codes identifying countries as specified in <em>ISO Standard 3166</em>.</p>
</blockquote>
<blockquote>
<p>In some cases, the Internet domain name may not be a valid package name. Here are some suggested conventions for dealing with these situations:</p>
</blockquote>
<blockquote>
<ul>
<li><p>If the domain name contains a hyphen, or any other special character not allowed in an identifier (<a href="#jls-3.8">3.8</a>), convert it into an underscore.</p></li>
<li><p>If any of the resulting package name components are keywords (<a href="#jls-3.9">3.9</a>), append an underscore to them.</p></li>
<li><p>If any of the resulting package name components start with a digit, or any other character that is not allowed as an initial character of an identifier, have an underscore prefixed to the component.</p></li>
</ul>
</blockquote>
<blockquote>
<p>The name of a module should correspond to the name of its principal exported package. If a module does not have such a package, or if for legacy reasons it must have a name that does not correspond to one of its exported packages, then its name should still start with the reversed form of an Internet domain with which its author is associated.</p>
</blockquote>
<div class="example">
<p>Example 6.1-2. Unique Module Names</p>
<pre><code>com.nighthacks.scrabble
org.openjdk.compiler
net.jcip.annotations</code></pre>
</div>
<blockquote>
<p>The first component of a package or module name must not be the identifier <code>java</code>. Package and module names that start with the identifier <code>java</code> are reserved for packages and modules of the Java SE Platform.</p>
</blockquote>
<blockquote>
<p>The name of a package or module is not meant to imply where the package or module is stored on the Internet. For example, a package named <code>edu.cmu.cs.bovik.cheese</code> is not necessarily obtainable from the host <code>cmu.edu</code> or <code>cs.cmu.edu</code> or <code>bovik.cs.cmu.edu</code>. The suggested convention for generating unique package and module names is merely a way to piggyback a package and module naming convention on top of an existing, widely known unique name registry instead of having to create a separate registry for package and module names.</p>
</blockquote>
<blockquote>
<p><em>Class and Interface Type Names</em></p>
</blockquote>
<blockquote>
<p>Names of class types should be descriptive nouns or noun phrases, not overly long, in mixed case with the first letter of each word capitalized.</p>
</blockquote>
<div class="example">
<p>Example 6.1-3. Descriptive Class Names</p>
<pre><code>`ClassLoader`
SecurityManager
`Thread`
Dictionary
BufferedInputStream</code></pre>
</div>
<blockquote>
<p>Likewise, names of interface types should be short and descriptive, not overly long, in mixed case with the first letter of each word capitalized. The name may be a descriptive noun or noun phrase, which is appropriate when an interface is used as if it were an abstract superclass, such as interfaces <code>java.io.DataInput</code> and <code>java.io.DataOutput</code>; or it may be an adjective describing a behavior, as for the interfaces <code>Runnable</code> and <code>Cloneable</code>.</p>
</blockquote>
<blockquote>
<p><em>Type Variable Names</em></p>
</blockquote>
<blockquote>
<p>Type variable names should be pithy (single character if possible) yet evocative, and should not include lower case letters. This makes it easy to distinguish type parameters from ordinary classes and interfaces.</p>
</blockquote>
<blockquote>
<p>Container types should use the name <code>E</code> for their element type. Maps should use <code>K</code> for the type of their keys and <code>V</code> for the type of their values. The name <code>X</code> should be used for arbitrary exception types. We use <code>T</code> for type, whenever there is not anything more specific about the type to distinguish it. (This is often the case in generic methods.)</p>
</blockquote>
<blockquote>
<p>If there are multiple type parameters that denote arbitrary types, one should use letters that neighbor <code>T</code> in the alphabet, such as <code>S</code>. Alternately, it is acceptable to use numeric subscripts (e.g., <code>T1</code>, <code>T2</code>) to distinguish among the different type variables. In such cases, all the variables with the same prefix should be subscripted.</p>
</blockquote>
<blockquote>
<p>If a generic method appears inside a generic class, it is a good idea to avoid using the same names for the type parameters of the method and class, to avoid confusion. The same applies to nested generic classes.</p>
</blockquote>
<div class="example">
<p>Example 6.1-4. Conventional Type Variable Names</p>
<pre><code>public class HashSet&lt;E&gt; extends AbstractSet&lt;E&gt; { ... }
public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; { ... }
public class ThreadLocal&lt;T&gt; { ... }
public interface Functor&lt;T, X extends Throwable&gt; {
    T eval() throws X;
}</code></pre>
</div>
<blockquote>
<p>When type parameters do not fall conveniently into one of the categories mentioned, names should be chosen to be as meaningful as possible within the confines of a single letter. The names mentioned above (<code>E</code>, <code>K</code>, <code>V</code>, <code>X</code>, <code>T</code>) should not be used for type parameters that do not fall into the designated categories.</p>
</blockquote>
<blockquote>
<p><em>Method Names</em></p>
</blockquote>
<blockquote>
<p>Method names should be verbs or verb phrases, in mixed case, with the first letter lowercase and the first letter of any subsequent words capitalized. Here are some additional specific conventions for method names:</p>
</blockquote>
<blockquote>
<ul>
<li><p>Methods to get and set an attribute that might be thought of as a variable <em>V</em> should be named <code>get*V*</code> and <code>set*V*</code>. An example is the methods <code>getPriority</code> and <code>setPriority</code> of class <code>Thread</code>.</p></li>
<li><p>A method that returns the length of something should be named <code>length</code>, as in class <code>String</code>.</p></li>
<li><p>A method that tests a boolean condition <em>V</em> about an object should be named <code>is*V*</code>. An example is the method <code>isInterrupted</code> of class <code>Thread</code>.</p></li>
<li><p>A method that converts its object to a particular format <em>F</em> should be named <code>to*F*</code>. Examples are the method <code>toString</code> of class <code>Object</code> and the methods <code>toLocaleString</code> and <code>toGMTString</code> of class <code>java.util.Date</code>.</p></li>
</ul>
</blockquote>
<blockquote>
<p>Whenever possible and appropriate, basing the names of methods in a new class on names in an existing class that is similar, especially a class from the Java SE Platform API, will make it easier to use.</p>
</blockquote>
<blockquote>
<p><em>Field Names</em></p>
</blockquote>
<blockquote>
<p>Names of fields that are not <code>final</code> should be in mixed case with a lowercase first letter and the first letters of subsequent words capitalized. Note that well-designed classes have very few <code>public</code> or <code>protected</code> fields, except for fields that are constants (<code>static</code> <code>final</code> fields).</p>
</blockquote>
<blockquote>
<p>Fields should have names that are nouns, noun phrases, or abbreviations for nouns.</p>
</blockquote>
<blockquote>
<p>Examples of this convention are the fields <code>buf</code>, <code>pos</code>, and <code>count</code> of the class <code>java.io.ByteArrayInputStream</code> and the field <code>bytesTransferred</code> of the class <code>java.io.InterruptedIOException</code>.</p>
</blockquote>
<blockquote>
<p><em>Constant Names</em></p>
</blockquote>
<blockquote>
<p>The names of constants in interface types should be, and <code>final</code> variables of class types may conventionally be, a sequence of one or more words, acronyms, or abbreviations, all uppercase, with components separated by underscore &quot;<code>_</code>&quot; characters. Constant names should be descriptive and not unnecessarily abbreviated. Conventionally they may be any appropriate part of speech.</p>
</blockquote>
<blockquote>
<p>Examples of names for constants include <code>MIN_VALUE</code>, <code>MAX_VALUE</code>, <code>MIN_RADIX</code>, and <code>MAX_RADIX</code> of the class <code>Character</code>.</p>
</blockquote>
<blockquote>
<p>A group of constants that represent alternative values of a set, or, less frequently, masking bits in an integer value, are sometimes usefully specified with a common acronym as a name prefix.</p>
</blockquote>
<blockquote>
<p>For example:</p>
<pre><code>interface ProcessStates {
    int PS_RUNNING   = 0;
    int PS_SUSPENDED = 1;
}</code></pre>
</blockquote>
<blockquote>
<p><em>Local Variable and Parameter Names</em></p>
</blockquote>
<blockquote>
<p>Local variable and parameter names should be short, yet meaningful. They are often short sequences of lowercase letters that are not words, such as:</p>
</blockquote>
<blockquote>
<ul>
<li><p>Acronyms, that is the first letter of a series of words, as in <code>cp</code> for a variable holding a reference to a <code>ColoredPoint</code></p></li>
<li><p>Abbreviations, as in <code>buf</code> holding a pointer to a buffer of some kind</p></li>
<li><p>Mnemonic terms, organized in some way to aid memory and understanding, typically by using a set of local variables with conventional names patterned after the names of parameters to widely used classes. For example:</p>
<ul>
<li><p><code>in</code> and <code>out</code>, whenever some kind of input and output are involved, patterned after the fields of <code>System</code></p></li>
<li><p><code>off</code> and <code>len</code>, whenever an offset and length are involved, patterned after the parameters to the <code>read</code> and <code>write</code> methods of the interfaces <code>DataInput</code> and <code>DataOutput</code> of <code>java.io</code></p></li>
</ul></li>
</ul>
</blockquote>
<blockquote>
<p>One-character local variable or parameter names should be avoided, except for temporary and looping variables, or where a variable holds an undistinguished value of a type. Conventional one-character names are:</p>
</blockquote>
<blockquote>
<ul>
<li><code>b</code> for a <code>byte</code></li>
<li><code>c</code> for a <code>char</code></li>
<li><code>d</code> for a <code>double</code></li>
<li><code>e</code> for an <code>Exception</code></li>
<li><code>f</code> for a <code>float</code></li>
<li><code>i</code>, <code>j</code>, and <code>k</code> for <code>int</code>s</li>
<li><code>l</code> for a <code>long</code></li>
<li><code>o</code> for an <code>Object</code></li>
<li><code>s</code> for a <code>String</code></li>
<li><code>v</code> for an arbitrary value of some type</li>
</ul>
</blockquote>
<blockquote>
<p>Local variable or parameter names that consist of only two or three lowercase letters should not conflict with the initial country codes and domain names that are the first component of unique package names.</p>
</blockquote>
<h3 id="jls-6.5">6.5 Determining the Meaning of a Name</h3>
<h4 id="jls-6.5.1">6.5.1 Syntactic Classification of a Name According to Context</h4>
<p>A name is syntactically classified as a <em>ModuleName</em> in these contexts:</p>
<ul>
<li><p>In a <code>requires</code> directive in a module declaration (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-7.html#jls-7.7.">7.7.1</a>)</p></li>
<li><p>To the right of <code>to</code> in an <code>exports</code> or <code>opens</code> directive in a module declaration (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-7.html#jls-7.7.2">7.7.2</a>)</p></li>
</ul>
<p>A name is syntactically classified as a <em>PackageName</em> in these contexts:</p>
<ul>
<li><p>To the right of <code>exports</code> or <code>opens</code> in a module declaration</p></li>
<li><p>To the left of the &quot;<code>.</code>&quot; in a qualified <em>PackageName</em></p></li>
</ul>
<p>A name is syntactically classified as a <em>TypeName</em> in these contexts:</p>
<ul>
<li><p>The first eleven non-generic contexts (<a href="#jls-6.1">6.1</a>):</p>
<ol type="1">
<li><p>In a <code>uses</code> or <code>provides</code> directive in a module declaration (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-7.html#jls-7.7.">7.7.1</a>)</p></li>
<li><p>In a single-type-import declaration (<a href="#jls-7.5.1">7.5.1</a>)</p></li>
<li><p>To the left of the <code>.</code> in a single-static-import declaration (<a href="#jls-7.5.3">7.5.3</a>)</p></li>
<li><p>To the left of the <code>.</code> in a static-import-on-demand declaration (<a href="#jls-7.5.4">7.5.4</a>)</p></li>
<li><p>To the left of the <code>(</code> in a constructor declaration (<a href="#jls-8.8">8.8</a>)</p></li>
<li><p>After the <code>@</code> sign in an annotation (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-9.html#jls-9.7">9.7</a>)</p></li>
<li><p>To the left of <code>.class</code> in a class literal (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.8.2">15.8.2</a>)</p></li>
<li><p>To the left of <code>.this</code> in a qualified <code>this</code> expression (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.8.4">15.8.4</a>)</p></li>
<li><p>To the left of <code>.super</code> in a qualified superclass field access expression (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.11.2">15.11.2</a>)</p></li>
<li><p>To the left of <code>.</code><em>Identifier</em> or <code>.super.</code><em>Identifier</em> in a qualified method invocation expression (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.12">15.12</a>)</p></li>
<li><p>To the left of <code>.super::</code> in a method reference expression (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.13">15.13</a>)</p></li>
</ol></li>
<li><p>As the <em>Identifier</em> or dotted <em>Identifier</em> sequence that constitutes any <em>ReferenceType</em> (including a <em>ReferenceType</em> to the left of the brackets in an array type, or to the left of the &lt; in a parameterized type, or in a non-wildcard type argument of a parameterized type, or in an <code>extends</code> or <code>super</code> clause of a wildcard type argument of a parameterized type) in the <del>16</del> <strong>17</strong> contexts where types are used (<a href="#jls-4.11">4.11</a>):</p>
<ol type="1">
<li><p>In an <code>extends</code> or <code>implements</code> clause of a class declaration (<a href="#jls-8.1.4">8.1.4</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.1.5">8.1.5</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.5">8.5</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-9.html#jls-9.5">9.5</a>)</p></li>
<li><p>In an <code>extends</code> clause of an interface declaration (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-9.html#jls-9.1.3">9.1.3</a>)</p></li>
<li><p>The return type of a method (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.4">8.4</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-9.html#jls-9.4">9.4</a>) (including the type of an element of an annotation type (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-9.html#jls-9.6.1">9.6.1</a>))</p></li>
<li><p>In the <code>throws</code> clause of a method or constructor (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.4.6">8.4.6</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.8.5">8.8.5</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-9.html#jls-9.4">9.4</a>)</p></li>
<li><p>In an <code>extends</code> clause of a type parameter declaration of a generic class, interface, method, or constructor (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.1.2">8.1.2</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-9.html#jls-9.1.2">9.1.2</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.4.4">8.4.4</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.8.4">8.8.4</a>)</p></li>
<li><p>The type in a field declaration of a class or interface (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.3">8.3</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-9.html#jls-9.3">9.3</a>)</p></li>
<li><p>The type in a formal parameter declaration of a method, constructor, or lambda expression (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.4.1">8.4.1</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.8.1">8.8.1</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-9.html#jls-9.4">9.4</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.27.1">15.27.1</a>)</p></li>
<li><p>The type of the receiver parameter of a method (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.4">8.4</a>)</p></li>
<li><p>The type in a local variable declaration (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-14.html#jls-14.4">14.4</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-14.html#jls-14.14.1">14.14.1</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-14.html#jls-14.14.2">14.14.2</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-14.html#jls-14.20.3">14.20.3</a>)</p></li>
<li><p>A type in an exception parameter declaration (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-14.html#jls-14.20">14.20</a>)</p></li>
<li><p><strong>The type of a record component of a record (<a href="#jls-8.10.1">8.10.1</a>)</strong></p></li>
</ol>
<p><del>11.</del> <strong>12.</strong> In an explicit type argument list to an explicit constructor invocation statement or class instance creation expression or method invocation expression (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.8.7.1">8.8.7.1</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.9">15.9</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.12">15.12</a>)</p>
<p><del>12.</del> <strong>13.</strong> In an unqualified class instance creation expression, either as the class type to be instantiated (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.9">15.9</a>) or as the direct superclass or direct superinterface of an anonymous class to be instantiated (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.9.5">15.9.5</a>)</p>
<p><del>13.</del> <strong>14.</strong> The element type in an array creation expression (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.10.1">15.10.1</a>)</p>
<p><del>14.</del> <strong>15.</strong> The type in the cast operator of a cast expression (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.16">15.16</a>)</p>
<p><del>15.</del> <strong>16.</strong> The type that follows the <code>instanceof</code> relational operator (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.20.2">15.20.2</a>)</p>
<p><del>16.</del> <strong>17.</strong> In a method reference expression (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.13">15.13</a>), as the reference type to search for a member method or as the class type or array type to construct.</p></li>
</ul>
<blockquote>
<p>The extraction of a <em>TypeName</em> from the identifiers of a <em>ReferenceType</em> in the 16 contexts above is intended to apply recursively to all sub-terms of the <em>ReferenceType</em>, such as its element type and any type arguments.</p>
<p>For example, suppose a field declaration uses the type <code>p.q.Foo[]</code>. The brackets of the array type are ignored, and the term <code>p.q.Foo</code> is extracted as a dotted sequence of <em>Identifiers</em> to the left of the brackets in an array type, and classified as a <em>TypeName</em>. A later step determines which of <code>p</code>, <code>q</code>, and <code>Foo</code> is a type name or a package name.</p>
<p>As another example, suppose a cast operator uses the type <code>p.q.Foo&lt;? extends String&gt;</code>. The term <code>p.q.Foo</code> is again extracted as a dotted sequence of <em>Identifier</em> terms, this time to the left of the <code>&lt;</code> in a parameterized type, and classified as a <em>TypeName</em>. The term <code>String</code> is extracted as an <em>Identifier</em> in an <code>extends</code> clause of a wildcard type argument of a parameterized type, and classified as a <em>TypeName</em>.</p>
</blockquote>
<p>A name is syntactically classified as an <em>ExpressionName</em> in these contexts:</p>
<ul>
<li><p>As the qualifying expression in a qualified superclass constructor invocation (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.8.7.1">8.8.7.1</a>)</p></li>
<li><p>As the qualifying expression in a qualified class instance creation expression (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.9">15.9</a>)</p></li>
<li><p>As the array reference expression in an array access expression (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.10.3">15.10.3</a>)</p></li>
<li><p>As a <em>PostfixExpression</em> (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.14">15.14</a>)</p></li>
<li><p>As the left-hand operand of an assignment operator (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.26">15.26</a>)</p></li>
<li><p>As a <em>VariableAccess</em> in a <code>try</code>-with-resources statement (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-14.html#jls-14.20.3">14.20.3</a>)</p></li>
</ul>
<p>A name is syntactically classified as a <em>MethodName</em> in this context:</p>
<ul>
<li>Before the &quot;<code>(</code>&quot; in a method invocation expression (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.12">15.12</a>)</li>
</ul>
<p>A name is syntactically classified as a <em>PackageOrTypeName</em> in these contexts:</p>
<ul>
<li><p>To the left of the &quot;<code>.</code>&quot; in a qualified <em>TypeName</em></p></li>
<li><p>In a type-import-on-demand declaration (<a href="#jls-7.5.2">7.5.2</a>)</p></li>
</ul>
<p>A name is syntactically classified as an <em>AmbiguousName</em> in these contexts:</p>
<ul>
<li><p>To the left of the &quot;<code>.</code>&quot; in a qualified <em>ExpressionName</em></p></li>
<li><p>To the left of the rightmost <code>.</code> that occurs before the &quot;<code>(</code>&quot; in a method invocation expression</p></li>
<li><p>To the left of the &quot;<code>.</code>&quot; in a qualified <em>AmbiguousName</em></p></li>
<li><p>In the default value clause of an annotation type element declaration (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-9.html#jls-9.6.2">9.6.2</a>)</p></li>
<li><p>To the right of an &quot;<code>=</code>&quot; in an an element-value pair (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-9.html#jls-9.7.1">9.7.1</a>)</p></li>
<li><p>To the left of <code>::</code> in a method reference expression (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.13">15.13</a>)</p></li>
</ul>
<blockquote>
<p>The effect of syntactic classification is to restrict certain kinds of entities to certain parts of expressions:</p>
</blockquote>
<blockquote>
<ul>
<li><p>The name of a field, parameter, or local variable may be used as an expression (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.14.1">15.14.1</a>).</p></li>
<li><p>The name of a method may appear in an expression only as part of a method invocation expression (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.12">15.12</a>).</p></li>
<li><p>The name of a class or interface type may appear in an expression only as part of a class literal (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.8.2">15.8.2</a>), a qualified <code>this</code> expression (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.8.4">15.8.4</a>), a class instance creation expression (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.9">15.9</a>), an array creation expression (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.10.1">15.10.1</a>), a cast expression (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.16">15.16</a>), an <code>instanceof</code> expression (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.20.2">15.20.2</a>), an enum constant (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.9">8.9</a>), or as part of a qualified name for a field or method.</p></li>
<li><p>The name of a package may appear in an expression only as part of a qualified name for a class or interface type.</p></li>
</ul>
</blockquote>
<h2 id="jls-7">Chapter 7: Packages and Modules</h2>
<h3 id="jls-7.5">7.5 Import Declarations</h3>
<h4 id="jls-7.5.1">7.5.1 Single-Type-Import Declarations</h4>
<p>A <em>single-type-import declaration</em> imports a single type by giving its canonical name, making it available under a simple name in the module, class, and interface declarations of the compilation unit in which the single-type-import declaration appears.</p>
<dl>
<dt><em>SingleTypeImportDeclaration:</em></dt>
<dd><code>import</code> <em>TypeName</em> <code>;</code>
</dd>
</dl>
<p>The <em>TypeName</em> must be the canonical name of a class type, interface type, enum type, <strong>record type,</strong> or annotation type (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-6.html#jls-6.7">6.7</a>).</p>
<p>The type must be either a member of a named package, or a member of a type whose outermost lexically enclosing type declaration (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.1.3">8.1.3</a>) is a member of a named package, or a compile-time error occurs.</p>
<p>It is a compile-time error if the named type is not accessible (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-6.html#jls-6.6">6.6</a>).</p>
<p>If two single-type-import declarations in the same compilation unit attempt to import types with the same simple name, then a compile-time error occurs, unless the two types are the same type, in which case the duplicate declaration is ignored.</p>
<p>If the type imported by the single-type-import declaration is declared in the compilation unit that contains the <code>import</code> declaration, the <code>import</code> declaration is ignored.</p>
<p>If a single-type-import declaration imports a type whose simple name is <em>n</em>, and the compilation unit also declares a top level type (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-7.html#jls-7.6">7.6</a>) whose simple name is <em>n</em>, a compile-time error occurs.</p>
<p>If a compilation unit contains both a single-type-import declaration that imports a type whose simple name is <em>n</em>, and a single-static-import declaration (<a href="#jls-7.5.3">7.5.3</a>) that imports a type whose simple name is <em>n</em>, a compile-time error occurs, unless the two types are the same type, in which case the duplicate declaration is ignored.</p>
<div class="example">
<p>Example 7.5.1-1. Single-Type-Import</p>
<pre><code>import java.util.Vector;</code></pre>
<p>causes the simple name <code>Vector</code> to be available within the class and interface declarations in a compilation unit. Thus, the simple name <code>Vector</code> refers to the type declaration <code>Vector</code> in the package <code>java.util</code> in all places where it is not shadowed (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-6.html#jls-6.4.1">6.4.1</a>) or obscured (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-6.html#jls-6.4.2">6.4.2</a>) by a declaration of a field, parameter, local variable, or nested type declaration with the same name.</p>
<p>Note that the actual declaration of <code>java.util.Vector</code> is generic (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.1.2">8.1.2</a>). Once imported, the name <code>Vector</code> can be used without qualification in a parameterized type such as <code>Vector&lt;String&gt;</code>, or as the raw type <code>Vector</code>. A related limitation of the <code>import</code> declaration is that a nested type declared inside a generic type declaration can be imported, but its outer type is always erased.</p>
</div>
<div class="example">
<p>Example 7.5.1-2. Duplicate Type Declarations</p>
<p>This program:</p>
<pre><code>import java.util.Vector;
class Vector { Object[] vec; }</code></pre>
<p>causes a compile-time error because of the duplicate declaration of <code>Vector</code>, as does:</p>
<pre><code>import java.util.Vector;
import myVector.Vector;</code></pre>
<p>where <code>myVector</code> is a package containing the compilation unit:</p>
<pre><code>package myVector;
public class Vector { Object[] vec; }</code></pre>
</div>
<div class="example">
<p>Example 7.5.1-3. No Import of a Subpackage</p>
<p>Note that an <code>import</code> declaration cannot import a subpackage, only a type.</p>
<p>For example, it does not work to try to import <code>java.util</code> and then use the name <code>util.Random</code> to refer to the type <code>java.util.Random</code>:</p>
<pre><code>import java.util;
class Test { util.Random generator; }
  // incorrect: compile-time error</code></pre>
</div>
<div class="example">
<p>Example 7.5.1-4. Importing a Type Name that is also a Package Name</p>
<p>Package names and type names are usually different under the naming conventions described in <a href="#jls-6.1">6.1</a>. Nevertheless, in a contrived example where there is an unconventionally-named package <code>Vector</code>, which declares a public class whose name is <code>Mosquito</code>:</p>
<pre><code>package Vector;
public class Mosquito { int capacity; }</code></pre>
<p>and then the compilation unit:</p>
<pre><code>package strange;
import java.util.Vector;
import Vector.Mosquito;
class Test {
    public static void main(String[] args) {
        System.out.println(new Vector().getClass());
        System.out.println(new Mosquito().getClass());
    }
}</code></pre>
<p>the single-type-import declaration importing class <code>Vector</code> from package <code>java.util</code> does not prevent the package name <code>Vector</code> from appearing and being correctly recognized in subsequent <code>import</code> declarations. The example compiles and produces the output:</p>
<pre><code>class java.util.Vector
class Vector.Mosquito</code></pre>
</div>
<h4 id="jls-7.5.2">7.5.2 Type-Import-on-Demand Declarations</h4>
<p>A <em>type-import-on-demand declaration</em> allows all accessible types of a named package or type to be imported as needed.</p>
<dl>
<dt><em>TypeImportOnDemandDeclaration:</em></dt>
<dd><code>import</code> <em>PackageOrTypeName</em> <code>.</code> <code>*</code> <code>;</code>
</dd>
</dl>
<p>The <em>PackageOrTypeName</em> must be the canonical name (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-6.html#jls-6.7">6.7</a>) of a package, a class type, an interface type, an enum type, <strong>a record type,</strong> or an annotation type.</p>
<p>If the <em>PackageOrTypeName</em> denotes a type (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-6.html#jls-6.5.4">6.5.4</a>), then the type must be either a member of a named package, or a member of a type whose outermost lexically enclosing type declaration (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.1.3">8.1.3</a>) is a member of a named package, or a compile-time error occurs.</p>
<p>It is a compile-time error if the named package is not uniquely visible to the current module (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-7.html#jls-7.4.3">7.4.3</a>), or if the named type is not accessible (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-6.html#jls-6.6">6.6</a>).</p>
<p>It is not a compile-time error to name either <code>java.lang</code> or the named package of the current compilation unit in a type-import-on-demand declaration. The type-import-on-demand declaration is ignored in such cases.</p>
<p>Two or more type-import-on-demand declarations in the same compilation unit may name the same type or package. All but one of these declarations are considered redundant; the effect is as if that type was imported only once.</p>
<p>If a compilation unit contains both a type-import-on-demand declaration and a static-import-on-demand declaration (<a href="#jls-7.5.4">7.5.4</a>) that name the same type, the effect is as if the <code>static</code> member types of that type (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.5">8.5</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-9.html#jls-9.5">9.5</a>) were imported only once.</p>
<div class="example">
<p>Example 7.5.2-1. Type-Import-on-Demand</p>
<pre><code>import java.util.*;</code></pre>
<p>causes the simple names of all <code>public</code> types declared in the package <code>java.util</code> to be available within the class and interface declarations of the compilation unit. Thus, the simple name <code>Vector</code> refers to the type <code>Vector</code> in the package <code>java.util</code> in all places in the compilation unit where that type declaration is not shadowed (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-6.html#jls-6.4.1">6.4.1</a>) or obscured (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-6.html#jls-6.4.2">6.4.2</a>).</p>
<p>The declaration might be shadowed by a single-type-import declaration of a type whose simple name is <code>Vector</code>; by a type named <code>Vector</code> and declared in the package to which the compilation unit belongs; or any nested classes or interfaces.</p>
<p>The declaration might be obscured by a declaration of a field, parameter, or local variable named <code>Vector</code>.</p>
<p>(It would be unusual for any of these conditions to occur.)</p>
</div>
<h4 id="jls-7.5.3">7.5.3 Single-Static-Import Declarations</h4>
<p>A <em>single-static-import declaration</em> imports all accessible <code>static</code> members with a given simple name from a type. This makes these <code>static</code> members available under their simple name in the module, class, and interface declarations of the compilation unit in which the single-static-import declaration appears.</p>
<dl>
<dt><em>SingleStaticImportDeclaration:</em></dt>
<dd><code>import</code> <code>static</code> <em>TypeName</em> <code>.</code> <em>Identifier</em> <code>;</code>
</dd>
</dl>
<p>The <em>TypeName</em> must be the canonical name (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-6.html#jls-6.7">6.7</a>) of a class type, interface type, enum type, <strong>record type,</strong> or annotation type.</p>
<p>The type must be either a member of a named package, or a member of a type whose outermost lexically enclosing type declaration (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.1.3">8.1.3</a>) is a member of a named package, or a compile-time error occurs.</p>
<p>It is a compile-time error if the named type is not accessible (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-6.html#jls-6.6">6.6</a>).</p>
<p>The <em>Identifier</em> must name at least one <code>static</code> member of the named type. It is a compile-time error if there is no <code>static</code> member of that name, or if all of the named members are not accessible.</p>
<p>It is permissible for one single-static-import declaration to import several fields or types with the same name, or several methods with the same name and signature. This occurs when the named type inherits multiple fields, member types, or methods, all with the same name, from its own supertypes.</p>
<p>If two single-static-import declarations in the same compilation unit attempt to import types with the same simple name, then a compile-time error occurs, unless the two types are the same type, in which case the duplicate declaration is ignored.</p>
<p>If a single-static-import declaration imports a type whose simple name is <em>n</em>, and the compilation unit also declares a top level type (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-7.html#jls-7.6">7.6</a>) whose simple name is <em>n</em>, a compile-time error occurs.</p>
<p>If a compilation unit contains both a single-static-import declaration that imports a type whose simple name is <em>n</em>, and a single-type-import declaration (<a href="#jls-7.5.1">7.5.1</a>) that imports a type whose simple name is <em>n</em>, a compile-time error occurs, unless the two types are the same type, in which case the duplicate declaration is ignored.</p>
<h4 id="jls-7.5.4">7.5.4 Static-Import-on-Demand Declarations</h4>
<p>A <em>static-import-on-demand declaration</em> allows all accessible <code>static</code> members of a named type to be imported as needed.</p>
<dl>
<dt><em>StaticImportOnDemandDeclaration:</em></dt>
<dd><code>import</code> <code>static</code> <em>TypeName</em> <code>.</code> <code>*</code> <code>;</code>
</dd>
</dl>
<p>The <em>TypeName</em> must be the canonical name (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-6.html#jls-6.7">6.7</a>) of a class type, interface type, enum type, <strong>record type,</strong> or annotation type.</p>
<p>The type must be either a member of a named package, or a member of a type whose outermost lexically enclosing type declaration (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.1.3">8.1.3</a>) is a member of a named package, or a compile-time error occurs.</p>
<p>It is a compile-time error if the named type is not accessible (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-6.html#jls-6.6">6.6</a>).</p>
<p>Two or more static-import-on-demand declarations in the same compilation unit may name the same type; the effect is as if there was exactly one such declaration.</p>
<p>Two or more static-import-on-demand declarations in the same compilation unit may name the same member; the effect is as if the member was imported exactly once.</p>
<p>It is permissible for one static-import-on-demand declaration to import several fields or types with the same name, or several methods with the same name and signature. This occurs when the named type inherits multiple fields, member types, or methods, all with the same name, from its own supertypes.</p>
<p>If a compilation unit contains both a static-import-on-demand declaration and a type-import-on-demand declaration (<a href="#jls-7.5.2">7.5.2</a>) that name the same type, the effect is as if the <code>static</code> member types of that type (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.5">8.5</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-9.html#jls-9.5">9.5</a>) were imported only once.</p>
<h2 id="jls-8">Chapter 8: Classes</h2>
<p>Class declarations define new reference types and describe how they are implemented (<a href="#jls-8.1">8.1</a>).</p>
<p>A <em>top level class</em> is a class that is not a nested class.</p>
<p>A <em>nested class</em> is any class whose declaration occurs within the body of another class or interface.</p>
<p>This chapter discusses the common semantics of all classes - top level (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-7.html#jls-7.6">7.6</a>) and nested (including member classes (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.5">8.5</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-9.html#jls-9.5">9.5</a>), local classes <strong>and local records</strong> (<a href="#jls-14.3">14.3</a>) and anonymous classes (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.9.5">15.9.5</a>)). Details that are specific to particular kinds of classes are discussed in the sections dedicated to these constructs.</p>
<p>A named class may be declared <code>abstract</code> (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.1.1.1">8.1.1.1</a>) and must be declared abstract if it is incompletely implemented; such a class cannot be instantiated, but can be extended by subclasses. A class may be declared <code>final</code> (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.1.1.2">8.1.1.2</a>), in which case it cannot have subclasses. If a class is declared <code>public</code>, then it can be referred to from code in any package of its module and potentially from code in other modules. Each class except <code>Object</code> is an extension of (that is, a subclass of) a single existing class (<a href="#jls-8.1.4">8.1.4</a>) and may implement interfaces (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.1.5">8.1.5</a>). Classes may be <em>generic</em> (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.1.2">8.1.2</a>), that is, they may declare type variables whose bindings may differ among different instances of the class.</p>
<p>Classes may be decorated with annotations (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-9.html#jls-9.7">9.7</a>) just like any other kind of declaration.</p>
<p>The body of a class declares members (fields and methods and nested classes and interfaces), instance and static initializers, and constructors (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.1.6">8.1.6</a>). The scope (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-6.html#jls-6.3">6.3</a>) of a member (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.2">8.2</a>) is the entire body of the declaration of the class to which the member belongs. Field, method, member class, member interface, and constructor declarations may include the access modifiers (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-6.html#jls-6.6">6.6</a>) <code>public</code>, <code>protected</code>, or <code>private</code>. The members of a class include both declared and inherited members (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.2">8.2</a>). Newly declared fields can hide fields declared in a superclass or superinterface. Newly declared class members and interface members can hide class or interface members declared in a superclass or superinterface. Newly declared methods can hide, implement, or override methods declared in a superclass or superinterface.</p>
<p>Field declarations (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.3">8.3</a>) describe class variables, which are incarnated once, and instance variables, which are freshly incarnated for each instance of the class. A field may be declared <code>final</code> (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.3.1.2">8.3.1.2</a>), in which case it can be assigned to only once. Any field declaration may include an initializer.</p>
<p>Member class declarations (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.5">8.5</a>) describe nested classes that are members of the surrounding class. Member classes may be <code>static</code>, in which case they have no access to the instance variables of the surrounding class; or they may be inner classes (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.1.3">8.1.3</a>).</p>
<p>Member interface declarations (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.5">8.5</a>) describe nested interfaces that are members of the surrounding class.</p>
<p>Method declarations (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.4">8.4</a>) describe code that may be invoked by method invocation expressions (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.12">15.12</a>). A class method is invoked relative to the class type; an instance method is invoked with respect to some particular object that is an instance of a class type. A method whose declaration does not indicate how it is implemented must be declared <code>abstract</code>. A method may be declared <code>final</code> (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.4.3.3">8.4.3.3</a>), in which case it cannot be hidden or overridden. A method may be implemented by platform-dependent <code>native</code> code (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.4.3.4">8.4.3.4</a>). A <code>synchronized</code> method (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.4.3.6">8.4.3.6</a>) automatically locks an object before executing its body and automatically unlocks the object on return, as if by use of a <code>synchronized</code> statement (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-14.html#jls-14.19">14.19</a>), thus allowing its activities to be synchronized with those of other threads (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-17.html">17</a>).</p>
<p>Method names may be overloaded (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.4.9">8.4.9</a>).</p>
<p>Instance initializers (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.6">8.6</a>) are blocks of executable code that may be used to help initialize an instance when it is created (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.9">15.9</a>).</p>
<p>Static initializers (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.7">8.7</a>) are blocks of executable code that may be used to help initialize a class.</p>
<p>Constructors (<a href="#jls-8.8">8.8</a>) are similar to methods, but cannot be invoked directly by a method call; they are used to initialize new class instances. Like methods, they may be overloaded (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.8.8">8.8.8</a>).</p>
<h3 id="jls-8.1">8.1 Class Declarations</h3>
<p>A class declaration specifies a new named reference type.</p>
<p>There are <del>two</del> <strong>three</strong> kinds of class declarations: <em>normal class declarations</em><strong>,</strong> <del>and</del> <em>enum declarations</em><strong>, and <em>record declarations</em></strong>.</p>
<dl>
<dt><em>ClassDeclaration:</em></dt>
<dd><em>NormalClassDeclaration</em>
</dd>
<dd><em>EnumDeclaration</em>
</dd>
<dd><strong><em>RecordDeclaration</em></strong>
</dd>
<dt><em>NormalClassDeclaration:</em></dt>
<dd>{<em>ClassModifier</em>} <code>class</code> <em>TypeIdentifier</em> [<em>TypeParameters</em>]<br />
[<em>Superclass</em>] [<em>Superinterfaces</em>] <em>ClassBody</em>
</dd>
</dl>
<p>The rules in this section apply to all class declarations, including enum declarations <strong>and record declarations</strong>. However, special rules apply to enum declarations <strong>and record declarations</strong> with regard to class modifiers, inner classes, and superclasses; these rules are stated in <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.9">8.9</a> <strong>and <a href="#jls-8.10">8.10</a></strong>.</p>
<p>The <em>TypeIdentifier</em> in a class declaration specifies the name of the class.</p>
<p>It is a compile-time error if a class has the same simple name as any of its enclosing classes or interfaces.</p>
<p>The scope and shadowing of a class declaration is specified in <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-6.html#jls-6.3">6.3</a> and <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-6.html#jls-6.4">6.4</a>.</p>
<h4 id="jls-8.1.4">8.1.4 Superclasses and Subclasses</h4>
<p>The optional <code>extends</code> clause in a normal class declaration specifies the <em>direct superclass</em> of the current class.</p>
<dl>
<dt><em>Superclass:</em></dt>
<dd><code>extends</code> <em>ClassType</em>
</dd>
</dl>
<p>The <code>extends</code> clause must not appear in the definition of the class <code>Object</code>, or a compile-time error occurs, because it is the primordial class and has no direct superclass.</p>
<p>The <em>ClassType</em> must name an accessible class type (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-6.html#jls-6.6">6.6</a>), or a compile-time error occurs.</p>
<p>It is a compile-time error if the <em>ClassType</em> names a class that is <code>final</code>, because <code>final</code> classes are not allowed to have subclasses (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.1.1.2">8.1.1.2</a>).</p>
<p>It is a compile-time error if the <em>ClassType</em> names the class <code>Enum</code> or any invocation of <code>Enum</code> (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.9">8.9</a>).</p>
<p><strong>It is a compile-time error if the <em>ClassType</em> names the class <code>Record</code> (<a href="#jls-8.10">8.10</a>).</strong></p>
<p>If the <em>ClassType</em> has type arguments, it must denote a well-formed parameterized type (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-4.html#jls-4.5">4.5</a>), and none of the type arguments may be wildcard type arguments, or a compile-time error occurs.</p>
<p>Given a (possibly generic) class declaration <em>C</em><code>&lt;</code><em>F<sub>1</sub></em>,...,<em>F<sub>n</sub></em><code>&gt;</code> (<em>n</em> <em>≥</em> 0, <em>C</em> <em>≠</em> <code>Object</code>), the <em>direct superclass</em> of the class type <em>C</em><code>&lt;</code><em>F<sub>1</sub></em>,...,<em>F<sub>n</sub></em><code>&gt;</code> is the type given in the <code>extends</code> clause of the declaration of <em>C</em> if an <code>extends</code> clause is present, or <code>Object</code> otherwise.</p>
<p>Given a generic class declaration <em>C</em><code>&lt;</code><em>F<sub>1</sub></em>,...,<em>F<sub>n</sub></em><code>&gt;</code> (<em>n</em> &gt; 0), the <em>direct superclass</em> of the parameterized class type <em>C</em><code>&lt;</code><em>T<sub>1</sub></em>,...,<em>T<sub>n</sub></em><code>&gt;</code>, where <em>T<sub>i</sub></em> (1 <em>≤</em> <em>i</em> <em>≤</em> <em>n</em>) is a type, is <em>D</em><code>&lt;</code><em>U<sub>1</sub></em> <em>θ</em>,...,<em>U<sub>k</sub></em> <em>θ</em><code>&gt;</code>, where <em>D</em><code>&lt;</code><em>U<sub>1</sub></em>,...,<em>U<sub>k</sub></em><code>&gt;</code> is the direct superclass of <em>C</em><code>&lt;</code><em>F<sub>1</sub></em>,...,<em>F<sub>n</sub></em><code>&gt;</code> and <em>θ</em> is the substitution <code>[*F~1~*:=*T~1~*,...,*F~n~*:=*T~n~*]</code>.</p>
<p>A class is said to be a <em>direct subclass</em> of its direct superclass. The direct superclass is the class from whose implementation the implementation of the current class is derived.</p>
<p>The <em>subclass</em> relationship is the transitive closure of the direct subclass relationship. A class <em>A</em> is a subclass of class <em>C</em> if either of the following is true:</p>
<ul>
<li><p><em>A</em> is the direct subclass of <em>C</em></p></li>
<li><p>There exists a class <em>B</em> such that <em>A</em> is a subclass of <em>B</em>, and <em>B</em> is a subclass of <em>C</em>, applying this definition recursively.</p></li>
</ul>
<p>Class <em>C</em> is said to be a <em>superclass</em> of class <em>A</em> whenever <em>A</em> is a subclass of <em>C</em>.</p>
<div class="example">
<p>Example 8.1.4-1. Direct Superclasses and Subclasses</p>
<pre><code>class Point { int x, y; }
final class ColoredPoint extends Point { int color; }
class Colored3DPoint extends ColoredPoint { int z; }  // error</code></pre>
<p>Here, the relationships are as follows:</p>
<ul>
<li><p>The class <code>Point</code> is a direct subclass of <code>Object</code>.</p></li>
<li><p>The class <code>Object</code> is the direct superclass of the class <code>Point</code>.</p></li>
<li><p>The class <code>ColoredPoint</code> is a direct subclass of class <code>Point</code>.</p></li>
<li><p>The class <code>Point</code> is the direct superclass of class <code>ColoredPoint</code>.</p></li>
</ul>
<p>The declaration of class <code>Colored3dPoint</code> causes a compile-time error because it attempts to extend the final class <code>ColoredPoint</code>.</p>
</div>
<div class="example">
<p>Example 8.1.4-2. Superclasses and Subclasses</p>
<pre><code>class Point { int x, y; }
class ColoredPoint extends Point { int color; }
final class Colored3dPoint extends ColoredPoint { int z; }</code></pre>
<p>Here, the relationships are as follows:</p>
<ul>
<li><p>The class <code>Point</code> is a superclass of class <code>ColoredPoint</code>.</p></li>
<li><p>The class <code>Point</code> is a superclass of class <code>Colored3dPoint</code>.</p></li>
<li><p>The class <code>ColoredPoint</code> is a subclass of class <code>Point</code>.</p></li>
<li><p>The class <code>ColoredPoint</code> is a superclass of class <code>Colored3dPoint</code>.</p></li>
<li><p>The class <code>Colored3dPoint</code> is a subclass of class <code>ColoredPoint</code>.</p></li>
<li><p>The class <code>Colored3dPoint</code> is a subclass of class <code>Point</code>.</p></li>
</ul>
</div>
<p>A class <em>C</em> <em>directly depends</em> on a type <em>T</em> if <em>T</em> is mentioned in the <code>extends</code> or <code>implements</code> clause of <em>C</em> either as a superclass or superinterface, or as a qualifier in the fully qualified form of a superclass or superinterface name.</p>
<p>A class <em>C</em> <em>depends</em> on a reference type <em>T</em> if any of the following is true:</p>
<ul>
<li><p><em>C</em> directly depends on <em>T</em>.</p></li>
<li><p><em>C</em> directly depends on an interface <em>I</em> that depends (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-9.html#jls-9.1.3">9.1.3</a>) on <em>T</em>.</p></li>
<li><p><em>C</em> directly depends on a class <em>D</em> that depends on <em>T</em> (using this definition recursively).</p></li>
</ul>
<p>It is a compile-time error if a class depends on itself.</p>
<p>If circularly declared classes are detected at run time, as classes are loaded, then a <code>ClassCircularityError</code> is thrown (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-12.html#jls-12.2.">12.2.1</a>).</p>
<div class="example">
<p>Example 8.1.4-3. Class Depends on Itself</p>
<pre><code>class Point extends ColoredPoint { int x, y; }
class ColoredPoint extends Point { int color; }</code></pre>
<p>This program causes a compile-time error because class <code>Point</code> depends on itself.</p>
</div>
<h3 id="jls-8.5">8.5 Member Type Declarations</h3>
<h4 id="jls-8.5.1">8.5.1 Static Member Type Declarations</h4>
<p>The <code>static</code> keyword may modify the declaration of a member type <em>C</em> within the body of a non-inner class or interface <em>T</em>. Its effect is to declare that <em>C</em> is not an inner class. Just as a <code>static</code> method of <em>T</em> has no current instance of <em>T</em> in its body, <em>C</em> also has no current instance of <em>T</em>, nor does it have any lexically enclosing instances.</p>
<p>It is a compile-time error if a <code>static</code> class contains a usage of a non-<code>static</code> member of an enclosing class.</p>
<p>A member interface is implicitly <code>static</code> (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-9.html#jls-9.1.1">9.1.1</a>). It is permitted for the declaration of a member interface to redundantly specify the <code>static</code> modifier.</p>
<p><strong>A member record is implicitly <code>static</code> (<a href="#jls-8.10">8.10</a>). It is permitted for the declaration of a member record to redundantly specify the <code>static</code> modifier.</strong></p>
<h3 id="jls-8.8">8.8 Constructor Declarations</h3>
<p>A <em>constructor</em> is used in the creation of an object that is an instance of a class (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-12.html#jls-12.5">12.5</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.9">15.9</a>).</p>
<dl>
<dt><em>ConstructorDeclaration:</em></dt>
<dd>{<em>ConstructorModifier</em>} <em>ConstructorDeclarator</em> [<em>Throws</em>] <em>ConstructorBody</em>
</dd>
<dt><em>ConstructorDeclarator:</em></dt>
<dd>[<em>TypeParameters</em>] <em>SimpleTypeName</em><br />
<code>(</code> [<em>ReceiverParameter</em> <code>,</code>] [<em>FormalParameterList</em>] <code>)</code>
</dd>
<dt><em>SimpleTypeName:</em></dt>
<dd><em>TypeIdentifier</em>
</dd>
</dl>
<p>The rules in this section apply to constructors in all class declarations, including enum declarations <strong>and record declarations</strong>. However, special rules apply to enum declarations with regard to constructor modifiers, constructor bodies, and default constructors; these rules are stated in <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.9.2">8.9.2</a>. <strong>Special rules also apply to record declarations with regard to constructors, including a special compact declaration form; the details are given in <a href="#jls-8.10.4">8.10.4</a>.</strong></p>
<p>The <em>SimpleTypeName</em> in the <em>ConstructorDeclarator</em> must be the simple name of the class that contains the constructor declaration, or a compile-time error occurs.</p>
<p>In all other respects, a constructor declaration looks just like a method declaration that has no result (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.4.5">8.4.5</a>).</p>
<p>Constructor declarations are not members. They are never inherited and therefore are not subject to hiding or overriding.</p>
<p>Constructors are invoked by class instance creation expressions (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.9">15.9</a>), by the conversions and concatenations caused by the string concatenation operator <code>+</code> (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.18.1">15.18.1</a>), and by explicit constructor invocations from other constructors (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.8.7">8.8.7</a>). Access to constructors is governed by access modifiers (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-6.html#jls-6.6">6.6</a>), so it is possible to prevent class instantiation by declaring an inaccessible constructor (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.8.10">8.8.10</a>).</p>
<p>Constructors are never invoked by method invocation expressions (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.12">15.12</a>).</p>
<div class="example">
<p>Example 8.8-1. Constructor Declarations</p>
<pre><code>class Point {
    int x, y;
    Point(int x, int y) { this.x = x; this.y = y; }
}</code></pre>
</div>
<h3 id="jls-8.10"><strong>8.10 Record Types</strong></h3>
<div class="editorial">
<p>This is a new section.</p>
</div>
<div class="inserted">
<p>A <em>record declaration</em> specifies a new <em>record type</em>, a special kind of class type.</p>
<dl>
<dt><em>RecordDeclaration</em>:</dt>
<dd>{<em>ClassModifier</em>} <code>record</code> <em>TypeIdentifier</em> [<em>TypeParameters</em>] <em>RecordHeader</em> [<em>SuperInterfaces</em>] <em>RecordBody</em>
</dd>
</dl>
<p>It is a compile-time error if a record declaration has the modifier <code>abstract</code>.</p>
<p>A record declaration is implicitly <code>final</code>. It is permitted for the declaration of a record type to redundantly specify the <code>final</code> modifier.</p>
<p>A nested record type is implicitly <code>static</code>. It is permitted for the declaration of a nested record type to redundantly specify the <code>static</code> modifier.</p>
<blockquote>
<p>This implies that it is impossible to declare a record type in the body of an inner class (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.1.3">8.1.3</a>), because an inner class cannot have <code>static</code> members except for constant variables.</p>
</blockquote>
<p>It is a compile-time error if the same keyword appears more than once as a modifier for a record declaration, or if a record declaration has more than one of the access modifiers <code>public</code>, <code>protected</code>, and <code>private</code> (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-6.html#jls-6.6">6.6</a>).</p>
<p>The direct superclass of a record type <em>R</em> is <code>java.lang.Record</code>.</p>
<blockquote>
<p>Note that a record declaration can not explicitly specify a superclass, so it is not possible to explicitly declare that the direct superclass of a record type is <code>java.lang.Record</code>.</p>
</blockquote>
<blockquote>
<p>The serialization mechanism treats instances of a record type differently to ordinary serializable or externalizable objects. In particular, a record object is deserialized using the canonical constructor (<a href="#jls-8.10.4">8.10.4</a>).</p>
</blockquote>
</div>
<h4 id="jls-8.10.1"><strong>8.10.1 Record Components</strong></h4>
<div class="inserted">
<p>The <em>record components</em> of a record type, if any, are specified by a list of comma-separated parameter specifiers in the header of a record declaration. Each record component consists of a type (optionally preceded by the <code>final</code> modifier and/or one or more annotations) and an identifier (optionally followed by brackets) that specifies the name of the record component. If a record type has no record components, then the record header consists of an empty pair of parentheses.</p>
<p>Each record component corresponds to an implicitly declared field and an accessor method (declared either explicitly or implicitly) of the record type (<a href="#jls-8.10.3">8.10.3</a>).</p>
<dl>
<dt><em>RecordHeader</em>:</dt>
<dd><code>(</code> [ <em>RecordComponentList</em> ] <code>)</code>
</dd>
<dt><em>RecordComponentList</em>:</dt>
<dd><em>RecordComponent</em> { <code>,</code> <em>RecordComponent</em> }
</dd>
<dt><em>RecordComponent</em>:</dt>
<dd>{ <em>VariableModifier</em> } <em>UnannType</em> <em>VariableDeclaratorId</em>
</dd>
<dd><em>VariableArityRecordComponent</em>
</dd>
<dt><em>VariableArityRecordComponent</em>:</dt>
<dd>{ <em>VariableModifier</em> } <em>UnannType</em> { <em>Annotation</em> } <code>...</code> <em>Identifier</em>
</dd>
</dl>
<blockquote>
<p>It can be seen that the production for <em>RecordComponent</em> is identical in content to the production for <em>FormalParameter</em> (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.4.1">8.4.1</a>).</p>
<p>The following productions from <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.4.1">8.4.1</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.3">8.3</a> and <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-4.html#jls-4.3">4.3</a> are shown here for convenience:</p>
<dl>
<dt><em>FormalParameter</em>:</dt>
<dd>{ <em>VariableModifier</em> } <em>UnannType</em> <em>VariableDeclaratorId</em>
</dd>
<dd><em>VariableArityParameter</em>
</dd>
<dt><em>VariableArityParameter</em>:</dt>
<dd>{ <em>VariableModifier</em> } <em>UnannType</em> { <em>Annotation</em> } <code>...</code> <em>Identifier</em>
</dd>
<dt><em>VariableModifier</em>:</dt>
<dd><em>Annotation</em>
</dd>
<dd><code>final</code>
</dd>
<dt><em>VariableDeclaratorId</em>:</dt>
<dd><em>Identifier</em> [ <em>Dims</em> ]
</dd>
<dt><em>Dims</em>:</dt>
<dd>{ <em>Annotation</em> } <code>[ ]</code> { { <em>Annotation</em> } <code>[ ]</code> }
</dd>
</dl>
</blockquote>
<p>It is permitted for a record component to redundantly specify the <code>final</code> modifier. It is a compile-time error if <code>final</code> appears more than once as a modifier for a record component.</p>
<p>A record component may be a variable arity record component, indicated by an ellipsis following the type. At most one variable arity record component is permitted for a record type. It is a compile-time error if a variable arity record component appears anywhere in the list of record components except the last position.</p>
<p>It is a compile-time error for a record declaration to declare two record components with the same name.</p>
<p>It is a compile-time error for a record declaration to declare a record component with the name <code>clone</code>, <code>finalize</code>, <code>getClass</code>, <code>hashCode</code>, <code>notify</code>, <code>notifyAll</code>, <code>toString</code>, or <code>wait</code>.</p>
<blockquote>
<p>As every record component has a corresponding accessor method (<a href="#jls-8.10.3">8.10.3</a>), this restriction prevents a record type containing possibly illegal overloads of methods from the class <code>Object</code>.</p>
</blockquote>
<p>The rules for annotation modifiers on a record component are specified in <a href="#jls-9.7.4">9.7.4</a>.</p>
<p>The declared type of a record component depends on whether it is a variable arity record component:</p>
<ul>
<li><p>If the record component is not a variable arity record component, then the declared type is denoted by <em>UnannType</em> if no bracket pairs appear in <em>UnannType</em> and <em>VariableDeclaratorId</em>, and specified by <a href="#jls-10.2">10.2</a> otherwise.</p></li>
<li><p>If the record component is a variable arity record component, then the declared type is an array type specified by <a href="#jls-10.2">10.2</a>.</p></li>
</ul>
<p>If the declared type of a variable arity record component has a non-reifiable element type (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-4.html#jls-4.7">4.7</a>), then a compile-time unchecked warning occurs for the declaration of the variable arity record component, unless the record type is annotated with <code>@SafeVarargs</code> (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-9.html#jls-9.6.4.7">9.6.4.7</a>) or the warning is suppressed by <code>@SuppressWarnings</code> (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-9.html#jls-9.6.4.5">9.6.4.5</a>).</p>
</div>
<h4 id="jls-8.10.2"><strong>8.10.2 Record Bodies</strong></h4>
<div class="inserted">
<p>The body of a record declaration may contain constructor and member declarations as well as static initializers.</p>
<dl>
<dt><em>RecordBody</em>:</dt>
<dd><code>{</code> {<em>RecordBodyDeclaration</em>} <code>}</code>
</dd>
<dt><em>RecordBodyDeclaration</em>:</dt>
<dd><em>ClassBodyDeclaration</em>
</dd>
<dd><em>CompactConstructorDeclaration</em>
</dd>
</dl>
<blockquote>
<p>The following productions from <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.1.6">8.1.6</a> are shown here for convenience:</p>
</blockquote>
<blockquote>
<dl>
<dt><em>ClassBodyDeclaration:</em></dt>
<dd><em>ClassMemberDeclaration</em>
</dd>
<dd><em>InstanceInitializer</em>
</dd>
<dd><em>StaticInitializer</em>
</dd>
<dd><em>ConstructorDeclaration</em>
</dd>
<dt><em>ClassMemberDeclaration:</em></dt>
<dd><em>FieldDeclaration</em>
</dd>
<dd><em>MethodDeclaration</em>
</dd>
<dd><em>ClassDeclaration</em>
</dd>
<dd><em>InterfaceDeclaration</em>
</dd>
<dd><code>;</code>
</dd>
</dl>
</blockquote>
<p>It is a compile-time error for the body of a record declaration to contain non-static field declarations (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.3.1.1">8.3.1.1</a>).</p>
<p>It is a compile-time error for the body of a record declaration to contain a <code>native</code> method declaration (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.4.3.4">8.4.3.4</a>).</p>
<p>It is a compile-time error for the body of a record declaration to contain an instance initializer (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.6">8.6</a>).</p>
</div>
<h4 id="jls-8.10.3"><strong>8.10.3 Record Members</strong></h4>
<div class="inserted">
<p>In a record type <em>R</em>, an <em>accessor method for a record component</em> is a method whose name is the same as the name of the record component of <em>R</em>, and whose formal parameter list is empty.</p>
<p>A record type <em>R</em> has the following members:</p>
<ul>
<li><p>For each record component appearing in the record component list:</p>
<ol type="1">
<li><p>An implicitly declared <code>private</code> <code>final</code> field with the same name as the record component and the same type as the declared type of the record component. This field is annotated with the annotations, if any, that appear on the corresponding record component and whose annotation types are applicable in the field declaration context, or in type contexts, or both.</p></li>
<li><p>An accessor method for the record component.</p>
<p>If an accessor method for the record component is not explicitly declared, then one is implicitly declared with the following properties:</p>
<ul>
<li><p>The name is the same as the name of the record component</p></li>
<li><p>The return type is the same as the declared type of the record component</p></li>
<li><p>It is not generic</p></li>
<li><p>It has an empty formal parameter list</p></li>
<li><p>It is declared <code>public</code></p></li>
<li><p>It is annotated with the annotations, if any, that appear on the corresponding record component and whose annotation types are applicable in the method declaration context, or in type contexts, or both.</p></li>
<li><p>The body of the implicitly declared accessor method simply returns the value of the corresponding field.</p></li>
</ul>
<blockquote>
<p>The restrictions on the component names (<a href="#jls-8.10.1">8.10.1</a>) mean that no implicitly declared accessor method will have a signature that is override-equivalent with a non-<code>private</code> method of the class <code>Object</code>.</p>
</blockquote></li>
</ol></li>
<li><p>All the members inherited from <code>java.lang.Record</code>. Unless explicitly overridden in the record body, <em>R</em> has implicitly declared methods that override the <code>equals</code>, <code>hashCode</code> and <code>toString</code> methods from <code>java.lang.Record</code>.</p>
<blockquote>
<p>Should any of these methods from <code>java.lang.Record</code> be explicitly declared in the record body, the implementations should satisfy the expected semantics as specified in <code>java.lang.Record</code>.</p>
</blockquote></li>
<li><p>All the other members explicitly declared in the body of the declaration of <em>R</em>.</p></li>
</ul>
<p>If an accessor method is declared explicitly, then it must additionally satisfy the following rules; otherwise a compile-time error occurs:</p>
<ul>
<li><p>The return type of the accessor method must be identical to the declared type of the corresponding record component</p></li>
<li><p>The accessor method must not be generic (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.4.4">8.4.4</a>)</p></li>
<li><p>The accessor method must be declared <code>public</code></p></li>
<li><p>The accessor method must not be declared <code>static</code></p></li>
<li><p>The accessor method must not have a <code>throws</code> clause</p></li>
<li><p>All other rules for a method in a normal class declaration must be satisfied (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.4">8.4</a>).</p></li>
</ul>
<blockquote>
<p>Annotations that appear on a record component are not carried over to an explicitly declared accessor method for that record component. This is in contrast to an implicitly declared accessor method which is annotated with the applicable annotations from the record component.</p>
</blockquote>
<p>All the rules for field declarations and method declarations in a normal class declaration must be satisfied (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.3">8.3</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.4">8.4</a>).</p>
</div>
<h4 id="jls-8.10.4"><strong>8.10.4 Record Constructor Declarations</strong></h4>
<div class="inserted">
<p>To support proper initialization of its record components, a record type does not implicitly declare a default constructor (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.8.9">8.8.9</a>). Instead, a record type has a <em>canonical constructor</em>, declared either explicitly or implicitly, that initializes all of the fields corresponding to the record components.</p>
<p>A record type <em>R</em> has a <em>derived constructor signature</em>, with the name <em>R</em>, with no type parameters, and with a formal parameter list that is derived from the record component list of <em>R</em> as follows:</p>
<ul>
<li>For each record component in the record component list, a formal parameter with the same name and the declared type is derived. This formal parameter is annotated with the annotations, if any, that appear on the corresponding record component whose annotation types are applicable in the formal parameter context, or in type contexts, or both.</li>
</ul>
<p>A constructor declared in a record type <em>R</em> is said to be a canonical constructor if its signature is override-equivalent (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.4.2">8.4.2</a>) to the derived constructor signature of <em>R</em>.</p>
<blockquote>
<p>As a canonical constructor has a signature that is override-equivalent to the derived constructor signature of a record type, there can only be one explicitly declared canonical constructor.</p>
</blockquote>
<p>If a canonical constructor is explicitly declared, then it must additionally satisfy the following conditions; otherwise a compile-time error occurs:</p>
<ul>
<li><p>The types of the formal parameters in the formal parameter list of the canonical constructor must be identical to the declared type of the corresponding record component.</p></li>
<li><p>A canonical constructor must not be generic (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.8.4">8.8.4</a>).</p></li>
<li><p>A canonical constructor must be declared <code>public</code>.</p></li>
<li><p>A canonical constructor must not have a <code>throws</code> clause.</p></li>
<li><p>The body of a canonical constructor must not contain an explicit constructor invocation statement (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.8.7.1">8.8.7.1</a>).</p></li>
<li><p>All the other rules for a constructor in a normal class declaration must be satisfied (<a href="#jls-8.8">8.8</a>).</p></li>
</ul>
<blockquote>
<p>The requirement that the signature of an explicitly declared canonical constructor must be override-equivalent to the derived constructor signature means that the annotations on a record component can differ from the annotations on the corresponding formal parameter. For example, the following is valid:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb22-1" data-line-number="1">record <span class="fu">R</span>(<span class="at">@DevAnnotation</span>(<span class="st">&quot;devA&quot;</span>) <span class="bu">String</span> s) {</a>
<a class="sourceLine" id="cb22-2" data-line-number="2">  <span class="kw">public</span> <span class="fu">R</span>(<span class="at">@DevAnnotation</span>(<span class="st">&quot;devB&quot;</span>) <span class="bu">String</span> s) {</a>
<a class="sourceLine" id="cb22-3" data-line-number="3">    <span class="co">// Explicitly declared canonical constructor</span></a>
<a class="sourceLine" id="cb22-4" data-line-number="4">    ...</a>
<a class="sourceLine" id="cb22-5" data-line-number="5">  }</a>
<a class="sourceLine" id="cb22-6" data-line-number="6">}</a></code></pre></div>
</blockquote>
<p>If the canonical constructor is not explicitly declared, then one is implicitly declared with the following properties:</p>
<ul>
<li><p>The signature of the implicitly declared canonical constructor is given by the derived constructor signature for the record type.</p></li>
<li><p>The implicitly declared canonical constructor is declared <code>public</code>.</p></li>
<li><p>The implicitly declared canonical constructor does not have a <code>throws</code> clause.</p></li>
<li><p>The body of the implicitly declared canonical constructor initializes each field corresponding to a record component with the corresponding formal parameter in the order that they appear in the record component list.</p></li>
</ul>
<p>If a record type <em>R</em> declares constructors whose signatures are not override-equivalent to the derived constructor signature of <em>R</em>, then each constructor (if any) must satisfy all of the following; otherwise a compile-time error occurs:</p>
<ul>
<li><p>The constructor body must start with an explicit constructor invocation of another constructor of the record type <em>R</em> (including possibly the canonical constructor).</p></li>
<li><p>All the other rules for constructor declarations in a normal class declaration must be satisfied (<a href="#jls-8.8">8.8</a>).</p></li>
</ul>
<blockquote>
<p>These requirements enable us to talk of <em>the</em> canonical constructor for a record type <em>R</em>. In other words, every record type <em>R</em> has a single canonical constructor, declared explicitly or implicitly. This canonical constructor has the following properties:</p>
<ul>
<li>It is declared <code>public</code>.</li>
<li>It has no <code>throws</code> clause.</li>
<li>It is not generic.</li>
<li>Its signature is identical to the derived constructor signature of R (excluding any annotations).</li>
<li>The constructor body initializes every field corresponding to a record component from the record component list of <em>R</em>.</li>
</ul>
</blockquote>
</div>
<h4 id="jls-8.10.5"><strong>8.10.5 Compact Record Constructor Declarations</strong></h4>
<div class="inserted">
<p>A <em>compact constructor declaration</em> provides an alternative, succinct means to declare a canonical constructor for a record type.</p>
<dl>
<dt><em>CompactConstructorDeclaration</em>:</dt>
<dd>{ <em>Annotation</em> } { <em>ConstructorModifier</em> } <em>SimpleTypeName</em> <em>ConstructorBody</em>
</dd>
</dl>
<p>In a record type <em>R</em>, the signature of a compact constructor declaration is the derived constructor signature of <em>R</em> (<a href="#jls-8.10.4">8.10.4</a>).</p>
<blockquote>
<p>Unlike constructors in records, and indeed in classes in general, no explicit formal parameter list is given for a compact constructor, but is derived from the record component list.</p>
</blockquote>
<p>It is a compile-time error to declare more than one compact constructor declaration for a record type.</p>
<blockquote>
<p>The rules concerning signatures of constructors in class declarations (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.8.2">8.8.2</a>) mean that it is also a compile-time error if a record declaration contains a compact constructor declaration and a canonical constructor declaration. A compact constructor is a canonical constructor.</p>
</blockquote>
<p>A compact constructor declaration must satisfy all of the following conditions; otherwise a compile-time error occurs.</p>
<ul>
<li><p>The compact constructor must be declared <code>public</code>.</p></li>
<li><p>The body of a compact constructor must not contain a <code>return</code> statement (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-14.html#jls-14.17">14.17</a>).</p></li>
<li><p>The body of a compact constructor must not contain an explicit constructor invocation statement (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.8.7.1">8.8.7.1</a>).</p></li>
<li><p>All the other rules for a constructor in a normal class declaration must be satisfied (<a href="#jls-8.8">8.8</a>), except the requirement that the fields corresponding to the record components of <em>R</em> must be definitely assigned and moreover not definitely unassigned at the end of the compact constructor (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.3.1.2">8.3.1.2</a>).</p></li>
</ul>
<p>In addition, at the end of the body of the compact constructor, all the fields corresponding to the record components of <em>R</em> that are definitely unassigned (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-16.html">16</a> <em>(Definite Assignment)</em>) are implicitly initialized to the value of the corresponding formal parameter. These fields are implicitly initialized in the order that they are declared in the record component list.</p>
<blockquote>
<p>The intention of a compact constructor declaration is that only validation and/or normalization code need be given in the constructor body; the remaining initialization code is supplied by the compiler. Here are two simple examples:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb23-1" data-line-number="1">record <span class="fu">NonNegativePoint</span>(<span class="dt">int</span> i, <span class="dt">int</span> j) {</a>
<a class="sourceLine" id="cb23-2" data-line-number="2">  <span class="kw">public</span> NonNegativePoint {</a>
<a class="sourceLine" id="cb23-3" data-line-number="3">    <span class="co">// Validates that both components are non-negative</span></a>
<a class="sourceLine" id="cb23-4" data-line-number="4">    <span class="kw">if</span> ( i &lt; <span class="dv">0</span> || j &lt; <span class="dv">0</span> )</a>
<a class="sourceLine" id="cb23-5" data-line-number="5">      <span class="kw">throw</span> <span class="kw">new</span> <span class="bu">IllegalArgumentException</span>();</a>
<a class="sourceLine" id="cb23-6" data-line-number="6">  }</a>
<a class="sourceLine" id="cb23-7" data-line-number="7">}</a>
<a class="sourceLine" id="cb23-8" data-line-number="8"></a>
<a class="sourceLine" id="cb23-9" data-line-number="9">record <span class="fu">NonNullString</span>(<span class="dt">int</span> i, <span class="bu">String</span> s) {</a>
<a class="sourceLine" id="cb23-10" data-line-number="10">  <span class="kw">public</span> NonNullString {</a>
<a class="sourceLine" id="cb23-11" data-line-number="11">    <span class="co">// Normalizes the String component to be non-null</span></a>
<a class="sourceLine" id="cb23-12" data-line-number="12">    <span class="kw">if</span> ( s == <span class="kw">null</span>)</a>
<a class="sourceLine" id="cb23-13" data-line-number="13">      <span class="kw">this</span>.<span class="fu">s</span> = <span class="st">&quot;&quot;</span>;</a>
<a class="sourceLine" id="cb23-14" data-line-number="14">    <span class="kw">else</span></a>
<a class="sourceLine" id="cb23-15" data-line-number="15">      <span class="kw">this</span>.<span class="fu">s</span> = s;</a>
<a class="sourceLine" id="cb23-16" data-line-number="16">  }</a>
<a class="sourceLine" id="cb23-17" data-line-number="17">}</a></code></pre></div>
<p>These declarations are equivalent to the following:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb24-1" data-line-number="1">record <span class="fu">NonNegativePoint</span>(<span class="dt">int</span> i, <span class="dt">int</span> j) {</a>
<a class="sourceLine" id="cb24-2" data-line-number="2">  <span class="kw">public</span> NonNegativePoint {</a>
<a class="sourceLine" id="cb24-3" data-line-number="3">    <span class="co">// Validates that both components are non-negative</span></a>
<a class="sourceLine" id="cb24-4" data-line-number="4">    <span class="kw">if</span> ( i &lt; <span class="dv">0</span> || j &lt; <span class="dv">0</span> )</a>
<a class="sourceLine" id="cb24-5" data-line-number="5">      <span class="kw">throw</span> <span class="kw">new</span> <span class="bu">IllegalArgumentException</span>();</a>
<a class="sourceLine" id="cb24-6" data-line-number="6">    <span class="kw">this</span>.<span class="fu">i</span> = i;</a>
<a class="sourceLine" id="cb24-7" data-line-number="7">    <span class="kw">this</span>.<span class="fu">j</span> = j;</a>
<a class="sourceLine" id="cb24-8" data-line-number="8">  }</a>
<a class="sourceLine" id="cb24-9" data-line-number="9">}</a>
<a class="sourceLine" id="cb24-10" data-line-number="10"></a>
<a class="sourceLine" id="cb24-11" data-line-number="11">record <span class="fu">NonNullString</span>(<span class="dt">int</span> i, <span class="bu">String</span> s) {</a>
<a class="sourceLine" id="cb24-12" data-line-number="12">  <span class="kw">public</span> NonNullString {</a>
<a class="sourceLine" id="cb24-13" data-line-number="13">    <span class="co">// Normalizes the String component to be non-null</span></a>
<a class="sourceLine" id="cb24-14" data-line-number="14">    <span class="kw">if</span> ( s == <span class="kw">null</span>)</a>
<a class="sourceLine" id="cb24-15" data-line-number="15">      <span class="kw">this</span>.<span class="fu">s</span> = <span class="st">&quot;&quot;</span>;</a>
<a class="sourceLine" id="cb24-16" data-line-number="16">    <span class="kw">else</span></a>
<a class="sourceLine" id="cb24-17" data-line-number="17">      <span class="kw">this</span>.<span class="fu">s</span> = s;</a>
<a class="sourceLine" id="cb24-18" data-line-number="18">    <span class="kw">this</span>.<span class="fu">i</span> = i;</a>
<a class="sourceLine" id="cb24-19" data-line-number="19">  }</a>
<a class="sourceLine" id="cb24-20" data-line-number="20">}</a></code></pre></div>
</blockquote>
</div>
<h2 id="jls-9">Chapter 9: Interfaces</h2>
<h3 id="jls-9.6">9.6 Annotation Types</h3>
<h4 id="jls-9.6.4">9.6.4 Predefined Annotation Types</h4>
<h5 id="jls-9.6.4.1">9.6.4.1 <code>@Target</code></h5>
<p>An annotation of type <code>java.lang.annotation.Target</code> is used on the declaration of an annotation type <em>T</em> to specify the contexts in which <em>T</em> is <em>applicable</em>. <code>java.lang.annotation.Target</code> has a single element, <code>value</code>, of type <code>java.lang.annotation.ElementType[]</code>, to specify contexts.</p>
<p>Annotation types may be applicable in <em>declaration contexts</em>, where annotations apply to declarations, or in <em>type contexts</em>, where annotations apply to types used in declarations and expressions.</p>
<p>There are <del>nine</del> <strong>ten</strong> declaration contexts, each corresponding to an enum constant of <code>java.lang.annotation.ElementType</code>:</p>
<ol type="1">
<li><p>Module declarations (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-7.html#jls-7.7">7.7</a>)</p>
<p>Corresponds to <code>java.lang.annotation.ElementType.MODULE</code></p></li>
<li><p>Package declarations (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-7.html#jls-7.4.1">7.4.1</a>)</p>
<p>Corresponds to <code>java.lang.annotation.ElementType.PACKAGE</code></p></li>
<li><p>Type declarations: class, interface, enum, <strong>record,</strong> and annotation type declarations (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.1.1">8.1.1</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-9.html#jls-9.1.1">9.1.1</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.5">8.5</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-9.html#jls-9.5">9.5</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.9">8.9</a>, <strong><a href="#jls-8.10">8.10</a>,</strong> <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-9.html#jls-9.6">9.6</a>)</p>
<p>Corresponds to <code>java.lang.annotation.ElementType.TYPE</code></p>
<p>Additionally, annotation type declarations correspond to <code>java.lang.annotation.ElementType.ANNOTATION_TYPE</code></p></li>
<li><p>Method declarations (including elements of annotation types) (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.4.3">8.4.3</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-9.html#jls-9.4">9.4</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-9.html#jls-9.6.1">9.6.1</a>)</p>
<p>Corresponds to <code>java.lang.annotation.ElementType.METHOD</code></p></li>
<li><p>Constructor declarations (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.8.3">8.8.3</a>)</p>
<p>Corresponds to <code>java.lang.annotation.ElementType.CONSTRUCTOR</code></p></li>
<li><p>Type parameter declarations of generic classes, interfaces, methods, and constructors (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.1.2">8.1.2</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-9.html#jls-9.1.2">9.1.2</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.4.4">8.4.4</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.8.4">8.8.4</a>)</p>
<p>Corresponds to <code>java.lang.annotation.ElementType.TYPE_PARAMETER</code></p></li>
<li><p>Field declarations (including enum constants) (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.3.1">8.3.1</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-9.html#jls-9.3">9.3</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.9.1">8.9.1</a>)</p>
<p>Corresponds to <code>java.lang.annotation.ElementType.FIELD</code></p></li>
<li><p>Formal and exception parameter declarations (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.4.1">8.4.1</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-9.html#jls-9.4">9.4</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-14.html#jls-14.20">14.20</a>)</p>
<p>Corresponds to <code>java.lang.annotation.ElementType.PARAMETER</code></p></li>
<li><p>Local variable declarations (including loop variables of <code>for</code> statements and resource variables of <code>try</code>-with-resources statements) (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-14.html#jls-14.4">14.4</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-14.html#jls-14.14.1">14.14.1</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-14.html#jls-14.14.2">14.14.2</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-14.html#jls-14.20.3">14.20.3</a>)</p>
<p>Corresponds to <code>java.lang.annotation.ElementType.LOCAL_VARIABLE</code></p></li>
<li><p><strong>Record component declarations (<a href="#jls-8.10.1">8.10.1</a>)</strong></p>
<p><strong>Corresponds to <code>java.lang.annotation.ElementType.RECORD_COMPONENT</code></strong></p></li>
</ol>
<p>There are <del>16</del> <strong>17</strong> type contexts (<a href="#jls-4.11">4.11</a>), all represented by the enum constant <code>TYPE_USE</code> of <code>java.lang.annotation.ElementType</code>.</p>
<p>It is a compile-time error if the same enum constant appears more than once in the <code>value</code> element of an annotation of type <code>java.lang.annotation.Target</code>.</p>
<p>If an annotation of type <code>java.lang.annotation.Target</code> is not present on the declaration of an annotation type <em>T</em>, then <em>T</em> is applicable in all declaration contexts except type parameter declarations, and in no type contexts.</p>
<blockquote>
<p>These contexts are the syntactic locations where annotations were allowed in Java SE 7.</p>
</blockquote>
<h3 id="jls-9.7">9.7 Annotations</h3>
<h4 id="jls-9.7.4">9.7.4 Where Annotations May Appear</h4>
<p>A <em>declaration annotation</em> is an annotation that applies to a declaration, and whose own type is applicable in the declaration context (<a href="#jls-9.6.4.1">9.6.4.1</a>) represented by that declaration; or an annotation that applies to a class, interface, enum, <strong>record,</strong> annotation type, or type parameter declaration, and whose own type is applicable in type contexts (<a href="#jls-4.11">4.11</a>).</p>
<p>A <em>type annotation</em> is an annotation that applies to a type (or any part of a type), and whose own type is applicable in type contexts.</p>
<blockquote>
<p>For example, given the field declaration:</p>
<pre><code>@Foo int f;</code></pre>
<p><code>@Foo</code> is a declaration annotation on <code>f</code> if <code>Foo</code> is meta-annotated by <code>@Target(ElementType.FIELD)</code>, and a type annotation on <code>int</code> if <code>Foo</code> is meta-annotated by <code>@Target(ElementType.TYPE_USE)</code>. It is possible for <code>@Foo</code> to be both a declaration annotation and a type annotation simultaneously.</p>
<p>Type annotations can apply to an array type or any component type thereof (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-10.html#jls-10.1">10.1</a>). For example, assuming that <code>A</code>, <code>B</code>, and <code>C</code> are annotation types meta-annotated with <code>@Target(ElementType.TYPE_USE)</code>, then given the field declaration:</p>
<pre><code>@C int @A [] @B [] f;</code></pre>
<p><code>@A</code> applies to the array type <code>int[][]</code>, <code>@B</code> applies to its component type <code>int[]</code>, and <code>@C</code> applies to the element type <code>int</code>. For more examples, see <a href="#jls-10.2">10.2</a>.</p>
<p>An important property of this syntax is that, in two declarations that differ only in the number of array levels, the annotations to the left of the type refer to the same type. For example, <code>@C</code> applies to the type <code>int</code> in all of the following declarations:</p>
<pre><code>@C int f;
@C int[] f;
@C int[][] f;</code></pre>
</blockquote>
<blockquote>
<p>It is customary, though not required, to write declaration annotations before all other modifiers, and type annotations immediately before the type to which they apply.</p>
</blockquote>
<p>It is possible for an annotation to appear at a syntactic location in a program where it could plausibly apply to a declaration, or a type, or both. This can happen in any of the <del>five</del> <strong>six</strong> declaration contexts where modifiers immediately precede the type of the declared entity:</p>
<ul>
<li><p>Method declarations (including elements of annotation types)</p></li>
<li><p>Constructor declarations</p></li>
<li><p>Field declarations (including enum constants)</p></li>
<li><p>Formal and exception parameter declarations</p></li>
<li><p>Local variable declarations (including loop variables of <code>for</code> statements and resource variables of <code>try</code>-with-resources statements)</p></li>
<li><p><strong>Record component declarations</strong></p></li>
</ul>
<p>The grammar of the Java programming language unambiguously treats annotations at these locations as modifiers for a declaration (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.3">8.3</a>), but that is purely a syntactic matter. Whether an annotation applies to the declaration or to the type of the declared entity - and thus, whether the annotation is a <em>declaration annotation</em> or a <em>type annotation</em> - depends on the applicability of the annotation's type:</p>
<ul>
<li><p>If the annotation's type is applicable in the declaration context corresponding to the declaration, and not in type contexts, then the annotation is deemed to apply only to the declaration.</p></li>
<li><p>If the annotation's type is applicable in type contexts, and not in the declaration context corresponding to the declaration, then the annotation is deemed to apply only to the type which is closest to the annotation.</p></li>
<li><p>If the annotation's type is applicable in the declaration context corresponding to the declaration <em>and</em> in type contexts, then the annotation is deemed to apply to both the declaration <em>and</em> the type which is closest to the annotation.</p></li>
</ul>
<p>In the second and third cases above, the type which is <em>closest</em> to the annotation is determined as follows:</p>
<ul>
<li><p>If the annotation appears before a <code>void</code> method declaration or a local variable declaration that uses <code>var</code> (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-14.html#jls-14.4">14.4</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-14.html#jls-14.14.2">14.14.2</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-14.html#jls-14.20.3">14.20.3</a>), then there is no closest type. If the annotation's type is deemed to apply only to the type which is closest to the annotation, a compile-time error occurs.</p></li>
<li><p>If the annotation appears before a constructor declaration, then the closest type is the type of the newly constructed object. The type of the newly constructed object is the fully qualified name of the type immediately enclosing the constructor declaration. Within that fully qualified name, the annotation applies to the simple type name indicated by the constructor declaration.</p></li>
<li><p>In all other cases, the closest type is the type written in source code for the declared entity; if that type is an array type, then the element type is deemed to be closest to the annotation.</p>
<blockquote>
<p>For example, in the field declaration <code>@Foo public static String f;</code>, the type which is closest to <code>@Foo</code> is <code>String</code>. (If the type of the field declaration had been written as <code>java.lang.String</code>, then <code>java.lang.String</code> would be the type closest to <code>@Foo</code>, and later rules would prohibit a type annotation from applying to the package name <code>java</code>.) In the generic method declaration <code>@Foo &lt;T&gt; int[] m() {...}</code>, the type written for the declared entity is <code>int[]</code>, so <code>@Foo</code> applies to the element type <code>int</code>.</p>
</blockquote>
<blockquote>
<p>Local variable declarations which do not use <code>var</code> are similar to formal parameter declarations of lambda expressions, in that both allow declaration annotations and type annotations in source code, but only the type annotations can be stored in the <code>class</code> file.</p>
</blockquote></li>
</ul>
<p>It is a compile-time error if an annotation of type <em>T</em> is syntactically a modifier for:</p>
<ul>
<li><p>a module declaration, but <em>T</em> is not applicable to module declarations.</p></li>
<li><p>a package declaration, but <em>T</em> is not applicable to package declarations.</p></li>
<li><p>a class, interface, <del>or</del> enum<strong>, or record</strong> declaration, but <em>T</em> is not applicable to type declarations or type contexts; or an annotation type declaration, but <em>T</em> is not applicable to annotation type declarations or type declarations or type contexts.</p></li>
<li><p>a method declaration (including an element of an annotation type), but <em>T</em> is not applicable to method declarations or type contexts.</p></li>
<li><p>a constructor declaration, but <em>T</em> is not applicable to constructor declarations or type contexts.</p></li>
<li><p>a type parameter declaration of a generic class, interface, method, or constructor, but <em>T</em> is not applicable to type parameter declarations or type contexts.</p></li>
<li><p>a field declaration (including an enum constant), but <em>T</em> is not applicable to field declarations or type contexts.</p></li>
<li><p>a formal or exception parameter declaration, but <em>T</em> is not applicable to either formal and exception parameter declarations or type contexts.</p></li>
<li><p>a receiver parameter, but <em>T</em> is not applicable to type contexts.</p></li>
<li><p>a local variable declaration (including a loop variable of a <code>for</code> statement or a resource variable of a <code>try</code>-with-resources statement), but <em>T</em> is not applicable to local variable declarations or type contexts.</p></li>
<li><p><strong>a record component but <em>T</em> is not applicable to record component declarations, field declarations, method declarations, formal and exception parameter declarations, or type contexts.</strong></p></li>
</ul>
<blockquote>
<p><del>Five</del> <strong>Six</strong> of these <del>nine</del> <strong>eleven</strong> clauses mention &quot;... or type contexts&quot;because they characterize the <del>five</del> <strong>six</strong> syntactic locations where an annotation could plausibly apply either to a declaration or to the type of a declared entity. Furthermore, two of the <del>nine</del> <strong>eleven</strong> clauses - for class, interface, enum, <strong>record,</strong> and annotation type declarations, and for type parameter declarations - mention &quot;... or type contexts&quot; because it may be convenient to apply an annotation whose type is meta-annotated with <code>@Target(ElementType.TYPE_USE)</code> (thus, applicable in type contexts) to a type declaration.</p>
</blockquote>
<p>A type annotation is <em>admissible</em> if both of the following are true:</p>
<ul>
<li><p>The simple name to which the annotation is closest is classified as a <em>TypeName</em>, not a <em>PackageName</em>.</p></li>
<li><p>If the simple name to which the annotation is closest is followed by &quot;<code>.</code>&quot; and another <em>TypeName</em> - that is, the annotation appears as <code>@Foo T.U</code> - then <code>U</code> denotes an inner class of <code>T</code>.</p></li>
</ul>
<blockquote>
<p>The intuition behind the second clause is that if <code>Outer.this</code> is legal in a nested class enclosed by <code>Outer</code>, then <code>Outer</code> may be annotated because it represents the type of some object at run time. On the other hand, if <code>Outer.this</code> is not legal - because the class where it appears has no enclosing instance of <code>Outer</code> at run time - then <code>Outer</code> may not be annotated because it is logically just a name, akin to components of a package name in a fully qualified type name.</p>
</blockquote>
<blockquote>
<p>For example, in the following program, it is not possible to write <code>A.this</code> in the body of <code>B</code>, as <code>B</code> has no lexically enclosing instances (8.5.1). Therefore, it is not possible to apply <code>@Foo</code> to <code>A</code> in the type <code>A.B</code>, because <code>A</code> is logically just a name, not a type.</p>
<pre><code>@Target(ElementType.TYPE_USE)
@interface Foo {}

class Test {
  class A {
    static class B {}
  }

  @Foo A.B x;  // Illegal
}</code></pre>
<p>On the other hand, in the following program, it is possible to write <code>C.this</code> in the body of <code>D</code>. Therefore, it is possible to apply <code>@Foo</code> to <code>C</code> in the type <code>C.D</code>, because <code>C</code> represents the type of some object at run time.</p>
<pre><code>@Target(ElementType.TYPE_USE)
@interface Foo {}

class Test {
  static class C {
    class D {}
  }

  @Foo C.D x;  // Legal
}</code></pre>
<p>Finally, note that the second clause looks only one level deeper in a qualified type. This is because a <code>static</code> class may only be nested in a top level class or another <code>static</code> nested class. It is not possible to write a nest like:</p>
<pre><code>@Target(ElementType.TYPE_USE)
@interface Foo {}

class Test {
  class E {
    class F {
      static class G {}
    }
  }

  @Foo E.F.G x;
}</code></pre>
<p>Assume for a moment that the nest was legal. In the type of field <code>x</code>, <code>E</code> and <code>F</code> would logically be names qualifying <code>G</code>, as <code>E.F.this</code> would be illegal in the body of <code>G</code>. Then, <code>@Foo</code> should not be legal next to <code>E</code>. Technically, however, <code>@Foo</code> would be admissible next to <code>E</code> because the next deepest term <code>F</code> denotes an inner class; but this is moot as the class nest is illegal in the first place.</p>
</blockquote>
<p>It is a compile-time error if an annotation of type <em>T</em> applies to the outermost level of a type in a type context, and <em>T</em> is not applicable in type contexts or the declaration context (if any) which occupies the same syntactic location.</p>
<p>It is a compile-time error if an annotation of type <em>T</em> applies to a part of a type (that is, not the outermost level) in a type context, and <em>T</em> is not applicable in type contexts.</p>
<p>It is a compile-time error if an annotation of type <em>T</em> applies to a type (or any part of a type) in a type context, and <em>T</em> is applicable in type contexts, and the annotation is not admissible.</p>
<blockquote>
<p>For example, assume an annotation type <code>TA</code> which is meta-annotated with just <code>@Target(ElementType.TYPE_USE)</code>. The terms <code>@TA java.lang.Object</code> and <code>java.@TA lang.Object</code> are illegal because the simple name to which <code>@TA</code> is closest is classified as a package name. On the other hand, <code>java.lang.@TA Object</code> is legal.</p>
</blockquote>
<blockquote>
<p>Note that the illegal terms are illegal &quot;everywhere&quot;. The ban on annotating package names applies broadly: to locations which are solely type contexts, such as <code>class ... extends @TA java.lang.Object {...}</code>, and to locations which are both declaration and type contexts, such as <code>@TA java.lang.Object f;</code>. (There are no locations which are solely declaration contexts where a package name could be annotated, as class, package, and type parameter declarations use only simple names.)</p>
</blockquote>
<blockquote>
<p>If <code>TA</code> is additionally meta-annotated with <code>@Target(ElementType.FIELD)</code>, then the term <code>@TA java.lang.Object</code> is legal in locations which are both declaration and type contexts, such as a field declaration <code>@TA java.lang.Object f;</code>. Here, <code>@TA</code> is deemed to apply to the declaration of <code>f</code> (and not to the type <code>java.lang.Object</code>) because <code>TA</code> is applicable in the field declaration context.</p>
</blockquote>
<h2 id="jls-10">Chapter 10: Arrays</h2>
<h3 id="jls-10.2">10.2 Array Variables</h3>
<p>A variable of array type holds a reference to an object. Declaring a variable of array type does not create an array object or allocate any space for array components. It creates only the variable itself, which can contain a reference to an array. However, the initializer part of a declarator (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.3">8.3</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-9.html#jls-9.3">9.3</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-14.html#jls-14.4.1">14.4.1</a>) may create an array, a reference to which then becomes the initial value of the variable.</p>
<div class="example">
<p>Example 10.2-1. Declarations of Array Variables</p>
<pre><code>int[]     ai;        // array of int
short[][] as;        // array of array of short
short     s,         // scalar short
          aas[][];   // array of array of short
Object[]  ao,        // array of Object
          otherAo;   // array of Object
Collection&lt;?&gt;[] ca;  // array of Collection of unknown type</code></pre>
<p>The declarations above do not create array objects. The following are examples of declarations of array variables that do create array objects:</p>
<pre><code>Exception ae[]  = new Exception[3];
Object aao[][]  = new Exception[2][3];
int[] factorial = { 1, 1, 2, 6, 24, 120, 720, 5040 };
char ac[]       = { &#39;n&#39;, &#39;o&#39;, &#39;t&#39;, &#39; &#39;, &#39;a&#39;, &#39; &#39;,
                    &#39;S&#39;, &#39;t&#39;, &#39;r&#39;, &#39;i&#39;, &#39;n&#39;, &#39;g&#39; };
String[] aas    = { &quot;array&quot;, &quot;of&quot;, &quot;String&quot;, };</code></pre>
</div>
<p>The array type of a variable depends on the bracket pairs that may appear as part of the type at the beginning of a variable declaration, or as part of the declarator for the variable, or both. Specifically, in the declaration of a field, formal parameter, <del>or</del> local variable<strong>, or record component</strong> (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.3">8.3</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.4.1">8.4.1</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-9.html#jls-9.3">9.3</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-9.html#jls-9.4">9.4</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-14.html#jls-14.4.1">14.4.1</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-14.html#jls-14.14.2">14.14.2</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.27.1">15.27.1</a><strong>, <a href="#jls-8.10.1">8.10.1</a></strong>), the array type of the variable is denoted by:</p>
<ul>
<li><p>the element type that appears at the beginning of the declaration; then,</p></li>
<li><p>any bracket pairs that follow the variable's <em>Identifier</em> in the declarator (not applicable for a variable arity parameter); then,</p></li>
<li><p>any bracket pairs that appear in the type at the beginning of the declaration (where the ellipsis of a variable arity parameter is treated as a bracket pair).</p></li>
</ul>
<p>The return type of a method (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.4.5">8.4.5</a>) may be an array type. The precise array type depends on the bracket pairs that may appear as part of the type at the beginning of the method declaration, or after the method's formal parameter list, or both. The array type is denoted by:</p>
<ul>
<li><p>the element type that appears in the <em>Result</em>; then,</p></li>
<li><p>any bracket pairs that follow the formal parameter list; then,</p></li>
<li><p>any bracket pairs that appear in the <em>Result</em>.</p></li>
</ul>
<p>We do not recommend &quot;mixed notation&quot; in array variable declarations, where bracket pairs appear on both the type and in declarators; nor in method declarations, where bracket pairs appear both before and after the formal parameter list.</p>
<div class="example">
<p>Example 10.2-2. Array Variables and Array Types</p>
<p>The local variable declaration statement:</p>
<pre><code>byte[] rowvector, colvector, matrix[];</code></pre>
<p>is equivalent to:</p>
<pre><code>byte rowvector[], colvector[], matrix[][];</code></pre>
<p>because the array type of each local variable is unchanged. Similarly, the local variable declaration statement:</p>
<pre><code>int a, b[], c[][];</code></pre>
<p>is equivalent to the series of declaration statements:</p>
<pre><code>int a;
int[] b;
int[][] c;</code></pre>
<p>Brackets are allowed in declarators as a nod to the tradition of C and C++. The general rules for variable declaration, however, permit brackets to appear on both the type and in declarators, so that the local variable declaration statement:</p>
<pre><code>float[][] f[][], g[][][], h[];  // Yechh!</code></pre>
<p>is equivalent to the series of declarations:</p>
<pre><code>float[][][][] f;
float[][][][][] g;
float[][][] h;</code></pre>
<p>Because of how array types are formed, the following parameter declarations have the same array type:</p>
<pre><code>void m(int @A [] @B []  x) {}
void n(int @A [] @B ... y) {}</code></pre>
<p>And perhaps surprisingly, the following field declarations have the same array type:</p>
<pre><code>int @A [] f @B [];
int @B [] @A [] g;</code></pre>
</div>
<p>Once an array object is created, its length never changes. To make an array variable refer to an array of different length, a reference to a different array must be assigned to the variable.</p>
<p>A single variable of array type may contain references to arrays of different lengths, because an array's length is not part of its type.</p>
<p>If an array variable <em>v</em> has type <em>A</em><code>[]</code>, where <em>A</em> is a reference type, then <em>v</em> can hold a reference to an instance of any array type <em>B</em><code>[]</code>, provided <em>B</em> can be assigned to <em>A</em> (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-5.html#jls-5.2">5.2</a>). This may result in a run-time exception on a <em>later</em> assignment; see <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-10.html#jls-10.5">10.5</a> for a discussion.</p>
<h2 id="jls-13">Chapter 13: Binary Compatibility</h2>
<div class="editorial">
<p>A <a href="records-jvms.html">companion document</a> describes the changes needed to the <a href="https://docs.oracle.com/javase/specs/jvms/se13/html">Java Virtual Machine Specification</a> to support records.</p>
</div>
<h3 id="jls-13.1">13.1 The Form of a Binary</h3>
<p>Programs must be compiled either into the <code>class</code> file format specified by <em>The Java Virtual Machine Specification, Java SE 13 Edition</em>, or into a representation that can be mapped into that format by a class loader written in the Java programming language.</p>
<p>A <code>class</code> file corresponding to a class or interface declaration must have certain properties. A number of these properties are specifically chosen to support source code transformations that preserve binary compatibility. The required properties are:</p>
<ol type="1">
<li><p>The class or interface must be named by its <em>binary name</em>, which must meet the following constraints:</p>
<ul>
<li><p>The binary name of a top level type (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-7.html#jls-7.6">7.6</a>) is its canonical name (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-6.html#jls-6.7">6.7</a>).</p></li>
<li><p>The binary name of a member type (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.5">8.5</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-9.html#jls-9.5">9.5</a>) consists of the binary name of its immediately enclosing type, followed by <code>$</code>, followed by the simple name of the member.</p></li>
<li><p>The binary name of a local class (<a href="#jls-14.3">14.3</a>) consists of the binary name of its immediately enclosing type, followed by <code>$</code>, followed by a non-empty sequence of digits, followed by the simple name of the local class.</p></li>
<li><p>The binary name of an anonymous class (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.9.5">15.9.5</a>) consists of the binary name of its immediately enclosing type, followed by <code>$</code>, followed by a non-empty sequence of digits.</p></li>
<li><p>The binary name of a type variable declared by a generic class or interface (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.1.2">8.1.2</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-9.html#jls-9.1.2">9.1.2</a>) is the binary name of its immediately enclosing type, followed by <code>$</code>, followed by the simple name of the type variable.</p></li>
<li><p>The binary name of a type variable declared by a generic method (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.4.4">8.4.4</a>) is the binary name of the type declaring the method, followed by <code>$</code>, followed by the descriptor of the method (JVMS §4.3.3), followed by <code>$</code>, followed by the simple name of the type variable.</p></li>
<li><p>The binary name of a type variable declared by a generic constructor (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.8.4">8.8.4</a>) is the binary name of the type declaring the constructor, followed by <code>$</code>, followed by the descriptor of the constructor (JVMS §4.3.3), followed by <code>$</code>, followed by the simple name of the type variable.</p></li>
</ul></li>
<li><p>A reference to another class or interface type must be symbolic, using the binary name of the type.</p></li>
<li><p>A reference to a field that is a constant variable (<a href="#jls-4.12.4">4.12.4</a>) must be resolved at compile time to the value <em>V</em> denoted by the constant variable's initializer.</p>
<p>If such a field is <code>static</code>, then no reference to the field should be present in the code in a binary file, including the class or interface which declared the field. Such a field must always appear to have been initialized (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-12.html#jls-12.4.2">12.4.2</a>); the default initial value for the field (if different than <em>V</em>) must never be observed.</p>
<p>If such a field is non-<code>static</code>, then no reference to the field should be present in the code in a binary file, except in the class containing the field. (It will be a class rather than an interface, since an interface has only <code>static</code> fields.) The class should have code to set the field's value to <em>V</em> during instance creation (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-12.html#jls-12.5">12.5</a>).</p></li>
<li><p>Given a legal expression denoting a field access in a class <em>C</em>, referencing a field named <em>f</em> that is not a constant variable and is declared in a (possibly distinct) class or interface <em>D</em>, we define the <em>qualifying type of the field reference</em> as follows:</p>
<ul>
<li><p>If the expression is referenced by a simple name, then if <em>f</em> is a member of the current class or interface, <em>C</em>, then let <em>T</em> be <em>C</em>. Otherwise, let <em>T</em> be the innermost lexically enclosing type declaration of which <em>f</em> is a member. In either case, <em>T</em> is the qualifying type of the reference.</p></li>
<li><p>If the reference is of the form <em>TypeName</em><code>.</code><em>f</em>, where <em>TypeName</em> denotes a class or interface, then the class or interface denoted by <em>TypeName</em> is the qualifying type of the reference.</p></li>
<li><p>If the expression is of the form <em>ExpressionName</em><code>.</code><em>f</em> or <em>Primary</em><code>.</code><em>f</em>, then:</p>
<ul>
<li><p>If the compile-time type of <em>ExpressionName</em> or <em>Primary</em> is an intersection type <em>V<sub>1</sub></em> <code>&amp;</code> ... <code>&amp;</code> <em>V<sub>n</sub></em> (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-4.html#jls-4.9">4.9</a>), then the qualifying type of the reference is <em>V<sub>1</sub></em>.</p></li>
<li><p>Otherwise, the compile-time type of <em>ExpressionName</em> or <em>Primary</em> is the qualifying type of the reference.</p></li>
</ul></li>
<li><p>If the expression is of the form <code>super.</code><em>f</em>, then the superclass of <em>C</em> is the qualifying type of the reference.</p></li>
<li><p>If the expression is of the form <em>TypeName</em><code>.super.</code><em>f</em>, then the superclass of the class denoted by <em>TypeName</em> is the qualifying type of the reference.</p></li>
</ul>
<p>The reference to <em>f</em> must be compiled into a symbolic reference to the erasure (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-4.html#jls-4.6">4.6</a>) of the qualifying type of the reference, plus the simple name of the field, <em>f</em>. The reference must also include a symbolic reference to the erasure of the declared type of the field so that the verifier can check that the type is as expected.</p></li>
<li><p>Given a method invocation expression or a method reference expression in a class or interface <em>C</em>, referencing a method named <em>m</em> declared (or implicitly declared (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-9.html#jls-9.2">9.2</a>)) in a (possibly distinct) class or interface <em>D</em>, we define the <em>qualifying type of the method invocation</em> as follows:</p>
<ul>
<li><p>If <em>D</em> is <code>Object</code> then the qualifying type of the expression is <code>Object</code>.</p></li>
<li><p>Otherwise:</p>
<ul>
<li><p>If the method is referenced by a simple name, then if <em>m</em> is a member of the current class or interface <em>C</em>, let <em>T</em> be <em>C</em>; otherwise, let <em>T</em> be the innermost lexically enclosing type declaration of which <em>m</em> is a member. In either case, <em>T</em> is the qualifying type of the method invocation.</p></li>
<li><p>If the expression is of the form <em>TypeName</em><code>.</code><em>m</em> or <em>ReferenceType</em><code>::</code><em>m</em>, then the type denoted by <em>TypeName</em> or <em>ReferenceType</em> is the qualifying type of the method invocation.</p></li>
<li><p>If the expression is of the form <em>ExpressionName</em><code>.</code><em>m</em> or <em>Primary</em><code>.</code><em>m</em> or <em>ExpressionName</em><code>::</code><em>m</em> or <em>Primary</em><code>::</code><em>m</em>, then:</p>
<ul>
<li><p>If the compile-time type of <em>ExpressionName</em> or <em>Primary</em> is an intersection type <em>V<sub>1</sub></em> <code>&amp;</code> ... <code>&amp;</code> <em>V<sub>n</sub></em> (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-4.html#jls-4.9">4.9</a>), then the qualifying type of the method invocation is <em>V<sub>1</sub></em>.</p></li>
<li><p>Otherwise, the compile-time type of <em>ExpressionName</em> or <em>Primary</em> is the qualifying type of the method invocation.</p></li>
</ul></li>
<li><p>If the expression is of the form <code>super.</code><em>m</em> or <code>super::</code><em>m</em>, then the superclass of <em>C</em> is the qualifying type of the method invocation.</p></li>
<li><p>If the expression is of the form <em>TypeName</em><code>.super.</code><em>m</em> or <em>TypeName</em><code>.super::</code><em>m</em>, then if <em>TypeName</em> denotes a class <em>X</em>, the superclass of <em>X</em> is the qualifying type of the method invocation; if <em>TypeName</em> denotes an interface <em>X</em>, <em>X</em> is the qualifying type of the method invocation.</p></li>
</ul></li>
</ul>
<p>A reference to a method must be resolved at compile time to a symbolic reference to the erasure (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-4.html#jls-4.6">4.6</a>) of the qualifying type of the invocation, plus the erasure of the signature (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.4.2">8.4.2</a>) of the method. The signature of a method must include all of the following as determined by <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.12.3">15.12.3</a>:</p>
<ul>
<li><p>The simple name of the method</p></li>
<li><p>The number of parameters to the method</p></li>
<li><p>A symbolic reference to the type of each parameter</p></li>
</ul>
<p>A reference to a method must also include either a symbolic reference to the erasure of the return type of the denoted method or an indication that the denoted method is declared <code>void</code> and does not return a value.</p></li>
<li><p>Given a class instance creation expression (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.9">15.9</a>) or an explicit constructor invocation statement (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.8.7.1">8.8.7.1</a>) or a method reference expression of the form <em>ClassType <code>::</code> <code>new</code></em> (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.13">15.13</a>) in a class or interface <em>C</em> referencing a constructor <em>m</em> declared in a (possibly distinct) class or interface <em>D</em>, we define the qualifying type of the constructor invocation as follows:</p>
<ul>
<li><p>If the expression is of the form <code>new</code> <em>D</em><code>(...)</code> or <em>ExpressionName</em><code>.new</code> <em>D</em><code>(...)</code> or <em>Primary</em><code>.new</code> <em>D</em><code>(...)</code> or <em>D</em> <code>::</code> <code>new</code>, then the qualifying type of the invocation is <em>D</em>.</p></li>
<li><p>If the expression is of the form <code>new</code> <em>D</em><code>(...){...}</code> or <em>ExpressionName</em><code>.new</code> <em>D</em><code>(...){...}</code> or <em>Primary</em><code>.new</code> <em>D</em><code>(...){...}</code>, then the qualifying type of the expression is the compile-time type of the expression.</p></li>
<li><p>If the expression is of the form <code>super(...)</code> or <em>ExpressionName</em><code>.super(...)</code> or <em>Primary</em><code>.super(...)</code>, then the qualifying type of the expression is the direct superclass of <em>C</em>.</p></li>
<li><p>If the expression is of the form <code>this(...)</code>, then the qualifying type of the expression is <em>C</em>.</p></li>
</ul>
<p>A reference to a constructor must be resolved at compile time to a symbolic reference to the erasure (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-4.html#jls-4.6">4.6</a>) of the qualifying type of the invocation, plus the signature of the constructor (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.8.2">8.8.2</a>). The signature of a constructor must include both:</p>
<ul>
<li><p>The number of parameters of the constructor</p></li>
<li><p>A symbolic reference to the type of each formal parameter</p></li>
</ul></li>
</ol>
<p>A binary representation for a class or interface must also contain all of the following:</p>
<ol type="1">
<li><p>If it is a class and is not <code>Object</code>, then a symbolic reference to the erasure of the direct superclass of this class.</p></li>
<li><p>A symbolic reference to the erasure of each direct superinterface, if any.</p></li>
<li><p>A specification of each field declared in the class or interface, given as the simple name of the field and a symbolic reference to the erasure of the type of the field.</p></li>
<li><p>If it is a class, then the erased signature of each constructor, as described above.</p></li>
<li><p>For each method declared in the class or interface (excluding, for an interface, its implicitly declared methods (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-9.html#jls-9.2">9.2</a>)), its erased signature and return type, as described above.</p></li>
<li><p>The code needed to implement the class or interface:</p>
<ul>
<li><p>For an interface, code for the field initializers and the implementation of each method with a block body (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-9.html#jls-9.4.3">9.4.3</a>).</p></li>
<li><p>For a class, code for the field initializers, the instance and static initializers, the implementation of each method with a block body (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.4.7">8.4.7</a>), and the implementation of each constructor.</p></li>
</ul></li>
<li><p>Every type must contain sufficient information to recover its canonical name (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-6.html#jls-6.7">6.7</a>).</p></li>
<li><p>Every member type must have sufficient information to recover its source-level access modifier.</p></li>
<li><p>Every nested class and nested interface must have a symbolic reference to its immediately enclosing type (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.1.3">8.1.3</a>).</p></li>
<li><p>Every class must contain symbolic references to all of its member types (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.5">8.5</a>), and to all local and anonymous classes that appear in its methods, constructors, static initializers, instance initializers, and field initializers.</p>
<p>Every interface must contain symbolic references to all of its member types (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-9.html#jls-9.5">9.5</a>), and to all local and anonymous classes that appear in its default methods and field initializers.</p></li>
<li><p>A construct emitted by a Java compiler must be marked as <em>synthetic</em> if it does not correspond to a construct declared explicitly or implicitly in source code, unless the emitted construct is a class initialization method (JVMS §2.9).</p></li>
<li><p>A construct emitted by a Java compiler must be marked as <em>mandated</em> if it corresponds to a formal parameter declared implicitly in source code (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.8.1">8.8.1</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.8.9">8.8.9</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.9.3">8.9.3</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.9.5.1">15.9.5.1</a>).</p></li>
</ol>
<blockquote>
<p>The following formal parameters are declared implicitly in source code:</p>
</blockquote>
<blockquote>
<ul>
<li><p>The first formal parameter of a constructor of a non-<code>private</code> inner member class (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.8.1">8.8.1</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.8.9">8.8.9</a>).</p></li>
<li><p>The first formal parameter of an anonymous constructor of an anonymous class whose superclass is inner or local (not in a static context) (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.9.5.1">15.9.5.1</a>).</p></li>
<li><p>The formal parameter <code>name</code> of the <code>valueOf</code> method which is implicitly declared in an enum type (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.9.3">8.9.3</a>).</p></li>
<li><p><strong>The formal parameters of a compact constructor of a record type ( <a href="#jls-8.10.5">8.10.5</a>).</strong></p></li>
</ul>
</blockquote>
<blockquote>
<p>For reference, the following constructs are declared implicitly in source code, but are not marked as mandated because only formal parameters can be so marked in a <code>class</code> file (JVMS §4.7.24):</p>
</blockquote>
<blockquote>
<ul>
<li><p>Default constructors of classes and enum types (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.8.9">8.8.9</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.9.2">8.9.2</a>)</p></li>
<li><p><strong>Canonical constructors of record types (<a href="#jls-8.10.4">8.10.4</a>)</strong></p></li>
<li><p>Anonymous constructors (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.9.5.1">15.9.5.1</a>)</p></li>
<li><p>The <code>values</code> and <code>valueOf</code> methods of enum types (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.9.3">8.9.3</a>)</p></li>
<li><p>Certain <code>public</code> fields of enum types (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.9.3">8.9.3</a>)</p></li>
<li><p><strong>Certain <code>private</code> fields and <code>public</code> methods of record types (<a href="#jls-8.10.3">8.10.3</a>)</strong></p></li>
<li><p>Certain <code>public</code> methods of interfaces (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-9.html#jls-9.2">9.2</a>)</p></li>
<li><p>Container annotations (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-9.html#jls-9.7.5">9.7.5</a>)</p></li>
</ul>
</blockquote>
<p>A <code>class</code> file corresponding to a module declaration must have the properties of a <code>class</code> file for a class whose binary name is <code>module-info</code> and which has no superclass, no superinterfaces, no fields, and no methods. In addition, the binary representation of the module must contain all of the following:</p>
<ul>
<li><p>A specification of the name of the module, given as a symbolic reference to the name indicated after <code>module</code>. Also, the specification must include whether the module is normal or open (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-7.html#jls-7.7">7.7</a>).</p></li>
<li><p>A specification of each dependence denoted by a <code>requires</code> directive, given as a symbolic reference to the name of the module indicated by the directive (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-7.html#jls-7.7.">7.7.1</a>). Also, the specification must include whether the dependence is <code>transitive</code> and whether the dependence is <code>static</code>.</p></li>
<li><p>A specification of each package denoted by an <code>exports</code> or <code>opens</code> directive, given as a symbolic reference to the name of the package indicated by the directive (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-7.html#jls-7.7.2">7.7.2</a>). Also, if the directive was qualified, the specification must give symbolic references to the names of the modules indicated by the directive's <code>to</code> clause.</p></li>
<li><p>A specification of each service denoted by a <code>uses</code> directive, given as a symbolic reference to the name of the type indicated by the directive (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-7.html#jls-7.7.3">7.7.3</a>).</p></li>
<li><p>A specification of the service providers denoted by a <code>provides</code> directive, given as symbolic references to the names of the types indicated by the directive's <code>with</code> clause (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-7.html#jls-7.7.4">7.7.4</a>). Also, the specification must give a symbolic reference to the name of the type indicated as the service by the directive.</p></li>
</ul>
<p>The following sections discuss changes that may be made to class and interface type declarations without breaking compatibility with pre-existing binaries. Under the translation requirements given above, the Java Virtual Machine and its <code>class</code> file format support these changes. Any other valid binary format, such as a compressed or encrypted representation that is mapped back into <code>class</code> files by a class loader under the above requirements, will necessarily support these changes as well.</p>
<h3 id="jls-13.4">13.4 Evolution of Classes</h3>
<h4 id="jls-13.4.27"><strong>13.4.27 Evolution of Records</strong></h4>
<div class="editorial">
<p>This is a new subsection</p>
</div>
<div class="inserted">
<p>Adding, deleting, changing, or reordering record components in a record declaration may break compatibility with pre-existing binaries, resulting in a linkage time error, namely an <code>IncompatibleClassChangeError</code>.</p>
<p>If a pre-existing binary attempts to access a record component that no longer exists, the client will fail at run time with a <code>NoSuchFieldError</code>. Therefore such a change is not recommended for widely distributed records.</p>
<p>In all other respects, the binary compatibility rules for records are identical to those for classes.</p>
</div>
<h2 id="jls-14">Chapter 14: Blocks and Statements</h2>
<h3 id="jls-14.2">14.2 Blocks</h3>
<p><del>A <em>block</em> is a sequence of statements, local class declarations, and local variable declaration statements within braces.</del></p>
<p><strong>A <em>block</em> is a sequence of statements and declarations within braces. Local variable declaration statements are an important kind of statement because they introduce names into scope. The declarations that appear in a block may be of classes and records (but not enums); these declarations are known as <em>local classes</em> and <em>local records</em>.</strong></p>
<dl>
<dt><em>Block:</em></dt>
<dd><code>{</code> [<em>BlockStatements</em>] <code>}</code>
</dd>
<dt><em>BlockStatements:</em></dt>
<dd><em>BlockStatement</em> {<em>BlockStatement</em>}
</dd>
<dt><em>BlockStatement:</em></dt>
<dd><em>LocalVariableDeclarationStatement</em>
</dd>
<dd><del><em>ClassDeclaration</em></del> <strong><em>NormalClassDeclaration</em></strong>
</dd>
<dd><strong><em>RecordDeclaration</em></strong>
</dd>
<dd><em>Statement</em>
</dd>
</dl>
<p>A block is executed by executing each of the local variable declaration statements and other statements in order from first to last (left to right). If all of these block statements complete normally, then the block completes normally. If any of these block statements complete abruptly for any reason, then the block completes abruptly for the same reason.</p>
<h3 id="jls-14.3">14.3 Local Class Declarations</h3>
<p><strong>A local class declaration is the declaration of either a local class or a local record (but not an enum).</strong></p>
<p>A <em>local class</em> is a nested class (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html">8</a>) that is not a member of any class and that has a name (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-6.html#jls-6.2">6.2</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-6.html#jls-6.7">6.7</a>).</p>
<p>All local classes are inner classes (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.1.3">8.1.3</a>).</p>
<div class="inserted">
<p>A <em>local record</em> is a record type declaration (<a href="#jls-8.10">8.10</a>) that is not a member of a class. A local record is implicitly <code>static</code>. A local record is not a local class.</p>
<p>It is a compile-time error if a local record contains a usage of a variable declared in the enclosing block.</p>
<blockquote>
<p>Local records are constrained with regards to with variables they can access. The fact that a local record is implicitly <code>static</code> means that it is a compile-time error if a local record uses a non-<code>static</code> member of an enclosing class. It is permitted to use a <code>static</code> member of an enclosing class. Here is an example to illustrate the constraints.</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb41-1" data-line-number="1"><span class="kw">class</span> LocalRecordTest {</a>
<a class="sourceLine" id="cb41-2" data-line-number="2">    <span class="dt">static</span> <span class="dt">int</span> si;</a>
<a class="sourceLine" id="cb41-3" data-line-number="3">    <span class="dt">int</span> nsi;</a>
<a class="sourceLine" id="cb41-4" data-line-number="4"></a>
<a class="sourceLine" id="cb41-5" data-line-number="5">    <span class="dt">void</span> <span class="fu">m</span>() {</a>
<a class="sourceLine" id="cb41-6" data-line-number="6">        <span class="dt">int</span> li;</a>
<a class="sourceLine" id="cb41-7" data-line-number="7"></a>
<a class="sourceLine" id="cb41-8" data-line-number="8">        record <span class="fu">R</span>(<span class="dt">int</span> r) {</a>
<a class="sourceLine" id="cb41-9" data-line-number="9">            <span class="dt">void</span> <span class="fu">print</span>() {</a>
<a class="sourceLine" id="cb41-10" data-line-number="10">                <span class="bu">System</span>.<span class="fu">out</span>.<span class="fu">println</span>(si);  <span class="co">// ok, static member of enclosing class</span></a>
<a class="sourceLine" id="cb41-11" data-line-number="11">                <span class="bu">System</span>.<span class="fu">out</span>.<span class="fu">println</span>(nsi); <span class="co">// error, non-static member</span></a>
<a class="sourceLine" id="cb41-12" data-line-number="12">                <span class="bu">System</span>.<span class="fu">out</span>.<span class="fu">println</span>(li);  <span class="co">// error, local variable</span></a>
<a class="sourceLine" id="cb41-13" data-line-number="13">            }</a>
<a class="sourceLine" id="cb41-14" data-line-number="14">        }</a>
<a class="sourceLine" id="cb41-15" data-line-number="15">    }</a>
<a class="sourceLine" id="cb41-16" data-line-number="16">}</a></code></pre></div>
</blockquote>
</div>
<p>Every local class declaration statement is immediately contained by a block (<a href="#jls-14.2">14.2</a>). Local class declaration statements may be intermixed freely with other kinds of statements in the block.</p>
<p>It is a compile-time error if a local class declaration contains any of the access modifiers <code>public</code>, <code>protected</code>, or <code>private</code> (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-6.html#jls-6.6">6.6</a>), or<strong>, if it is not a local record,</strong> the modifier <code>static</code> (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.1.1">8.1.1</a>).</p>
<p>The scope and shadowing of a local class declaration is specified in <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-6.html#jls-6.3">6.3</a> and <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-6.html#jls-6.4">6.4</a>.</p>
<div class="example">
<p>Example 14.3-1. Local Class <del>Declarations</del></p>
<p>Here is an example that illustrates several aspects of the rules given above <strong>regarding local classes</strong>:</p>
<pre><code>class Global {
    class Cyclic {}

    void foo() {
        new Cyclic(); // create a Global.Cyclic
        class Cyclic extends Cyclic {} // circular definition

        {
            class Local {}
            {
                class Local {} // compile-time error
            }
            class Local {} // compile-time error
            class AnotherLocal {
                void bar() {
                    class Local {} // ok
                }
            }
        }
        class Local {} // ok, not in scope of prior Local
    }
}</code></pre>
<p>The first statement of method <code>foo</code> creates an instance of the member class <code>Global.Cyclic</code> rather than an instance of the local class <code>Cyclic</code>, because the statement appears prior to the scope of the local class declaration.</p>
<p>The fact that the scope of a local class declaration encompasses its whole declaration (not only its body) means that the definition of the local class <code>Cyclic</code> is indeed cyclic because it extends itself rather than <code>Global.Cyclic</code>. Consequently, the declaration of the local class <code>Cyclic</code> is rejected at compile time.</p>
<p>Since local class names cannot be redeclared within the same method (or constructor or initializer, as the case may be), the second and third declarations of <code>Local</code> result in compile-time errors. However, <code>Local</code> can be redeclared in the context of another, more deeply nested, class such as <code>AnotherLocal</code>.</p>
<p>The final declaration of <code>Local</code> is legal, since it occurs outside the scope of any prior declaration of <code>Local</code>.</p>
</div>
</main><footer class="legal-footer"><hr/><a href="../legal/copyright.html">Copyright</a> &copy; 1993, 2020, Oracle and/or its affiliates, 500 Oracle Parkway, Redwood Shores, CA 94065 USA.<br>All rights reserved. Use is subject to <a href="https://www.oracle.com/technetwork/java/javase/terms/license/java14.0.2speclicense.html">license terms</a> and the <a href="https://www.oracle.com/technetwork/java/redist-137594.html">documentation redistribution policy</a>. <!-- Version 14.0.2+12-46 --></footer>
</body>
</html>