<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc,fixuphtml" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Pattern matching for instanceof</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <link rel="stylesheet" href="../resources/jdk-default.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  <link rel="stylesheet" href="../resources/spec-changes.css" />
</head>
<body>
<header id="title-block-header">
<h1 class="title">Pattern matching for <code>instanceof</code></h1>
<p class="subtitle">Changes to the Java® Language Specification • Version 14.0.2+12-46</p>
</header>
<nav id="TOC" title="Table Of Contents">
<ul>
<li><a href="#jls-1">Chapter 1: Introduction</a><ul>
<li><a href="#jls-1.1">1.1 Organization of the Specification</a></li>
</ul></li>
<li><a href="#jls-4">Chapter 4: Types, Values, and Variables</a><ul>
<li><a href="#jls-4.11">4.11 Where Types Are Used</a></li>
<li><a href="#jls-4.12">4.12 Variables</a><ul>
<li><a href="#jls-4.12.3">4.12.3 Kinds of Variables</a></li>
<li><a href="#jls-4.12.4">4.12.4 <code>final</code> Variables</a></li>
<li><a href="#jls-4.12.5">4.12.5 Initial Values of Variables</a></li>
</ul></li>
</ul></li>
<li><a href="#jls-5">Chapter 5: Conversions and Contexts</a><ul>
<li><a href="#jls-5.5">5.5 Casting Contexts</a></li>
</ul></li>
<li><a href="#jls-6">Chapter 6: Names</a><ul>
<li><a href="#jls-6.1">6.1 Declarations</a></li>
<li><a href="#jls-6.3">6.3 Scope of a Declaration</a><ul>
<li><a href="#jls-6.3.1"><strong>6.3.1 Pattern Declaration Scopes and Expressions</strong></a><ul>
<li><a href="#jls-6.3.1.1"><strong>6.3.1.1 Conditional-And Operator <code>&amp;&amp;</code></strong></a></li>
<li><a href="#jls-6.3.1.2"><strong>6.3.1.2 Conditional-Or Operator <code>||</code></strong></a></li>
<li><a href="#jls-6.3.1.3"><strong>6.3.1.3 Logical Complement Operator <code>!</code></strong></a></li>
<li><a href="#jls-6.3.1.4"><strong>6.3.1.4 Conditional Operator <code>? :</code></strong></a></li>
<li><a href="#jls-6.3.1.5"><strong>6.3.1.5 <code>instanceof</code> Operator</strong></a></li>
</ul></li>
<li><a href="#jls-6.3.2"><strong>6.3.2 Pattern Declaration Scopes and Statements</strong></a><ul>
<li><a href="#jls-6.3.2.1"><strong>6.3.2.1 Blocks</strong></a></li>
<li><a href="#jls-6.3.2.2"><strong>6.3.2.2 <code>if</code> Statements</strong></a></li>
<li><a href="#jls-6.3.2.3"><strong>6.3.2.3 <code>while</code> Statements</strong></a></li>
<li><a href="#jls-6.3.2.4"><strong>6.3.2.4 <code>do</code> Statements</strong></a></li>
<li><a href="#jls-6.3.2.5"><strong>6.3.2.5 <code>for</code> Statements</strong></a></li>
<li><a href="#jls-6.3.2.6"><strong>6.3.2.6 <code>switch</code> Statements</strong></a></li>
</ul></li>
</ul></li>
<li><a href="#jls-6.4">6.4 Shadowing and Obscuring</a><ul>
<li><a href="#jls-6.4.1">6.4.1 Shadowing</a></li>
</ul></li>
<li><a href="#jls-6.5">6.5 Determining the Meaning of a Name</a><ul>
<li><a href="#jls-6.5.1">6.5.1 Syntactic Classification of a Name According to Context</a></li>
<li><a href="#jls-6.5.2">6.5.2 Reclassification of Contextually Ambiguous Names</a></li>
<li><a href="#jls-6.5.6">6.5.6 Meaning of Expression Names</a><ul>
<li><a href="#jls-6.5.6.1">6.5.6.1 Simple Expression Names</a></li>
</ul></li>
</ul></li>
</ul></li>
<li><a href="#jls-9">Chapter 9: Interfaces</a><ul>
<li><a href="#jls-9.6">9.6 Annotation Types</a><ul>
<li><a href="#jls-9.6.4">9.6.4 Predefined Annotation Types</a><ul>
<li><a href="#jls-9.6.4.1">9.6.4.1 <code>@Target</code></a></li>
</ul></li>
</ul></li>
</ul></li>
<li><a href="#jls-14">Chapter 14: <del>Blocks and</del> Statements <strong>and Patterns</strong></a><ul>
<li><a href="#jls-14.30"><strong>14.30 Patterns</strong></a><ul>
<li><a href="#jls-14.30.1"><strong>14.30.1 Kinds of Patterns</strong></a><ul>
<li><a href="#jls-14.30.1.1"><strong>14.30.1.1 Type Test Pattern</strong></a></li>
</ul></li>
<li><a href="#jls-14.30.2"><strong>14.30.2 Compatibility of an Expression with a Pattern</strong></a></li>
<li><a href="#jls-14.30.3"><strong>14.30.3 Execution of Pattern Matching</strong></a></li>
</ul></li>
</ul></li>
<li><a href="#jls-15">Chapter 15: Expressions</a><ul>
<li><a href="#jls-15.20">15.20 Relational Operators</a><ul>
<li><a href="#jls-15.20.2">15.20.2 <del>Type Comparison Operator <code>instanceof</code></del> <strong>The <code>instanceof</code> Operator</strong></a></li>
</ul></li>
</ul></li>
</ul>
</nav>
<main><p>This document describes changes to the <a href="https://docs.oracle.com/javase/specs/jls/se13/html">Java Language Specification</a> to support <em>pattern matching</em> in <code>instanceof</code> expressions, a preview feature of Java SE 14. See <a href="https://openjdk.java.net/jeps/305">JEP 305</a> for an overview of the feature.</p>
<p>Changes are described with respect to existing sections of the JLS. New text is indicated <strong>like this</strong> and deleted text is indicated <del>like this</del>. Explanation and discussion, as needed, is set aside in grey boxes.</p>
<h2 id="jls-1">Chapter 1: Introduction</h2>
<h3 id="jls-1.1">1.1 Organization of the Specification</h3>
<p>...</p>
<p>Chapter 14 describes <del>blocks and</del> statements, which are based on C and C++<strong>, and patterns, which provide a means for describing the shape of data</strong>. The language has no <code>goto</code> statement, but includes labeled <code>break</code> and <code>continue</code> statements. Unlike C, the Java programming language requires <code>boolean</code> (or <code>Boolean</code>) expressions in control-flow statements, and does not convert types to <code>boolean</code> implicitly (except through unboxing), in the hope of catching more errors at compile time. A <code>synchronized</code> statement provides basic object-level monitor locking. A <code>try</code> statement can include <code>catch</code> and <code>finally</code> clauses to protect against non-local control transfers.</p>
<p>...</p>
<h2 id="jls-4">Chapter 4: Types, Values, and Variables</h2>
<h3 id="jls-4.11">4.11 Where Types Are Used</h3>
<p>Types are used in most kinds of declaration and in certain kinds of expression. Specifically, there are <del>16</del> <strong>17</strong> <em>type contexts</em> where types are used:</p>
<ul>
<li><p>In declarations:</p>
<ol type="1">
<li><p>A type in the <code>extends</code> or <code>implements</code> clause of a class declaration (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.1.4">8.1.4</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.1.5">8.1.5</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.5">8.5</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-9.html#jls-9.5">9.5</a>)</p></li>
<li><p>A type in the <code>extends</code> clause of an interface declaration (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-9.html#jls-9.1.3">9.1.3</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.5">8.5</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-9.html#jls-9.5">9.5</a>)</p></li>
<li><p>The return type of a method (including the type of an element of an annotation type) (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.4.5">8.4.5</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-9.html#jls-9.4">9.4</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-9.html#jls-9.6.1">9.6.1</a>)</p></li>
<li><p>A type in the <code>throws</code> clause of a method or constructor (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.4.6">8.4.6</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.8.5">8.8.5</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-9.html#jls-9.4">9.4</a>)</p></li>
<li><p>A type in the <code>extends</code> clause of a type parameter declaration of a generic class, interface, method, or constructor (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.1.2">8.1.2</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-9.html#jls-9.1.2">9.1.2</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.4.4">8.4.4</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.8.4">8.8.4</a>)</p></li>
<li><p>The type in a field declaration of a class or interface (including an enum constant) (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.3">8.3</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-9.html#jls-9.3">9.3</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.9.1">8.9.1</a>)</p></li>
<li><p>The type in a formal parameter declaration of a method, constructor, or lambda expression (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.4.1">8.4.1</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.8.1">8.8.1</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-9.html#jls-9.4">9.4</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.27.1">15.27.1</a>)</p></li>
<li><p>The type of the receiver parameter of a method (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.4">8.4</a>)</p></li>
<li><p>The type in a local variable declaration (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-14.html#jls-14.4">14.4</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-14.html#jls-14.14.1">14.14.1</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-14.html#jls-14.14.2">14.14.2</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-14.html#jls-14.20.3">14.20.3</a>)</p></li>
<li><p>The type in an exception parameter declaration (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-14.html#jls-14.20">14.20</a>)</p></li>
</ol>
<div class="inserted">
<ol start="11" type="1">
<li>The type in the declaration of a pattern variable (<a href="#jls-14.30.1">14.30.1</a>)</li>
</ol>
</div></li>
<li><p>In expressions:</p>
<ol type="1">
<li><p>A type in the explicit type argument list to an explicit constructor invocation statement or class instance creation expression or method invocation expression (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.8.7.1">8.8.7.1</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.9">15.9</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.12">15.12</a>)</p></li>
<li><p>In an unqualified class instance creation expression, as the class type to be instantiated (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.9">15.9</a>) or as the direct superclass or direct superinterface of an anonymous class to be instantiated (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.9.5">15.9.5</a>)</p></li>
<li><p>The element type in an array creation expression (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.10.1">15.10.1</a>)</p></li>
<li><p>The type in the cast operator of a cast expression (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.16">15.16</a>)</p></li>
<li><p>The type that follows the <strong>type</strong> <code>instanceof</code> relational operator (<a href="#jls-15.20.2">15.20.2</a>)</p></li>
<li><p>In a method reference expression (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.13">15.13</a>), as the reference type to search for a member method or as the class type or array type to construct.</p></li>
</ol></li>
</ul>
<p>Also, types are used as:</p>
<ul>
<li><p>The element type of an array type in any of the above contexts; and</p></li>
<li><p>A non-wildcard type argument, or a bound of a wildcard type argument, of a parameterized type in any of the above contexts.</p></li>
</ul>
<p>Finally, there are three special terms in the Java programming language which denote the use of a type:</p>
<ul>
<li><p>An unbounded wildcard (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-4.html#jls-4.5.1">4.5.1</a>)</p></li>
<li><p>The <code>...</code> in the type of a variable arity parameter (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.4.1">8.4.1</a>), to indicate an array type</p></li>
<li><p>The simple name of a type in a constructor declaration (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.8">8.8</a>), to indicate the class of the constructed object</p></li>
</ul>
<p>...</p>
<h3 id="jls-4.12">4.12 Variables</h3>
<h4 id="jls-4.12.3">4.12.3 Kinds of Variables</h4>
<p>There are <del>eight</del> <strong>nine</strong> kinds of variables:</p>
<ol type="1">
<li><p>A <em>class variable</em> is a field declared using the keyword <code>static</code> within a class declaration (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.3.1.1">8.3.1.1</a>), or with or without the keyword <code>static</code> within an interface declaration (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-9.html#jls-9.3">9.3</a>).</p>
<p>A class variable is created when its class or interface is prepared (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-12.html#jls-12.3.2">12.3.2</a>) and is initialized to a default value (<a href="#jls-4.12.5">4.12.5</a>). The class variable effectively ceases to exist when its class or interface is unloaded (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-12.html#jls-12.7">12.7</a>).</p></li>
<li><p>An <em>instance variable</em> is a field declared within a class declaration without using the keyword <code>static</code> (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.3.1.1">8.3.1.1</a>).</p>
<p>If a class <em>T</em> has a field <code>a</code> that is an instance variable, then a new instance variable <code>a</code> is created and initialized to a default value (<a href="#jls-4.12.5">4.12.5</a>) as part of each newly created object of class <em>T</em> or of any class that is a subclass of <em>T</em> (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.1.4">8.1.4</a>). The instance variable effectively ceases to exist when the object of which it is a field is no longer referenced, after any necessary finalization of the object (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-12.html#jls-12.6">12.6</a>) has been completed.</p></li>
<li><p><em>Array components</em> are unnamed variables that are created and initialized to default values (<a href="#jls-4.12.5">4.12.5</a>) whenever a new object that is an array is created (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-10.html">10</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.10.2">15.10.2</a>). The array components effectively cease to exist when the array is no longer referenced.</p></li>
<li><p><em>Method parameters</em> (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.4.1">8.4.1</a>) name argument values passed to a method.</p>
<p>For every parameter declared in a method declaration, a new parameter variable is created each time that method is invoked (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.12">15.12</a>). The new variable is initialized with the corresponding argument value from the method invocation. The method parameter effectively ceases to exist when the execution of the body of the method is complete.</p></li>
<li><p><em>Constructor parameters</em> (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.8.1">8.8.1</a>) name argument values passed to a constructor.</p>
<p>For every parameter declared in a constructor declaration, a new parameter variable is created each time a class instance creation expression (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.9">15.9</a>) or explicit constructor invocation (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.8.7">8.8.7</a>) invokes that constructor. The new variable is initialized with the corresponding argument value from the creation expression or constructor invocation. The constructor parameter effectively ceases to exist when the execution of the body of the constructor is complete.</p></li>
<li><p><em>Lambda parameters</em> (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.27.1">15.27.1</a>) name argument values passed to a lambda expression body (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.27.2">15.27.2</a>).</p>
<p>For every parameter declared in a lambda expression, a new parameter variable is created each time a method implemented by the lambda body is invoked (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.12">15.12</a>). The new variable is initialized with the corresponding argument value from the method invocation. The lambda parameter effectively ceases to exist when the execution of the lambda expression body is complete.</p></li>
<li><p>An <em>exception parameter</em> is created each time an exception is caught by a <code>catch</code> clause of a <code>try</code> statement (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-14.html#jls-14.20">14.20</a>).</p>
<p>The new variable is initialized with the actual object associated with the exception (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-11.html#jls-11.3">11.3</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-14.html#jls-14.18">14.18</a>). The exception parameter effectively ceases to exist when execution of the block associated with the <code>catch</code> clause is complete.</p></li>
<li><p><em>Local variables</em> are declared by local variable declaration statements (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-14.html#jls-14.4">14.4</a>).</p>
<p>Whenever the flow of control enters a block (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-14.html#jls-14.2">14.2</a>) or <code>for</code> statement (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-14.html#jls-14.14">14.14</a>), a new variable is created for each local variable declared in a local variable declaration statement immediately contained within that block or <code>for</code> statement.</p>
<p>A local variable declaration statement may contain an expression which initializes the variable. The local variable with an initializing expression is not initialized, however, until the local variable declaration statement that declares it is executed. (The rules of definite assignment (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-16.html">16</a>) prevent the value of a local variable from being used before it has been initialized or otherwise assigned a value.) The local variable effectively ceases to exist when the execution of the block or for statement is complete.</p>
<blockquote>
<p>Were it not for one exceptional situation, a local variable could always be regarded as being created when its local variable declaration statement is executed. The exceptional situation involves the <code>switch</code> statement (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-14.html#jls-14.11">14.11</a>), where it is possible for control to enter a block but bypass execution of a local variable declaration statement. Because of the restrictions imposed by the rules of definite assignment (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-16.html">16</a>), however, the local variable declared by such a bypassed local variable declaration statement cannot be used before it has been definitely assigned a value by an assignment expression (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.26">15.26</a>).</p>
</blockquote></li>
</ol>
<div class="inserted">
<ol start="9" type="1">
<li><em>Pattern variables</em> are declared in patterns. Pattern variables are assigned a value by the process of pattern matching (<a href="#jls-14.30.3">14.30.3</a>). This process is <em>conditional</em>; a pattern variable is only assigned a value if the pattern match succeeds. For this reason, pattern variables require special rules restricting their use (<a href="#jls-6.3">6.3</a>).</li>
</ol>
</div>
<div class="example">
<p>Example 4.12.3-1. Different Kinds of Variables</p>
<pre><code>class Point {
    static int numPoints;   // numPoints is a class variable
    int x, y;               // x and y are instance variables
    int[] w = new int[10];  // w[0] is an array component
    int setX(int x) {       // x is a method parameter
        int oldx = this.x;  // oldx is a local variable
        this.x = x;
        return oldx;
    }</code></pre>
<pre class="inserted"><code>    boolean equalAtX(Object o) {
        if (o instanceof Point p)  // p is a pattern variable
            return this.x == p.x;
        else
            return false;
    }
}</code></pre>
</div>
<h4 id="jls-4.12.4">4.12.4 <code>final</code> Variables</h4>
<p>A variable can be declared <code>final</code>. A <code>final</code> variable may only be assigned to once. It is a compile-time error if a <code>final</code> variable is assigned to unless it is definitely unassigned immediately prior to the assignment (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-16.html">16</a>).</p>
<p>Once a <code>final</code> variable has been assigned, it always contains the same value. If a <code>final</code> variable holds a reference to an object, then the state of the object may be changed by operations on the object, but the variable will always refer to the same object. This applies also to arrays, because arrays are objects; if a <code>final</code> variable holds a reference to an array, then the components of the array may be changed by operations on the array, but the variable will always refer to the same array.</p>
<p>A <em>blank <code>final</code></em> is a <code>final</code> variable whose declaration lacks an initializer.</p>
<p>A <em>constant variable</em> is a <code>final</code> variable of primitive type or type <code>String</code> that is initialized with a constant expression (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.28">15.28</a>). Whether a variable is a constant variable or not may have implications with respect to class initialization (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-12.html#jls-12.4.1">12.4.1</a>), binary compatibility (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-13.html#jls-13.1">13.1</a>), reachability (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-14.html#jls-14.21">14.21</a>), and definite assignment (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-16.html#jls-16.1.1">16.1.1</a>).</p>
<p><del>Three</del> <strong>Four</strong> kinds of variable are implicitly declared <code>final</code>: a field of an interface (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-9.html#jls-9.3">9.3</a>), a local variable declared as a resource of a <code>try</code>-with-resources statement (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-14.html#jls-14.20.3">14.20.3</a>), <del>and</del> an exception parameter of a multi-<code>catch</code> clause (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-14.html#jls-14.20">14.20</a>)<strong>, and a pattern variable (<a href="#jls-14.30.1">14.30.1</a>)</strong>. An exception parameter of a uni-<code>catch</code> clause is never implicitly declared <code>final</code>, but may be effectively final.</p>
<div class="example">
<p>Example 4.12.4-1. Final Variables</p>
<p>Declaring a variable <code>final</code> can serve as useful documentation that its value will not change and can help avoid programming errors. In this program:</p>
<pre><code>class Point {
    int x, y;
    int useCount;
    Point(int x, int y) { this.x = x; this.y = y; }
    static final Point origin = new Point(0, 0);
}</code></pre>
<p>the class <code>Point</code> declares a <code>final</code> class variable <code>origin</code>. The <code>origin</code> variable holds a reference to an object that is an instance of class <code>Point</code> whose coordinates are (0, 0). The value of the variable <code>Point.origin</code> can never change, so it always refers to the same <code>Point</code> object, the one created by its initializer. However, an operation on this <code>Point</code> object might change its state - for example, modifying its <code>useCount</code> or even, misleadingly, its <code>x</code> or <code>y</code> coordinate.</p>
</div>
<p>Certain variables that are not declared <code>final</code> are instead considered <em>effectively final</em>:</p>
<ul>
<li><p>A local variable whose declarator has an initializer (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-14.html#jls-14.4.2">14.4.2</a>) is <em>effectively final</em> if all of the following are true:</p>
<ul>
<li><p>It is not declared <code>final</code>.</p></li>
<li><p>It never occurs as the left hand side in an assignment expression (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.26">15.26</a>). (Note that the local variable declarator containing the initializer is <em>not</em> an assignment expression.)</p></li>
<li><p>It never occurs as the operand of a prefix or postfix increment or decrement operator (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.14">15.14</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.15">15.15</a>).</p></li>
</ul></li>
<li><p>A local variable whose declarator lacks an initializer is <em>effectively final</em> if all of the following are true:</p>
<ul>
<li><p>It is not declared <code>final</code>.</p></li>
<li><p>Whenever it occurs as the left hand side in an assignment expression, it is definitely unassigned and not definitely assigned before the assignment; that is, it is definitely unassigned and not definitely assigned after the right hand side of the assignment expression (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-16.html">16</a>).</p></li>
<li><p>It never occurs as the operand of a prefix or postfix increment or decrement operator.</p></li>
</ul></li>
<li><p>A method, constructor, lambda, or exception parameter (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.4.1">8.4.1</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.8.1">8.8.1</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-9.html#jls-9.4">9.4</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.27.1">15.27.1</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-14.html#jls-14.20">14.20</a>) is treated, for the purpose of determining whether it is <em>effectively final</em>, as a local variable whose declarator has an initializer.</p></li>
</ul>
<p>If a variable is effectively final, adding the <code>final</code> modifier to its declaration will not introduce any compile-time errors. Conversely, a local variable or parameter that is declared <code>final</code> in a valid program becomes effectively final if the <code>final</code> modifier is removed.</p>
<h4 id="jls-4.12.5">4.12.5 Initial Values of Variables</h4>
<p>Every variable in a program must have a value before its value is used:</p>
<ul>
<li><p>Each class variable, instance variable, or array component is initialized with a <em>default value</em> when it is created (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.9">15.9</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.10.2">15.10.2</a>):</p>
<ul>
<li><p>For type <code>byte</code>, the default value is zero, that is, the value of <code>(byte)0</code>.</p></li>
<li><p>For type <code>short</code>, the default value is zero, that is, the value of <code>(short)0</code>.</p></li>
<li><p>For type <code>int</code>, the default value is zero, that is, <code>0</code>.</p></li>
<li><p>For type <code>long</code>, the default value is zero, that is, <code>0L</code>.</p></li>
<li><p>For type <code>float</code>, the default value is positive zero, that is, <code>0.0f</code>.</p></li>
<li><p>For type <code>double</code>, the default value is positive zero, that is, <code>0.0d</code>.</p></li>
<li><p>For type <code>char</code>, the default value is the null character, that is, <code>'\u0000'</code>.</p></li>
<li><p>For type <code>boolean</code>, the default value is <code>false</code>.</p></li>
<li><p>For all reference types (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-4.html#jls-4.3">4.3</a>), the default value is <code>null</code>.</p></li>
</ul></li>
<li><p>Each method parameter (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.4.1">8.4.1</a>) is initialized to the corresponding argument value provided by the invoker of the method (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.12">15.12</a>).</p></li>
<li><p>Each constructor parameter (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.8.1">8.8.1</a>) is initialized to the corresponding argument value provided by a class instance creation expression (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.9">15.9</a>) or explicit constructor invocation (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.8.7">8.8.7</a>).</p></li>
<li><p><strong>Each pattern variable (<a href="#jls-14.30.1">14.30.1</a>) is assigned a value after the pattern matching process has succeeded (<a href="#jls-14.30.3">14.30.3</a>).</strong></p></li>
<li><p>An exception parameter (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-14.html#jls-14.20">14.20</a>) is initialized to the thrown object representing the exception (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-11.html#jls-11.3">11.3</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-14.html#jls-14.18">14.18</a>).</p></li>
<li><p>A local variable (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-14.html#jls-14.4">14.4</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-14.html#jls-14.14">14.14</a>) must be explicitly given a value before it is used, by either initialization (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-14.html#jls-14.4">14.4</a>) or assignment (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.26">15.26</a>), in a way that can be verified using the rules for definite assignment (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-16.html">16</a>).</p></li>
</ul>
<div class="example">
<p>Example 4.12.5-1. Initial Values of Variables</p>
<pre><code>class Point {
    static int npoints;
    int x, y;
    Point root;
}

class Test {
    public static void main(String[] args) {
        System.out.println(&quot;npoints=&quot; + Point.npoints);
        Point p = new Point();
        System.out.println(&quot;p.x=&quot; + p.x + &quot;, p.y=&quot; + p.y);
        System.out.println(&quot;p.root=&quot; + p.root);
    }
}</code></pre>
<p>This program prints:</p>
<pre><code>npoints=0
p.x=0, p.y=0
p.root=null</code></pre>
<p>illustrating the default initialization of <code>npoints</code>, which occurs when the class <code>Point</code> is prepared (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-12.html#jls-12.3.2">12.3.2</a>), and the default initialization of <code>x</code>, <code>y</code>, and <code>root</code>, which occurs when a new <code>Point</code> is instantiated. See <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-12.html">12</a> for a full description of all aspects of loading, linking, and initialization of classes and interfaces, plus a description of the instantiation of classes to make new class instances.</p>
</div>
<h2 id="jls-5">Chapter 5: Conversions and Contexts</h2>
<h3 id="jls-5.5">5.5 Casting Contexts</h3>
<p><em>Casting contexts</em> allow the operand of a cast expression (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.16">15.16</a>) to be converted to the type explicitly named by the cast operator<strong>, and the first operand of the <code>instanceof</code> operator (15.20.2) to be converted to the type indicated by the second operand</strong>. Compared to assignment contexts and invocation contexts, casting contexts allow the use of more of the conversions defined in <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-5.html#jls-5.1">5.1</a>, and allow more combinations of those conversions.</p>
<p>...</p>
<h2 id="jls-6">Chapter 6: Names</h2>
<h3 id="jls-6.1">6.1 Declarations</h3>
<p>A <em>declaration</em> introduces an entity into a program and includes an identifier (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-3.html#jls-3.8">3.8</a>) that can be used in a name to refer to this entity. The identifier is constrained to be a type identifier when the entity being introduced is a class, interface, or type parameter.</p>
<p>A declared entity is one of the following:</p>
<ul>
<li><p>A module, declared in a <code>module</code> declaration (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-7.html#jls-7.7">7.7</a>)</p></li>
<li><p>A package, declared in a <code>package</code> declaration (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-7.html#jls-7.4">7.4</a>)</p></li>
<li><p>An imported type, declared in a single-type-import declaration or a type-import-on-demand declaration (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-7.html#jls-7.5.1">7.5.1</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-7.html#jls-7.5.2">7.5.2</a>)</p></li>
<li><p>An imported <code>static</code> member, declared in a single-static-import declaration or a static-import-on-demand declaration (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-7.html#jls-7.5.3">7.5.3</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-7.html#jls-7.5.4">7.5.4</a>)</p></li>
<li><p>A class, declared in a class type declaration (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.1">8.1</a>)</p></li>
<li><p>An interface, declared in an interface type declaration (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-9.html#jls-9.1">9.1</a>)</p></li>
<li><p>A type parameter, declared as part of the declaration of a generic class, interface, method, or constructor (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.1.2">8.1.2</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-9.html#jls-9.1.2">9.1.2</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.4.4">8.4.4</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.8.4">8.8.4</a>)</p></li>
<li><p>A member of a reference type (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.2">8.2</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-9.html#jls-9.2">9.2</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.9.3">8.9.3</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-9.html#jls-9.6">9.6</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-10.html#jls-10.7">10.7</a>), one of the following:</p>
<ul>
<li><p>A member class (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.5">8.5</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-9.html#jls-9.5">9.5</a>)</p></li>
<li><p>A member interface (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.5">8.5</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-9.html#jls-9.5">9.5</a>)</p></li>
<li><p>An enum constant (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.9">8.9</a>)</p></li>
<li><p>A field, one of the following:</p>
<ul>
<li><p>A field declared in a class type or enum type (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.3">8.3</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.9.2">8.9.2</a>)</p></li>
<li><p>A field declared in an interface type or annotation type (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-9.html#jls-9.3">9.3</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-9.html#jls-9.6.1">9.6.1</a>)</p></li>
<li><p>The field <code>length</code>, which is implicitly a member of every array type (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-10.html#jls-10.7">10.7</a>)</p></li>
</ul></li>
<li><p>A method, one of the following:</p>
<ul>
<li><p>A method (<code>abstract</code> or otherwise) declared in a class type or enum type (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.4">8.4</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.9.2">8.9.2</a>)</p></li>
<li><p>A method (<code>abstract</code> or otherwise) declared in an interface type or annotation type (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-9.html#jls-9.4">9.4</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-9.html#jls-9.6.1">9.6.1</a>)</p></li>
</ul></li>
</ul></li>
<li><p>A parameter, one of the following:</p>
<ul>
<li><p>A formal parameter of a method or constructor of a class type or enum type (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.4.1">8.4.1</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.8.1">8.8.1</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.9.2">8.9.2</a>), or of a lambda expression (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.27.1">15.27.1</a>)</p></li>
<li><p>A formal parameter of an <code>abstract</code> method of an interface type or annotation type (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-9.html#jls-9.4">9.4</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-9.html#jls-9.6.1">9.6.1</a>)</p></li>
<li><p>An exception parameter of an exception handler declared in a <code>catch</code> clause of a <code>try</code> statement (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-14.html#jls-14.20">14.20</a>)</p></li>
</ul></li>
<li><p>A local variable, one of the following:</p>
<ul>
<li><p>A local variable declared in a block (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-14.html#jls-14.4">14.4</a>)</p></li>
<li><p>A local variable declared in a <code>for</code> statement (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-14.html#jls-14.14">14.14</a>)</p></li>
</ul></li>
<li><p><strong>A pattern variable, declared in a pattern (<a href="#jls-14.30">14.30</a>).</strong></p></li>
</ul>
<p>Constructors (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.8">8.8</a>) are also introduced by declarations, but use the name of the class in which they are declared rather than introducing a new name.</p>
<h3 id="jls-6.3">6.3 Scope of a Declaration</h3>
<p>The <em>scope</em> of a declaration is the region of the program within which the entity declared by the declaration can be referred to using a simple name, provided it is not shadowed (<a href="#jls-6.4.1">6.4.1</a>).</p>
<p>A declaration is said to be <em>in scope</em> at a particular point in a program if and only if the declaration's scope includes that point.</p>
<p>The scope of the declaration of an observable top level package (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-7.html#jls-7.4.3">7.4.3</a>) is all observable compilation units associated with modules to which the package is uniquely visible (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-7.html#jls-7.4.3">7.4.3</a>).</p>
<p>The declaration of a package that is not observable is never in scope.</p>
<p>The declaration of a subpackage is never in scope.</p>
<p>The package <code>java</code> is always in scope.</p>
<p>The scope of a type imported by a single-type-import declaration (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-7.html#jls-7.5.1">7.5.1</a>) or a type-import-on-demand declaration (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-7.html#jls-7.5.2">7.5.2</a>) is the module declaration (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-7.html#jls-7.7">7.7</a>) and all the class and interface type declarations (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-7.html#jls-7.6">7.6</a>) of the compilation unit in which the <code>import</code> declaration appears, as well as any annotations on the module declaration or package declaration of the compilation unit.</p>
<p>The scope of a member imported by a single-static-import declaration (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-7.html#jls-7.5.3">7.5.3</a>) or a static-import-on-demand declaration (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-7.html#jls-7.5.4">7.5.4</a>) is the module declaration and all the class and interface type declarations of the compilation unit in which the <code>import</code> declaration appears, as well as any annotations on the module declaration or package declaration of the compilation unit.</p>
<p>The scope of a top level type (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-7.html#jls-7.6">7.6</a>) is all type declarations in the package in which the top level type is declared.</p>
<p>The scope of a declaration of a member <em>m</em> declared in or inherited by a class type <em>C</em> (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.1.6">8.1.6</a>) is the entire body of <em>C</em>, including any nested type declarations.</p>
<p>The scope of a declaration of a member <em>m</em> declared in or inherited by an interface type <em>I</em> (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-9.html#jls-9.1.4">9.1.4</a>) is the entire body of <em>I</em>, including any nested type declarations.</p>
<p>The scope of an enum constant <em>C</em> declared in an enum type <em>T</em> is the body of <em>T</em>, and any <code>case</code> label of a <code>switch</code> statement whose expression is of enum type <em>T</em> (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-14.html#jls-14.11">14.11</a>).</p>
<p>The scope of a formal parameter of a method (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.4.1">8.4.1</a>), constructor (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.8.1">8.8.1</a>), or lambda expression (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.27">15.27</a>) is the entire body of the method, constructor, or lambda expression.</p>
<p>The scope of a class's type parameter (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.1.2">8.1.2</a>) is the type parameter section of the class declaration, the type parameter section of any superclass or superinterface of the class declaration, and the class body.</p>
<p>The scope of an interface's type parameter (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-9.html#jls-9.1.2">9.1.2</a>) is the type parameter section of the interface declaration, the type parameter section of any superinterface of the interface declaration, and the interface body.</p>
<p>The scope of a method's type parameter (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.4.4">8.4.4</a>) is the entire declaration of the method, including the type parameter section, but excluding the method modifiers.</p>
<p>The scope of a constructor's type parameter (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.8.4">8.8.4</a>) is the entire declaration of the constructor, including the type parameter section, but excluding the constructor modifiers.</p>
<p>The scope of a local class declaration immediately enclosed by a block (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-14.html#jls-14.2">14.2</a>) is the rest of the immediately enclosing block, including its own class declaration.</p>
<p>The scope of a local class declaration immediately enclosed by a switch block statement group (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-14.html#jls-14.11">14.11</a>) is the rest of the immediately enclosing switch block statement group, including its own class declaration.</p>
<p>The scope of a local variable declaration in a block (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-14.html#jls-14.4">14.4</a>) is the rest of the block in which the declaration appears, starting with its own initializer and including any further declarators to the right in the local variable declaration statement.</p>
<p>The scope of a local variable declared in the <em>ForInit</em> part of a basic <code>for</code> statement (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-14.html#jls-14.14.1">14.14.1</a>) includes all of the following:</p>
<ul>
<li><p>Its own initializer</p></li>
<li><p>Any further declarators to the right in the <em>ForInit</em> part of the <code>for</code> statement</p></li>
<li><p>The <em>Expression</em> and <em>ForUpdate</em> parts of the <code>for</code> statement</p></li>
<li><p>The contained <em>Statement</em></p></li>
</ul>
<p>The scope of a local variable declared in the <em>FormalParameter</em> part of an enhanced <code>for</code> statement (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-14.html#jls-14.14.2">14.14.2</a>) is the contained <em>Statement</em>.</p>
<p>The scope of a parameter of an exception handler that is declared in a <code>catch</code> clause of a <code>try</code> statement (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-14.html#jls-14.20">14.20</a>) is the entire block associated with the <code>catch</code>.</p>
<p>The scope of a variable declared in the <em>ResourceSpecification</em> of a <code>try</code>-with-resources statement (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-14.html#jls-14.20.3">14.20.3</a>) is from the declaration rightward over the remainder of the <em>ResourceSpecification</em> and the entire <code>try</code> block associated with the <code>try</code>-with-resources statement.</p>
<blockquote>
<p>The translation of a <code>try</code>-with-resources statement implies the rule above.</p>
</blockquote>
<div class="example">
<p>Example 6.3-1. Scope of Type Declarations</p>
<p>These rules imply that declarations of class and interface types need not appear before uses of the types. In the following program, the use of <code>PointList</code> in class <code>Point</code> is valid, because the scope of the class declaration <code>PointList</code> includes both class <code>Point</code> and class <code>PointList</code>, as well as any other type declarations in other compilation units of package <code>points</code>.</p>
<pre><code>package points;
class Point {
    int x, y;
    PointList list;
    Point next;
}

class PointList {
    Point first;
}</code></pre>
</div>
<div class="example">
<p>Example 6.3-2. Scope of Local Variable Declarations</p>
<p>The following program causes a compile-time error because the initialization of local variable <code>x</code> is within the scope of the declaration of local variable <code>x</code>, but the local variable <code>x</code> does not yet have a value and cannot be used. The field <code>x</code> has a value of <code>0</code> (assigned when <code>Test1</code> was initialized) but is a red herring since it is shadowed (<a href="#jls-6.4.1">6.4.1</a>) by the local variable <code>x</code>.</p>
<pre><code>class Test1 {
    static int x;
    public static void main(String[] args) {
        int x = x;
    }
}</code></pre>
<p>The following program does compile:</p>
<pre><code>class Test2 {
    static int x;
    public static void main(String[] args) {
        int x = (x=2)*2;
        System.out.println(x);
    }
}</code></pre>
<p>because the local variable <code>x</code> is definitely assigned (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-16.html">16</a>) before it is used. It prints:</p>
<pre><code>4</code></pre>
<p>In the following program, the initializer for <code>three</code> can correctly refer to the variable <code>two</code> declared in an earlier declarator, and the method invocation in the next line can correctly refer to the variable <code>three</code> declared earlier in the block.</p>
<pre><code>class Test3 {
    public static void main(String[] args) {
        System.out.print(&quot;2+1=&quot;);
        int two = 2, three = two + 1;
        System.out.println(three);
    }
}</code></pre>
<p>This program produces the output:</p>
<pre><code>2+1=3</code></pre>
</div>
<div class="inserted">
<p>A variable declared in a pattern is known as a <em>pattern variable</em> (<a href="#jls-14.30">14.30</a>). Pattern variables differ from other local variables in that they can only be assigned a value by pattern matching (<a href="#jls-14.30.3">14.30.3</a>). This process is <em>conditional</em>; a pattern variable is only assigned a value if the pattern match succeeds.</p>
<p>Accordingly the scope of pattern variables is carefully defined so that a pattern variable is only in scope at those program points where pattern matching will have succeeded and the pattern variable will have been definitely assigned a value. Put another way, accessing a pattern variable where pattern matching can not be guaranteed to have succeeded is not possible and will result in a compile-time error.</p>
<blockquote>
<p>In this sense, the scope of a pattern variable is a flow dependent concept similar to definite assignment (Chapter <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-16.html">16</a>). The rules that are defined in the rest of this section deliberately have a similar form to those used in Chapter <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-16.html">16</a>.</p>
</blockquote>
<p>The scope of a pattern variable is determined by considering the innermost enclosing statement <em>S</em> that contains the pattern variable declaration. The overall scope of a pattern variable <em>V</em> is defined to be (i) those expressions and statements contained in <em>S</em> where <em>V</em> is definitely matched; and (ii) if <em>S</em> is immediately contained by a statement <em>Q</em>, those statements following <em>S</em> contained by <em>Q</em> where <em>V</em> is definitely matched; and (iii) if <em>S</em> is immediately contained by a block, those statements following <em>S</em> contained by that block where <em>V</em> is definitely matched.</p>
<p>The remainder of this section is devoted to a precise explanation of the words &quot;definitely matched at&quot;, for which we define three auxiliary technical terms:</p>
<ul>
<li>a pattern variable is <em>introduced by</em> an expression <em>when true</em>;</li>
<li>a pattern variable is <em>introduced by</em> an expression <em>when false</em>; and</li>
<li>a pattern variable is <em>introduced by</em> a statement.</li>
</ul>
<!-- > Finally, given the expression `(a instanceof String s) && b`, the
> pattern variable `s` is _definitely matched_ at `b`, and so is in scope. -->
<blockquote>
<p>The analysis takes into account the structure of statements and expressions, with a special treatment for the boolean expression operators and certain statement forms.</p>
<p>The simplest example is that the pattern variable <code>s</code> is <em>introduced by</em> the expression <code>a instanceof String s</code> <em>when true</em>. In other words, if the value of the expression is <code>true</code> then the pattern matching must have succeeded, and thus the pattern variable must have been assigned a value.</p>
<p>In contrast, the pattern variable <code>t</code> is <em>introduced by</em> the expression <code>!(b instanceof Integer t)</code> <em>when false</em>. This is because the pattern matching could only have succeeded if the value of the expression is <code>false</code>.</p>
<p>Pattern variables can, in certain circumstances, be introduced by a statement. Further details are given in <a href="#jls-6.3.2">6.3.2</a>.</p>
</blockquote>
</div>
<h4 id="jls-6.3.1"><strong>6.3.1 Pattern Declaration Scopes and Expressions</strong></h4>
<div class="inserted">
<p>Only certain boolean expressions can introduce a new pattern variable into scope. If an expression is not a logical complement expression, conditional-and expression, conditional-or expression, conditional expression, or <code>instanceof</code> operator, then no rules apply regarding the introduction of pattern variables.</p>
</div>
<!--However, if a pattern variable is in scope at an expression, then clearly it is in scope at all its components. In other words the following rule applies for an expression, `e`, that is not a logical complement expression,
conditional-and expression, conditional-or expression, conditional expression,
or `instanceof` operator:

- if _V_ is in scope at `e` then _V_ is in scope at all the subexpressions and substatements of `e`. -->
<h5 id="jls-6.3.1.1"><strong>6.3.1.1 Conditional-And Operator <code>&amp;&amp;</code></strong></h5>
<div class="inserted">
<p>The following rules apply to a conditional-and expression (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.23">15.23</a>):</p>
<ul>
<li><em>V</em> is introduced by <code>a &amp;&amp; b</code> when true iff either
<ul>
<li><em>V</em> is introduced by <code>a</code> when true, or</li>
<li><em>V</em> is introduced by <code>b</code> when true.</li>
</ul>
It is a compile-time error if both <em>V</em> is introduced by <code>a</code> when true, and <em>V</em> is introduced by <code>b</code> when true.</li>
</ul>
<!-- // Removed as we don't allow merging

- _V_ is introduced by `a && b` when false iff both
    - _V_ is introduced by `a` when false, and
    - _V_ is introduced by `b` when false.
-->
<ul>
<li><p>A pattern variable introduced by <code>a</code> when true is definitely matched at <code>b</code>.</p>
<p>It is a compile-time error if any pattern variable introduced by <code>a</code> when true is already in scope at <code>b</code>.</p></li>
</ul>
<blockquote>
<p>The first rule rules out the possibility of a pattern variable being implicitly assigned a value more than once by pattern matching. Pattern variables are implicitly final by design.</p>
<pre><code>if ((a instanceof String s) &amp;&amp; (b instanceof String s)) {
    System.out.println(s);   // Not allowed
}</code></pre>
<p>The second rule means that a pattern variable introduced by the left-hand operand of a conditional-and operator is in scope, and can therefore be used, in the right-hand operand. This allows for expressions such as <code>x instanceof String s &amp;&amp; s.length()&gt;0</code>.</p>
</blockquote>
<ul>
<li><p>It is a compile-time error if a pattern variable is both introduced by <code>a</code> when false, and by <code>b</code> when false.</p>
<blockquote>
<p>This final case rules out an example such as the following where a pattern variable is declared in more than one place but these declarations are coalesced by the context:</p>
<pre><code>if (!(a instanceof T t) &amp;&amp; !(b instanceof T t)) {
    
} else {
    
}</code></pre>
<p>As it stands the pattern variable <code>t</code> is not in scope in the second contained statement (the one after the <code>else</code>), but this may be relaxed in future versions of the language (provided the types are identical).</p>
</blockquote></li>
</ul>
</div>
<h5 id="jls-6.3.1.2"><strong>6.3.1.2 Conditional-Or Operator <code>||</code></strong></h5>
<div class="inserted">
<p>The following rules apply to a conditional-or expression (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.24">15.24</a>):</p>
<!-- // Removed as we don;t allow merging
- _V_ is introduced by `a || b` when true iff both

    - _V_ is introduced by `a` when true, and
    - _V_ is introduced by `b` when true.
-->
<ul>
<li><p><em>V</em> is introduced by <code>a || b</code> when false iff either</p>
<ul>
<li><em>V</em> is introduced by <code>a</code> when false, or</li>
<li><em>V</em> is introduced by <code>b</code> when false.</li>
</ul>
<p>It is a compile-time error if both <em>V</em> is introduced by <code>a</code> when false, and <em>V</em> is introduced by <code>b</code> when false.</p></li>
<li><p>A pattern variable introduced by <code>a</code> when false is definitely matched at <code>b</code>.</p>
<p>It is a compile-time error if any pattern variable introduced by <code>a</code> when false is already in scope at <code>b</code>.</p></li>
</ul>
<!-- the following is needed for forwards compatibility with merging -->
<ul>
<li><p>It is a compile-time error if a pattern variable is both introduced by <code>a</code> when true, and by <code>b</code> when true.</p>
<blockquote>
<p>This final case rules out an example such as the following:</p>
<pre><code>if ((a instanceof T t) || (b instanceof T t)) {
    
}</code></pre>
<p>As it stands the pattern variable <code>t</code> is not in scope in the first contained statement, but this may be relaxed in future versions of the language.</p>
</blockquote></li>
</ul>
</div>
<h5 id="jls-6.3.1.3"><strong>6.3.1.3 Logical Complement Operator <code>!</code></strong></h5>
<div class="inserted">
<p>The following rules apply to a logical complement expression (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.15.6">15.15.6</a>):</p>
<ul>
<li><p><em>V</em> is introduced by <code>!a</code> when true iff <em>V</em> is introduced by <code>a</code> when false.</p></li>
<li><p><em>V</em> is introduced by <code>!a</code> when false iff <em>V</em> is introduced by <code>a</code> when true.</p></li>
</ul>
</div>
<h5 id="jls-6.3.1.4"><strong>6.3.1.4 Conditional Operator <code>? :</code></strong></h5>
<div class="inserted">
<p>The following rules apply to a conditional expression <code>a ? b : c</code> (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.25">15.25</a>):</p>
<!-- - _V_ is introduced by `a ? b : c` when true iff either

    - _V_ is introduced by `b` when true and _V_ is introduced by `c`
      when true, or
    - _V_ is introduced by `a` when true and _V_ is introduced by `c`
      when true, or
    - _V_ is introduced by `a` when false and _V_ is introduced by `b`
      when true.

  It is a compile-time error if two or more of the following conditions
  hold:

    - _V_ is introduced by `b` when true and _V_ is introduced by `c` when
          true,
    - _V_ is introduced by `a` when true and _V_ is introduced by `c` when
          true,
    - _V_ is introduced by `a` when false and _V_ is introduced by `b`
          when true.


- _V_ is introduced by `a ? b : c` when false iff either:

    - _V_ is introduced by `b` when false and _V_ is introduced by `c`
      when false, or
    - _V_ is introduced by `a` when true and _V_ is introduced by `c`
      when false, or
    - _V_ is introduced by `a` when false and _V_ is introduced by `b`
      when false

  It is a compile-time error if two or more of the following conditions
  hold:

    - _V_ is introduced by `b` when false and _V_ is introduced by `c`
          when false, or
    - _V_ is introduced by `a` when true and _V_ is introduced by `c` when
          false, or
    - _V_ is introduced by `a` when false and _V_ is introduced by `b`
        when false
-->
<ul>
<li><p>A pattern variable introduced by <code>a</code> when true is definitely matched at <code>b</code>.</p>
<p>It is a compile-time error if any pattern variable introduced by <code>a</code> when true is already in scope at <code>b</code>.</p></li>
<li><p>A pattern variable introduced by <code>a</code> when false is definitely matched at <code>c</code>.</p>
<p>It is a compile-time error if any pattern variable introduced by <code>a</code> when false is already in scope at <code>c</code>.</p></li>
<li><p>It is a compile-time error if any of the following conditions hold:</p>
<ul>
<li><p>A pattern variable is introduced both by <code>a</code> when true, and by <code>c</code> when true.</p></li>
<li><p>A pattern variable is introduced both by <code>a</code> when false, and by <code>b</code> when true.</p></li>
<li><p>A pattern variable is introduced both by <code>b</code> when true, and by <code>c</code> when true.</p></li>
<li><p>A pattern variable is introduced both by <code>a</code> when true, and by <code>c</code> when false.</p></li>
<li><p>A pattern variable is introduced both by <code>a</code> when false, and by <code>b</code> when false.</p></li>
<li><p>A pattern variable is introduced both by <code>b</code> when false, and by <code>c</code> when false.</p></li>
</ul>
<blockquote>
<p>These final cases are to rule out cases of the introduction of pattern variables that may be supported in future versions of the language.</p>
</blockquote></li>
</ul>
</div>
<h5 id="jls-6.3.1.5"><strong>6.3.1.5 <code>instanceof</code> Operator</strong></h5>
<div class="inserted">
<p>The following rule applies to an <code>instanceof</code> expression (<a href="#jls-15.20.2">15.20.2</a>):</p>
<ul>
<li><p><em>V</em> is introduced by <code>a instanceof p</code> when true iff <em>V</em> is declared by pattern <code>p</code>. (The rules for determining which pattern variables are declared by a pattern are given in <a href="#jls-14.30.1">14.30.1</a>.)</p>
<p>It is a compile-time error if any pattern variable introduced by the pattern <code>p</code> is already in scope at the <code>instanceof</code> expression.</p></li>
</ul>
<!---
- _V_ is introduced by `a instanceof T t` [15.20.2] when true iff `t` is _V_.
- _V_ is introduced by `a instanceof T t` when false iff never.
-->
<blockquote>
<p>Note that no pattern variable is introduced by an expression <code>a instanceof p</code> when false.</p>
</blockquote>
</div>
<div class="editorial">
<p>JEP 361 proposes to add a <code>switch</code> expression. This would result in the following additional rule for determining the scope of pattern variables (in conjunction with the changes required to specify <code>switch</code> expressions).</p>
<h5 id="jls-6.3.1.6"><strong>6.3.1.6 <code>switch</code> Expressions</strong></h5>
<div class="inserted">
<p>The following rule covers the <code>switch</code> expression (15.28).</p>
<ul>
<li>A pattern variable introduced by a statement <em>S</em> contained in a switch labeled statement group (14.11.1) is definitely matched at all the statements following <em>S</em>, if any, in the switch labeled statement group.</li>
</ul>
</div>
</div>
<h4 id="jls-6.3.2"><strong>6.3.2 Pattern Declaration Scopes and Statements</strong></h4>
<div class="inserted">
<p>Only a few statements play a significant role in determining the scope of pattern variables.</p>
<p>The scope of pattern variables declared in subexpressions contained within <code>if</code>, <code>while</code>, <code>do</code>, and <code>for</code> statements can, in certain circumstances, include other contained substatements. Here is an example:</p>
<pre><code>if (x instance String s) {
    // String s in scope for this block
    // No explicit cast needed here!
    ...
    System.out.println(&quot;The string value was: &quot; + s);
} else {
    // String s not in scope here
    System.out.println(s); // Compile-time error!
}</code></pre>
<p>In certain constrained circumstances, a pattern variable can be introduced by a statement. In this case, the pattern variable is in scope at following statements in the enclosing block. Here is an example:</p>
<pre><code>public void RequiresAString(Object o) {
    if (!(o instanceof String s)) {
        throw new IllegalArgumentException();
    }
    // Only reachable if the pattern match succeeded
    // String s is thus in scope for the rest of the block
    System.out.println(&quot;The parameter string was: &quot; + s);
    ...
}
</code></pre>
<!--

Key point is that we introduce two new ideas:

1. A variable can be *included* in a statement, if a nested expression introduces it via pattern matching.
2. A variable can be *introduced* by a statement, to allow the scope of a pattern variable to 'bleed' into subsequent statements.

Both of these only occur for a limited number of statements, cf. if, while, do, for and switch.
-->
<!--
First, let's deal with a sequence of statements in a block, and allow variables introduced by one statement to be in scope/included in subsequent statements
-->
<!--**TODO!**
The following rules apply to statements occuring in a block:

 - _V_ is in scope at a statement _S_ that occurs in a block that is not a switch block if _V_ is introduced by the preceding statement.

 - _V_ is in scope at a statement _S_ that occurs in a block that is not a switch block if _V_ is in scope at the preceding statement.
-->
</div>
<h5 id="jls-6.3.2.1"><strong>6.3.2.1 Blocks</strong></h5>
<div class="inserted">
<p>The following rule applies to a block statement <em>S</em> contained in a block that is not a switch block:</p>
<ul>
<li>A pattern variable introduced by <em>S</em> is definitely matched at all the block statements following <em>S</em>, if any, in the block.</li>
</ul>
</div>
<h5 id="jls-6.3.2.2"><strong>6.3.2.2 <code>if</code> Statements</strong></h5>
<div class="inserted">
<p>The following rules apply to a statement <code>if (e) S</code> (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-14.9.1">14.9.1</a>):</p>
<ul>
<li><p>A pattern variable introduced by <code>e</code> when true is definitely matched at <code>S</code>.</p>
<p>It is a compile-time error if any pattern variable introduced by <code>e</code> when true is already in scope at <code>S</code>.</p></li>
<li><p><em>V</em> is introduced by <code>if (e) S</code> iff <em>V</em> is introduced by <code>e</code> when false and <code>S</code> cannot complete normally.</p>
<p>It is a compile-time error if any pattern variable introduced by the <code>if</code> statement is already in scope.</p></li>
</ul>
<blockquote>
<p>The second rule makes use of the notion of 'cannot complete normally' (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-14.html#jls-14.21">14.21</a>), which itself makes use of the concept of a constant expression (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.29">15.29</a>). This means that calculating the scope of a pattern variable may require determining whether a simple name, or a qualified name of the form <em>TypeName</em><code>.</code> <em>Identifier</em>, refers to a constant variable. As pattern variables can never refer to a constant variable, there is no circularity.</p>
</blockquote>
<p>The following rules apply to a statement <code>if (e) S else T</code> (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-14.9.2">14.9.2</a>):</p>
<ul>
<li><p>A pattern variable introduced by <code>e</code> when true is definitely matched at <code>S</code>.</p>
<p>It is a compile-time error if any pattern variable introduced by <code>e</code> when true is already in scope at <code>S</code>.</p></li>
<li><p>A pattern variable introduced by <code>e</code> when false is definitely matched at <code>T</code>.</p>
<p>It is a compile-time error if any pattern variable introduced by <code>e</code> when false is already in scope at <code>T</code>.</p></li>
<li><em>V</em> is introduced by <code>if (e) S else T</code> iff either:
<ul>
<li><em>V</em> is introduced by <code>e</code> when true, <code>S</code> can complete normally, and <code>T</code> cannot complete normally; or</li>
<li><em>V</em> is introduced by <code>e</code> when false, <code>S</code> cannot complete normally, and <code>T</code> can complete normally.</li>
</ul>
<p>It is a compile-time error if any pattern variable introduced by the <code>if</code> statement is already in scope.</p></li>
</ul>
<blockquote>
<p>These rules highlight the flow-like nature of scoping for pattern variables. In the following statement:</p>
</blockquote>
<blockquote>
<pre><code>if (e instanceof String s) {
  counter += s.length();
} else {
  ...   // s not in scope
}</code></pre>
</blockquote>
<blockquote>
<p>The pattern variable <code>s</code> is introduced by the <code>instanceof</code> operator and is in scope in the first contained statement (the one before the <code>else</code> keyword), but it is <em>not</em> in scope in the second contained statement (the one after the <code>else</code> keyword).</p>
</blockquote>
<blockquote>
<p>Moreover, combined with the treatment for the boolean expressions, the scope of pattern variables is robust against code refactorings that exploit the familar boolean logical equivalences. For example, the previous code can be rewritten as:</p>
</blockquote>
<blockquote>
<pre><code>if (!(e instanceof String s)) {
  ...   // s not in scope
} else {
  counter += s.length();
}</code></pre>
<p>And, furthermore, can be rewritten as:</p>
</blockquote>
<blockquote>
<pre><code>if (!!(e instanceof String s)) {
  counter += s.length();
} else {
  ...   // s not in scope
}</code></pre>
</blockquote>
</div>
<h5 id="jls-6.3.2.3"><strong>6.3.2.3 <code>while</code> Statements</strong></h5>
<div class="inserted">
<p>The following rules apply to a statement <code>while (e) S</code> (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-14.12">14.12</a>):</p>
<ul>
<li><p>A pattern variable introduced by <code>e</code> when true is definitely matched at <code>S</code>.</p>
<p>It is a compile-time error if any pattern variable introduced by <code>e</code> when true is already in scope at <code>S</code>.</p></li>
<li><p><em>V</em> is introduced by <code>while (e) S</code> iff <em>V</em> is introduced by <code>e</code> when false, and <em>S</em> does not contains a reachable <code>break</code> statement whose break target contains <em>S</em>.</p>
<p>It is a compile-time error if any pattern variable introduced by the <code>while</code> statement is already in scope.</p></li>
</ul>
</div>
<h5 id="jls-6.3.2.4"><strong>6.3.2.4 <code>do</code> Statements</strong></h5>
<div class="inserted">
<p>The following rule applies to a statement <code>do S while (e)</code> (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-14.13">14.13</a>):</p>
<ul>
<li><p><em>V</em> is introduced by <code>do S while (e)</code> iff <em>V</em> is introduced by <code>e</code> when false, and <code>S</code> does not contain a reachable <code>break</code> statement whose break target contains <code>S</code>.</p>
<p>It is a compile-time error if any pattern variable introduced by the <code>do</code> statement is already in scope.</p></li>
</ul>
</div>
<h5 id="jls-6.3.2.5"><strong>6.3.2.5 <code>for</code> Statements</strong></h5>
<div class="inserted">
<p>The following rules cover the basic <code>for</code> statement (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-14.html#jls-14.14.1">14.14.1</a>). Since the enhanced <code>for</code> statement (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-14.html#jls-14.14.2">14.14.2</a>) is defined by translation to a basic <code>for</code> statement, no special rules need to be provided for it.</p>
<ul>
<li><p>A pattern variable introduced by the condition expression when true is definitely matched at both the incrementation part and the contained statement.</p>
<p>It is a compile-time error if any pattern variable introduced by the condition expression is already in scope at the incrementation part or the contained statement.</p></li>
<li><p><em>V</em> is introduced by a <code>for</code> statement iff <em>V</em> is introduced by the condition expression when false, and the contained statement, <em>S</em>, does not contain a reachable <code>break</code> statement whose break target contains <em>S</em>.</p>
<p>It is a compile-time error if any pattern variable introduced by a <code>for</code> statement is already in scope.</p></li>
</ul>
</div>
<h5 id="jls-6.3.2.6"><strong>6.3.2.6 <code>switch</code> Statements</strong></h5>
<div class="inserted">
<p>The following rule covers the <code>switch</code> statement (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-14.html#jls-14.11">14.11</a>).</p>
<ul>
<li>A pattern variable introduced by a statement <em>S</em> contained in a switch block statement group (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-14.html#jls-14.11">14.11</a>) is definitely matched at all the statements following <em>S</em>, if any, in the switch block statement group.</li>
</ul>
</div>
<!--
, if any,
in the block.

No rules apply to a `switch` statement whose switch block is either
empty or contains just switch labels.

The following rules apply to a `switch` statement `switch (e) B` whose
switch block `B` consists of switch labeled statement groups:

- _V_ is introduced by a labeled statement group contained in `B` if
  _V_ is introduced by every pattern that labels the statement group.

  It is a compile-time error if a pattern variable is not introduced by every pattern that labels a statement group.

  It is a compile-time error if _V_ is introduced by a labeled statement group contained in `B` and _V_ is also in scope at `switch (e) B`.



- _V_ is in scope at the first labeled statement group contained in `B` if _V_ is introduced by the labeled statement group.

- _V_ is in scope at a labeled statement group that is not
   the first labeled statement group contained in `B` if _V_ is introduced by the labeled statement group, and the previous
   statement group cannot complete normally.

- _V_ is in scope at a labeled statement group that is not the first labeled stament group contained in `B` if _V_ is introduced by the labeled statement group, _V_ is in scope at the previous statement group, and the previous statement group can complete normally.

- _V_ is in scope at a statement _S_ if
    - _S_ appears in a labeled statement group contained in `B`, and
    - _V_ is in scope at that labeled statement group.

> NOTE: We need to think about pattern variables introduced by e in switch (e)B




The following rules apply to a `switch` statement `switch (e) B` whose
switch block `B` consists of switch labeled rules:

- _V_ is introduced by a switch labeled rule contained in `B` if _V_ is
  introduced by every pattern that labels the rule.

  It is a compile-time error if a pattern variable is not introduced by every pattern that labels a rule.

  It is a compile-time error if _V_ is introduced by a switch labeled rule contained in `B` and _V_ is in scope at `switch (e) B`.

- _V_ is in scope at an expression _a_ if
    - _a_ is a switch labeled expression contained in `B`, and
    - _V_ is introduced by the switch labeled expression.

- _V_ is in scope at a statement `S` if, either
    - `S` is a switch labeled block statement contained in `B`, and
      _V_ is introduced by the switch labeled block statement; or
    - `S` is a switch labeled `throw` statement contained in `B`, and
      _V_ is introduced by the switch labeled throw statement.
-->
<h3 id="jls-6.4">6.4 Shadowing and Obscuring</h3>
<p>A local variable (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-14.html#jls-14.4">14.4</a>), formal parameter (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.4.1">8.4.1</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.27.1">15.27.1</a>), exception parameter (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-14.html#jls-14.20">14.20</a>), <del>and</del> local class (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-14.html#jls-14.3">14.3</a>)<strong>, and pattern variable (<a href="#jls-14.30">14.30</a>)</strong> can only be referred to using a simple name, not a qualified name (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-6.html#jls-6.2">6.2</a>).</p>
<p>Some declarations are not permitted within the scope of a local variable, <strong>pattern variable,</strong> formal parameter, exception parameter, or local class declaration because it would be impossible to distinguish between the declared entities using only simple names.</p>
<blockquote>
<p>For example, if the name of a formal parameter of a method could be redeclared as the name of a local variable in the method body, then the local variable would shadow the formal parameter and there would be no way to refer to the formal parameter - an undesirable outcome.</p>
</blockquote>
<p>It is a compile-time error if the name of a formal parameter is used to declare a new variable within the body of the method, constructor, or lambda expression, unless the new variable is declared within a class declaration contained by the method, constructor, or lambda expression.</p>
<p>It is a compile-time error if the name of a local variable <em>v</em> is used to declare a new variable within the scope of <em>v</em>, unless the new variable is declared within a class whose declaration is within the scope of <em>v</em>.</p>
<p>It is a compile-time error if the name of an exception parameter is used to declare a new variable within the <em>Block</em> of the <code>catch</code> clause, unless the new variable is declared within a class declaration contained by the <em>Block</em> of the <code>catch</code> clause.</p>
<p>It is a compile-time error if the name of a local class <em>C</em> is used to declare a new local class within the scope of <em>C</em>, unless the new local class is declared within another class whose declaration is within the scope of <em>C</em>.</p>
<blockquote>
<p>These rules allow redeclaration of a variable or local class in nested class declarations that occur in the scope of the variable or local class; such nested class declarations may be local classes (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-14.html#jls-14.3">14.3</a>) or anonymous classes (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.9">15.9</a>). Thus, the declaration of a formal parameter, local variable, <strong>pattern variable,</strong> or local class may be shadowed in a class declaration nested within a method, constructor, or lambda expression; and the declaration of an exception parameter may be shadowed in a class declaration nested within the <em>Block</em> of the <code>catch</code> clause.</p>
</blockquote>
<blockquote>
<p>There are two design alternatives for handling name clashes created by lambda parameters and other variables declared in lambda expressions. One is to mimic class declarations: like local classes, lambda expressions introduce a new &quot;level&quot; for names, and all variable names outside the expression can be redeclared. Another is a &quot;local&quot; strategy: like <code>catch</code> clauses, <code>for</code> loops, and blocks, lambda expressions operate at the same &quot;level&quot; as the enclosing context, and local variables outside the expression cannot be shadowed. The above rules use the local strategy; there is no special dispensation that allows a variable declared in a lambda expression to shadow a variable declared in an enclosing method.</p>
</blockquote>
<blockquote>
<p>Note that the rule for local classes does not make an exception for a class of the same name declared within the local class itself. However, this case is prohibited by a separate rule: a class cannot have the same name as a class that encloses it (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.1">8.1</a>).</p>
</blockquote>
<div class="example">
<p>Example 6.4-1. Attempted Shadowing Of A Local Variable</p>
<p>Because a declaration of an identifier as a local variable of a method, constructor, or initializer block must not appear within the scope of a parameter<strong>,</strong> <del>or</del> local variable<strong>, or pattern variable</strong> of the same name, a compile-time error occurs for the following program:</p>
<pre><code>class Test1 {
    public static void main(String[] args) {
        int i;
        for (int i = 0; i &lt; 10; i++)
            System.out.println(i);
    }
}</code></pre>
<p>This restriction helps to detect some otherwise very obscure bugs. A similar restriction on shadowing of members by local variables was judged impractical, because the addition of a member in a superclass could cause subclasses to have to rename local variables. Related considerations make restrictions on shadowing of local variables by members of nested classes, or on shadowing of local variables by local variables declared within nested classes unattractive as well.</p>
<p>Hence, the following program compiles without error:</p>
<pre><code>class Test2 {
    public static void main(String[] args) {
        int i;
        class Local {
            {
                for (int i = 0; i &lt; 10; i++)
                    System.out.println(i);
            }
        }
        new Local();
    }
}</code></pre>
<p>On the other hand, local variables with the same name may be declared in two separate blocks or <code>for</code> statements, neither of which contains the other:</p>
<pre><code>class Test3 {
    public static void main(String[] args) {
        for (int i = 0; i &lt; 10; i++)
            System.out.print(i + &quot; &quot;);
        for (int i = 10; i &gt; 0; i--)
            System.out.print(i + &quot; &quot;);
        System.out.println();
    }
}</code></pre>
<p>This program compiles without error and, when executed, produces the output:</p>
<pre><code>0 1 2 3 4 5 6 7 8 9 10 9 8 7 6 5 4 3 2 1</code></pre>
<div class="inserted">
<p>This style is also common with pattern matching, where repeated type test patterns often employ the same pattern name:</p>
<pre><code>class Test4 {
    class Point {
        int x, y;
    }
    public static void test(Object a, Object b, Object c) {
        if (a instanceof Point p) {
            System.out.print(&quot;a is a point (&quot; + p.x + &quot;, &quot; + p.y);
        }
        if (b instanceof Point p){
            System.out.print(&quot;b is a point (&quot; + p.x + &quot;, &quot; + p.y);
        } else if (c instanceof Point p) {
            System.out.print(&quot;c is a point (&quot; + p.x + &quot;, &quot; + p.y);
        }
        System.out.println();
    }
}</code></pre>
<p>However, pattern variables are not allowed to shadow other pattern variables; a compile-time error occurs for the following program:</p>
<pre><code>class Test5 {
    public static void test(Object a, Object b, Object c) {
        if (a instanceof Point p) {
            System.out.print(&quot;a is a point (&quot; + p.x + &quot;, &quot; + p.y);
            if (b instanceof Point p){
                System.out.print(&quot;b is a point (&quot; + p.x + &quot;, &quot; + p.y);
            }
        }
        System.out.println();
    }
}</code></pre>
<p>Pattern variables are, like local variables, not allowed to shadow local variables; a compile-time error occurs for the following program:</p>
<pre><code>class Test6 {
    class Point {
        int x, y;
        Point(int x, int y) {
            this.x = x;
            this.y = y;
        }
    }
    public static void test(Object o) {
        Point p = new Point(0,0);
        if (o instanceof Point p)
            System.out.println(&quot;I get your point&quot;);
    }
}</code></pre>
</div>
</div>
<h4 id="jls-6.4.1">6.4.1 Shadowing</h4>
<p>Some declarations may be <em>shadowed</em> in part of their scope by another declaration of the same name, in which case a simple name cannot be used to refer to the declared entity.</p>
<p>Shadowing is distinct from hiding (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.3">8.3</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.4.8.2">8.4.8.2</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.5">8.5</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-9.html#jls-9.3">9.3</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-9.html#jls-9.5">9.5</a>), which applies only to members which would otherwise be inherited but are not because of a declaration in a subclass. Shadowing is also distinct from obscuring (<a href="#jls-6.4.2">6.4.2</a>).</p>
<p>A declaration <em>d</em> of a type named <em>n</em> shadows the declarations of any other types named <em>n</em> that are in scope at the point where <em>d</em> occurs throughout the scope of <em>d</em>.</p>
<p>A declaration <em>d</em> of a field or formal parameter named <em>n</em> shadows, throughout the scope of <em>d</em>, the declarations of any other variables named <em>n</em> that are in scope at the point where <em>d</em> occurs.</p>
<p>A declaration <em>d</em> of a local variable<strong>, pattern variable,</strong> or exception parameter named <em>n</em> shadows, throughout the scope of <em>d</em>, (a) the declarations of any other fields named <em>n</em> that are in scope at the point where <em>d</em> occurs, and (b) the declarations of any other variables named <em>n</em> that are in scope at the point where <em>d</em> occurs but are <em>not</em> declared in the innermost class in which <em>d</em> is declared.</p>
<p>A declaration <em>d</em> of a method named <em>n</em> shadows the declarations of any other methods named <em>n</em> that are in an enclosing scope at the point where <em>d</em> occurs throughout the scope of <em>d</em>.</p>
<p>A package declaration never shadows any other declaration.</p>
<p>A type-import-on-demand declaration never causes any other declaration to be shadowed.</p>
<p>A static-import-on-demand declaration never causes any other declaration to be shadowed.</p>
<p>A single-type-import declaration <em>d</em> in a compilation unit <em>c</em> of package <em>p</em> that imports a type named <em>n</em> shadows, throughout <em>c</em>, the declarations of:</p>
<ul>
<li><p>any top level type named <em>n</em> declared in another compilation unit of <em>p</em></p></li>
<li><p>any type named <em>n</em> imported by a type-import-on-demand declaration in <em>c</em></p></li>
<li><p>any type named <em>n</em> imported by a static-import-on-demand declaration in <em>c</em></p></li>
</ul>
<p>A single-static-import declaration <em>d</em> in a compilation unit <em>c</em> of package <em>p</em> that imports a field named <em>n</em> shadows the declaration of any static field named <em>n</em> imported by a static-import-on-demand declaration in <em>c</em>, throughout <em>c</em>.</p>
<p>A single-static-import declaration <em>d</em> in a compilation unit <em>c</em> of package <em>p</em> that imports a method named <em>n</em> with signature <em>s</em> shadows the declaration of any static method named <em>n</em> with signature <em>s</em> imported by a static-import-on-demand declaration in <em>c</em>, throughout <em>c</em>.</p>
<p>A single-static-import declaration <em>d</em> in a compilation unit <em>c</em> of package <em>p</em> that imports a type named <em>n</em> shadows, throughout <em>c</em>, the declarations of:</p>
<ul>
<li><p>any static type named <em>n</em> imported by a static-import-on-demand declaration in <em>c</em>;</p></li>
<li><p>any top level type (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-7.html#jls-7.6">7.6</a>) named <em>n</em> declared in another compilation unit (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-7.html#jls-7.3">7.3</a>) of <em>p</em>;</p></li>
<li><p>any type named <em>n</em> imported by a type-import-on-demand declaration (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-7.html#jls-7.5.2">7.5.2</a>) in <em>c</em>.</p></li>
</ul>
<div class="example">
<p>Example 6.4.1-1. Shadowing of a Field Declaration by a Local Variable Declaration</p>
<pre><code>class Test {
    static int x = 1;
    public static void main(String[] args) {
        int x = 0;
        System.out.print(&quot;x=&quot; + x);
        System.out.println(&quot;, Test.x=&quot; + Test.x);
    }
}</code></pre>
<p>This program produces the output:</p>
<pre><code>x=0, Test.x=1</code></pre>
<p>This program declares:</p>
<ul>
<li><p>a class <code>Test</code></p></li>
<li><p>a class (<code>static</code>) variable <code>x</code> that is a member of the class <code>Test</code></p></li>
<li><p>a class method <code>main</code> that is a member of the class <code>Test</code></p></li>
<li><p>a parameter <code>args</code> of the <code>main</code> method</p></li>
<li><p>a local variable <code>x</code> of the <code>main</code> method</p></li>
</ul>
<p>Since the scope of a class variable includes the entire body of the class (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.2">8.2</a>), the class variable <code>x</code> would normally be available throughout the entire body of the method <code>main</code>. In this example, however, the class variable <code>x</code> is shadowed within the body of the method <code>main</code> by the declaration of the local variable <code>x</code>.</p>
<p>A local variable has as its scope the rest of the block in which it is declared (<a href="#jls-6.3">6.3</a>); in this case this is the rest of the body of the <code>main</code> method, namely its initializer &quot;<code>0</code>&quot; and the invocations of <code>System.out.print</code> and <code>System.out.println</code>.</p>
<p>This means that:</p>
<ul>
<li><p>The expression <code>x</code> in the invocation of <code>print</code> refers to (denotes) the value of the local variable <code>x</code>.</p></li>
<li><p>The invocation of <code>println</code> uses a qualified name (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-6.html#jls-6.6">6.6</a>) <code>Test.x</code>, which uses the class type name <code>Test</code> to access the class variable <code>x</code>, because the declaration of <code>Test.x</code> is shadowed at this point and cannot be referred to by its simple name.</p></li>
</ul>
<p>The keyword <code>this</code> can also be used to access a shadowed field <code>x</code>, using the form <code>this.x</code>. Indeed, this idiom typically appears in constructors (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.8">8.8</a>):</p>
<pre><code>class Pair {
    Object first, second;
    public Pair(Object first, Object second) {
        this.first = first;
        this.second = second;
    }
}</code></pre>
<p>Here, the constructor takes parameters having the same names as the fields to be initialized. This is simpler than having to invent different names for the parameters and is not too confusing in this stylized context. In general, however, it is considered poor style to have local variables with the same names as fields.</p>
</div>
<div class="example">
<p>Example 6.4.1-2. Shadowing of a Type Declaration by Another Type Declaration</p>
<pre><code>import java.util.*;
class Vector {
    int val[] = { 1 , 2 };
}

class Test {
    public static void main(String[] args) {
        Vector v = new Vector();
        System.out.println(v.val[0]);
    }
}</code></pre>
<p>The program compiles and prints:</p>
<pre><code>1</code></pre>
<p>using the class <code>Vector</code> declared here in preference to the generic class <code>java.util.Vector</code> (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.1.2">8.1.2</a>) that might be imported on demand.</p>
</div>
<h3 id="jls-6.5">6.5 Determining the Meaning of a Name</h3>
<h4 id="jls-6.5.1">6.5.1 Syntactic Classification of a Name According to Context</h4>
<p>...</p>
<p>A name is syntactically classified as an <em>ExpressionName</em> in these contexts:</p>
<ul>
<li><p>As the qualifying expression in a qualified superclass constructor invocation (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.8.7.1">8.8.7.1</a>)</p></li>
<li><p>As the qualifying expression in a qualified class instance creation expression (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.9">15.9</a>)</p></li>
<li><p>As the array reference expression in an array access expression (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.10.3">15.10.3</a>)</p></li>
<li><p>As a <em>PostfixExpression</em> (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.14">15.14</a>)</p></li>
<li><p>As the left-hand operand of an assignment operator (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.26">15.26</a>)</p></li>
<li><p><strong>As a <em>PatternVariable</em> in a pattern (<a href="#jls-14.30">14.30</a>)</strong></p></li>
<li><p>As a <em>VariableAccess</em> in a <code>try</code>-with-resources statement (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-14.html#jls-14.20.3">14.20.3</a>)</p></li>
</ul>
<p>...</p>
<h4 id="jls-6.5.2">6.5.2 Reclassification of Contextually Ambiguous Names</h4>
<p>An <em>AmbiguousName</em> is then reclassified as follows.</p>
<p>If the <em>AmbiguousName</em> is a simple name, consisting of a single <em>Identifier</em>:</p>
<ul>
<li><p>If the <em>Identifier</em> appears within the scope (<a href="#jls-6.3">6.3</a>) of a local variable declaration (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-14.html#jls-14.4">14.4</a>)<strong>, pattern variable declaration (<a href="#jls-14.30.1">14.30.1</a>),</strong> <del>or</del> parameter declaration (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.4.1">8.4.1</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.8.1">8.8.1</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-14.html#jls-14.20">14.20</a>)<strong>,</strong> or field declaration (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.3">8.3</a>) with that name, then the <em>AmbiguousName</em> is reclassified as an <em>ExpressionName</em>.</p></li>
<li><p>Otherwise, if a field of that name is declared in the compilation unit (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-7.html#jls-7.3">7.3</a>) containing the <em>Identifier</em> by a single-static-import declaration (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-7.html#jls-7.5.3">7.5.3</a>), or by a static-import-on-demand declaration (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-7.html#jls-7.5.4">7.5.4</a>) then the <em>AmbiguousName</em> is reclassified as an <em>ExpressionName</em>.</p></li>
<li><p>Otherwise, if the <em>Identifier</em> is a valid <em>TypeIdentifier</em> and appears within the scope (<a href="#jls-6.3">6.3</a>) of a top level class (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html">8</a>) or interface type declaration (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-9.html">9</a>), a local class declaration (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-14.html#jls-14.3">14.3</a>) or member type declaration (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.5">8.5</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-9.html#jls-9.5">9.5</a>) with that name, then the <em>AmbiguousName</em> is reclassified as a <em>TypeName</em>.</p></li>
<li><p>Otherwise, if the <em>Identifier</em> is a valid <em>TypeIdentifier</em> and a type of that name is declared in the compilation unit (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-7.html#jls-7.3">7.3</a>) containing the <em>Identifier</em>, either by a single-type-import declaration (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-7.html#jls-7.5.1">7.5.1</a>), or by a type-import-on-demand declaration (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-7.html#jls-7.5.2">7.5.2</a>), or by a single-static-import declaration (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-7.html#jls-7.5.3">7.5.3</a>), or by a static-import-on-demand declaration (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-7.html#jls-7.5.4">7.5.4</a>), then the <em>AmbiguousName</em> is reclassified as a <em>TypeName</em>.</p></li>
<li><p>Otherwise, the <em>AmbiguousName</em> is reclassified as a <em>PackageName</em>. A later step determines whether or not a package of that name actually exists.</p></li>
</ul>
<p>...</p>
<h4 id="jls-6.5.6">6.5.6 Meaning of Expression Names</h4>
<h5 id="jls-6.5.6.1">6.5.6.1 Simple Expression Names</h5>
<p>If an expression name consists of a single <em>Identifier</em>, then there must be exactly one declaration denoting either a local variable, formal parameter, or field in scope at the point at which the <em>Identifier</em> occurs. Otherwise, a compile-time error occurs.</p>
<p>If the declaration denotes an instance variable (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.3.1.1">8.3.1.1</a>), the expression name must appear within an instance method (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.4.3.2">8.4.3.2</a>), instance variable initializer (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.3.2">8.3.2</a>), instance initializer (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.6">8.6</a>), or constructor (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.8">8.8</a>). If the expression name appears within a class method, class variable initializer, or static initializer (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.7">8.7</a>), then a compile-time error occurs.</p>
<p>If the declaration declares a <code>final</code> variable which is definitely assigned before the simple expression, the meaning of the name is the value of that variable. Otherwise, the meaning of the expression name is the variable declared by the declaration.</p>
<p>If the expression name appears in an assignment context, invocation context, or casting context, then the type of the expression name is the declared type of the field, local variable, <strong>pattern variable,</strong> or parameter after capture conversion (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-5.html#jls-5.1.10">5.1.10</a>).</p>
<p>Otherwise, the type of the expression name is the declared type of the field, local variable<strong>, pattern variable,</strong> or parameter.</p>
<blockquote>
<p>That is, if the expression name appears &quot;on the right hand side&quot;, its type is subject to capture conversion. If the expression name is a variable that appears &quot;on the left hand side&quot;, its type is not subject to capture conversion.</p>
</blockquote>
<div class="example">
<p>Example 6.5.6.1-1. Simple Expression Names</p>
<pre><code>class Test {
    static int v;
    static final int f = 3;
    public static void main(String[] args) {
        int i;
        i = 1;
        v = 2;
        f = 33;  // compile-time error
        System.out.println(i + &quot; &quot; + v + &quot; &quot; + f);
    }
}</code></pre>
<p>In this program, the names used as the left-hand-sides in the assignments to <code>i</code>, <code>v</code>, and <code>f</code> denote the local variable <code>i</code>, the field <code>v</code>, and the value of <code>f</code> (not the variable <code>f</code>, because <code>f</code> is a <code>final</code> variable). The example therefore produces an error at compile time because the last assignment does not have a variable as its left-hand side. If the erroneous assignment is removed, the modified code can be compiled and it will produce the output:</p>
<pre><code>1 2 3</code></pre>
</div>
<h2 id="jls-9">Chapter 9: Interfaces</h2>
<h3 id="jls-9.6">9.6 Annotation Types</h3>
<h4 id="jls-9.6.4">9.6.4 Predefined Annotation Types</h4>
<h5 id="jls-9.6.4.1">9.6.4.1 <code>@Target</code></h5>
<p>An annotation of type <code>java.lang.annotation.Target</code> is used on the declaration of an annotation type <em>T</em> to specify the contexts in which <em>T</em> is <em>applicable</em>. <code>java.lang.annotation.Target</code> has a single element, <code>value</code>, of type <code>java.lang.annotation.ElementType[]</code>, to specify contexts.</p>
<p>Annotation types may be applicable in <em>declaration contexts</em>, where annotations apply to declarations, or in <em>type contexts</em>, where annotations apply to types used in declarations and expressions.</p>
<p>There are nine declaration contexts, each corresponding to an enum constant of <code>java.lang.annotation.ElementType</code>:</p>
<ol type="1">
<li><p>Module declarations (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-7.html#jls-7.7">7.7</a>)</p>
<p>Corresponds to <code>java.lang.annotation.ElementType.MODULE</code></p></li>
<li><p>Package declarations (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-7.html#jls-7.4.1">7.4.1</a>)</p>
<p>Corresponds to <code>java.lang.annotation.ElementType.PACKAGE</code></p></li>
<li><p>Type declarations: class, interface, enum, and annotation type declarations (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.1.1">8.1.1</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-9.html#jls-9.1.1">9.1.1</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.5">8.5</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-9.html#jls-9.5">9.5</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.9">8.9</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-9.html#jls-9.6">9.6</a>)</p>
<p>Corresponds to <code>java.lang.annotation.ElementType.TYPE</code></p>
<p>Additionally, annotation type declarations correspond to <code>java.lang.annotation.ElementType.ANNOTATION_TYPE</code></p></li>
<li><p>Method declarations (including elements of annotation types) (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.4.3">8.4.3</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-9.html#jls-9.4">9.4</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-9.html#jls-9.6.1">9.6.1</a>)</p>
<p>Corresponds to <code>java.lang.annotation.ElementType.METHOD</code></p></li>
<li><p>Constructor declarations (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.8.3">8.8.3</a>)</p>
<p>Corresponds to <code>java.lang.annotation.ElementType.CONSTRUCTOR</code></p></li>
<li><p>Type parameter declarations of generic classes, interfaces, methods, and constructors (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.1.2">8.1.2</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-9.html#jls-9.1.2">9.1.2</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.4.4">8.4.4</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.8.4">8.8.4</a>)</p>
<p>Corresponds to <code>java.lang.annotation.ElementType.TYPE_PARAMETER</code></p></li>
<li><p>Field declarations (including enum constants) (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.3.1">8.3.1</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-9.html#jls-9.3">9.3</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.9.1">8.9.1</a>)</p>
<p>Corresponds to <code>java.lang.annotation.ElementType.FIELD</code></p></li>
<li><p>Formal and exception parameter declarations (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.4.1">8.4.1</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-9.html#jls-9.4">9.4</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-14.html#jls-14.20">14.20</a>)</p>
<p>Corresponds to <code>java.lang.annotation.ElementType.PARAMETER</code></p></li>
<li><p>Local variable declarations (including loop variables of <code>for</code> statements<strong>,</strong> <del>and</del> resource variables of <code>try</code>-with-resources statements<strong>, and pattern variables</strong>) (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-14.html#jls-14.4">14.4</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-14.html#jls-14.14.1">14.14.1</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-14.html#jls-14.14.2">14.14.2</a>, <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-14.html#jls-14.20.3">14.20.3</a><strong>, <a href="#jls-15.20.2">15.20.2</a></strong>)</p>
<p>Corresponds to <code>java.lang.annotation.ElementType.LOCAL_VARIABLE</code></p></li>
</ol>
<p>There are 16 type contexts (<a href="#jls-4.11">4.11</a>), all represented by the enum constant <code>TYPE_USE</code> of <code>java.lang.annotation.ElementType</code>.</p>
<p>It is a compile-time error if the same enum constant appears more than once in the <code>value</code> element of an annotation of type <code>java.lang.annotation.Target</code>.</p>
<p>If an annotation of type <code>java.lang.annotation.Target</code> is not present on the declaration of an annotation type <em>T</em>, then <em>T</em> is applicable in all declaration contexts except type parameter declarations, and in no type contexts.</p>
<blockquote>
<p>These contexts are the syntactic locations where annotations were allowed in Java SE 7.</p>
</blockquote>
<h2 id="jls-14">Chapter 14: <del>Blocks and</del> Statements <strong>and Patterns</strong></h2>
<div class="editorial">
<p>Sections 14.22-14.29 are left deliberately unused to allow for future language evolution.</p>
</div>
<h3 id="jls-14.30"><strong>14.30 Patterns</strong></h3>
<div class="inserted">
<p>A pattern describes the shape of data. Pattern matching is the process of comparing a value against a pattern and determining whether the value matches the pattern or not. A pattern may in addition declare <!--a set of _pattern
variables_ --> a <em>pattern variable</em> to name <!--various components --> a component of the shape. If a value matches against a pattern, then <!--these variables are assigned values--> this variable is assigned a value by the process of pattern matching. The treatment of scoping of pattern variables in <a href="#jls-6.3.1">6.3.1</a> ensures that pattern variables are only in scope where matching is guaranteed to have succeeded and hence the pattern variable will be bound with a value at run-time.</p>
</div>
<h4 id="jls-14.30.1"><strong>14.30.1 Kinds of Patterns</strong></h4>
<div class="inserted">
<!---
> _Pattern_:
 : _ConstantPattern_
 : _NullPattern_
 : _TypeTestPattern_
 : _RecordPattern_
-->
<blockquote>
<dl>
<dt><em>Pattern</em>:</dt>
<dd><em>TypeTestPattern</em>
</dd>
</dl>
</blockquote>
</div>
<h5 id="jls-14.30.1.1"><strong>14.30.1.1 Type Test Pattern</strong></h5>
<div class="inserted">
<blockquote>
<dl>
<dt><em>TypeTestPattern</em>:</dt>
<dd><em>ReferenceType</em> <em>Identifier</em>
</dd>
</dl>
</blockquote>
<p>A <em>type test pattern</em> consists of a type and a pattern variable. It is a compile-time error if the type does not denote a reference type (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-4.html#jls-4.3">4.3</a>).</p>
<!--A type test pattern without an _Identifier_ is called an _anonymous_ type
test pattern.-->
<p>The type of a type test pattern is the <em>ReferenceType</em>.</p>
<p>A type test pattern is said to <em>declare</em> the pattern variable <em>Identifier</em>. The scope of that pattern variable <em>Identifier</em> is conditional on the context, as defined in <a href="#jls-6.3">6.3</a>. The type of the pattern variable <em>Identifier</em> is defined to be <em>ReferenceType</em>.</p>
</div>
<!---
### 14.30.1.2 Constant Patterns

> _ConstantPattern_:
 : _CaseConstant_

A constant pattern must be either a constant expression ([15.28]) or the
name of an enum constant, or a compile-time error occurs.

The type of a constant pattern is the type of the _CaseConstant_.

A constant pattern declares an empty set of pattern variables.

### 14.30.1.3 Null Patterns

> _NullPattern_:
 : `null`

A null pattern is just the `null` literal.

A null pattern declares an empty set of pattern variables.

### 14.30.1.4 Record Patterns

> _RecordPattern_:
 : _ReferenceType_ `(` _{_ _PatternArgument_ _}_ `)`  

> _PatternArgument_:
 : _Pattern_
 : `var` _Identifier_
 : `_`

The type of a record pattern is the _ReferenceType_. If the
_ReferenceType_ is not a record type, then a compile-time error
occurs.

A record pattern declares the union of the sets of pattern variables that are declared by its pattern arguments. It is a compile-time error if the sets of pattern variables declared by the pattern arguments are not disjoint.

<div class="editorial">
  There is a linearity constraint on pattern arguments. A pattern such as `Point(var x, var x)` is illegal.
</div>

The pattern argument `var x` declares the set containing the pattern variable `x`. The
pattern argument '`_`' is called a _match-all_ pattern argument, and declares an empty set of pattern variables.

<div class="editorial">
Record patterns can declare multiple pattern variables; for example, the record pattern `Point(var x, var y)` declares a set containing the two pattern variables `x` and `z`. Record patterns introduce the ability to compose, or _nest_ patterns; for example, in the pattern `Rectangle(Point(var x, var y), _)`.
</div>

-->
<h4 id="jls-14.30.2"><strong>14.30.2 Compatibility of an Expression with a Pattern</strong></h4>
<!--
    |- e ~ p
-->
<div class="inserted">
<p>An expression is <em>compatible</em> with a pattern as follows:</p>
<!--
- The `null` literal is compatible with the null pattern.
-->
<ul>
<li>The <code>null</code> literal is compatible with a type test pattern.</li>
</ul>
<!--
- An expression that is not the `null` literal is compatible with a
  constant pattern if the type of the expression is assignment
  convertible to the type of the constant pattern.

- An expression that is not the `null` literal is compatible with a
  null pattern if the type of the expression is a reference type.
-->
<ul>
<li>An expression that is not the <code>null</code> literal is compatible with a type test pattern of type <em>T</em> if (i) the expression can be converted to type <em>T</em> by casting conversion (<a href="#jls-5.5">5.5</a>), and (ii) the casting conversion does not make use of a narrowing reference conversion which is unchecked (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-5.html#jls-5.1.6.2">5.1.6.2</a>).</li>
</ul>
<!--
- An expression that is not the `null` literal is compatible with a
  record pattern if the type of the expression is equal to the type of
  the record pattern.
-->
<p>At compile time, the <code>instanceof</code> operator (<a href="#jls-15.20.2">15.20.2</a>) checks compatibility of its first operand, an expression, with the type of its second operand.</p>
<!-- *TODO: Think about boxing?* -->
</div>
<!--
## 14.30.4 Dominance between patterns

- A pattern that is not the `null` pattern dominates the `null`
  pattern.
- A pattern that is not a constant pattern dominates a constant pattern.
- A record pattern D(a1, ...) dominates a record pattern D(a1, ...)
  ...
- A pattern _P1_ of type _T1_ dominates another pattern _P2_ of type
  _T2_, if _T1_ is equal to _T2_ or _T1_ is a supertype of _T2_.
- A pattern argument `var x` dominates any other pattern argument.
- A match-all pattern argument '`_`' dominates any other pattern
  argument.
-->
<h4 id="jls-14.30.3"><strong>14.30.3 Execution of Pattern Matching</strong></h4>
<div class="inserted">
<p>At run time, a value is matched against a pattern. If the value matches the pattern, then additionally values may be assigned to any pattern variables declared in the pattern. The rules for determining whether a value matches a pattern (or not) are as follows:</p>
<!--
- The result of matching a value, `v` against a constant pattern, `c`
  is determined as follows:
  - If the type of the pattern is either the numeric type `float`, or
    `double`, then *TODO*.
  - If the type of the pattern is a numeric type other than `float`
    and `double`, then `v` matches `c` if the value of the expression
    `c == v` is `true` (using the numeric equality operator `==`
    [15.21.1]); and does not match otherwise.
  - If the type of the pattern is `String`, then `v` matches `c` if
    the value of the expression `c.equals(v)` is `true`; and does not
    match otherwise.
  - !!!Enum constants!
- The null reference value matches the null pattern.
- A value of reference type that is not the null reference value does
  not match the null pattern.
-->
<ul>
<li>The null reference value does not match a type test pattern.</li>
</ul>
<!--- A value of reference type that is not the null reference value
  matches an anonymous type test pattern `T` if the value could be
  cast to `T` without raising a `ClassCastException`; and it does
  not match otherwise.-->
<ul>
<li>A value of reference type that is not the null reference value matches a type test pattern <code>T t</code> if the value could be cast to <code>T</code> without raising a <code>ClassCastException</code>, in which case the value is assigned to the pattern variable <code>t</code>; and it does not match otherwise.</li>
</ul>
<!--
- The null reference value does not match a record pattern.
- A value of record type matches a record pattern `R(a1,...,an)` is if
  the value could be cast to `R` without raising a
  `ClassCastException`, and the components of the value match against
  the pattern arguments `a1`, ..., `an`; and does not match otherwise.
- A value matches a pattern argument `var x`, in which case the value
  is assigned to the pattern variable `x`.
- A value matches a match-all pattern argument '`_`'.
-->
<p>All other possibilities are excluded by the compile time type-checking of pattern matching.</p>
</div>
<h2 id="jls-15">Chapter 15: Expressions</h2>
<h3 id="jls-15.20">15.20 Relational Operators</h3>
<p>The numerical comparison operators <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, and <code>&gt;=</code>, and the <code>instanceof</code> operator, are called the <em>relational operators</em>.</p>
<dl>
<dt><em>RelationalExpression:</em></dt>
<dd><em>ShiftExpression</em>
</dd>
<dd><em>RelationalExpression</em> <code>&lt;</code> <em>ShiftExpression</em>
</dd>
<dd><em>RelationalExpression</em> <code>&gt;</code> <em>ShiftExpression</em>
</dd>
<dd><em>RelationalExpression</em> <code>&lt;=</code> <em>ShiftExpression</em>
</dd>
<dd><em>RelationalExpression</em> <code>&gt;=</code> <em>ShiftExpression</em>
</dd>
<dd><em>RelationalExpression</em> <code>instanceof</code> <del><em>ReferenceType</em></del> <strong><em>ReferenceTypeOrPattern</em></strong>
</dd>
</dl>
<p><strong>Patterns are defined in <a href="#jls-14.30">14.30</a>.</strong></p>
<p>The relational operators are syntactically left-associative (they group left-to-right).</p>
<blockquote>
<p>However, this fact is not useful. For example, <code>a&lt;b&lt;c</code> parses as <code>(a&lt;b)&lt;c</code>, which is always a compile-time error, because the type of <code>a&lt;b</code> is always <code>boolean</code> and &lt; is not an operator on <code>boolean</code> values.</p>
</blockquote>
<p>The type of a relational expression is always <code>boolean</code>.</p>
<h4 id="jls-15.20.2">15.20.2 <del>Type Comparison Operator <code>instanceof</code></del> <strong>The <code>instanceof</code> Operator</strong></h4>
<div class="deleted">
<p>The type of the <em>RelationalExpression</em> operand of the <code>instanceof</code> operator must be a reference type or the null type, or a compile-time error occurs.</p>
<p>It is a compile-time error if the <em>ReferenceType</em> mentioned after the <code>instanceof</code> operator does not denote a reference type that is reifiable (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-4.html#jls-4.7">4.7</a>).</p>
<p>If a cast of the <em>RelationalExpression</em> to the <em>ReferenceType</em> would be rejected as a compile-time error (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-15.html#jls-15.16">15.16</a>), then the <code>instanceof</code> relational expression likewise produces a compile-time error. In such a situation, the result of the <code>instanceof</code> expression could never be true.</p>
<p>At run time, the result of the <code>instanceof</code> operator is <code>true</code> if the value of the <em>RelationalExpression</em> is not <code>null</code> and the reference could be cast to the <em>ReferenceType</em> without raising a <code>ClassCastException</code>. Otherwise the result is <code>false</code>.</p>
</div>
<div class="inserted">
<!-- The `instanceof` operator compares the value of the _RelationalExpression_
with the *ReferenceTypeOrPattern* operand, which is either a *ReferenceType* or
a *Pattern*.-->
<dl>
<dt><em>ReferenceTypeOrPattern</em>:</dt>
<dd><em>ReferenceType</em>
</dd>
<dd><em>Pattern</em>
</dd>
</dl>
<p>An <code>instanceof</code> operator has one of two forms: (i) a <em>type</em> <code>instanceof</code> operator, where the <em>ReferenceTypeOrPattern</em> operand is a <em>ReferenceType</em>; or (ii) a <em>pattern</em> <code>instanceof</code> operator, where the <em>ReferenceTypeOrPattern</em> operand is a <em>Pattern</em>.</p>
<p>The following applies to a type <code>instanceof</code> operator:</p>
<ul>
<li><p>The type of the <em>RelationalExpression</em> operand of the type <code>instanceof</code> operator must be a reference type or the null type, or a compile-time error occurs.</p></li>
<li><p>The expression <em>RelationalExpression</em> is compatible with the type <em>ReferenceType</em> if (i) <em>RelationalExpression</em> can be converted to type <em>ReferenceType</em> by casting conversion (<a href="#jls-5.5">5.5</a>), and (ii) the casting conversion does not make use of a narrowing reference conversion which is unchecked (<a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-5.html#jls-5.1.6.2">5.1.6.2</a>). If <em>ReferenceType</em> is not compatible with <em>ReferenceType</em> then a compile-time error occurs.</p></li>
<li><p>At run time, the result of the <code>instanceof</code> operator is <code>true</code> if the value of the <em>RelationalExpression</em> is not <code>null</code> and the reference could be cast to the <em>ReferenceType</em> without raising a <code>ClassCastException</code>. Otherwise the result is <code>false</code>.</p></li>
</ul>
<p>The following applies to a pattern <code>instanceof</code> operator:</p>
<!--  -  A pattern `instanceof` operator matches the value of the
  _RelationalExpression_ against the _Pattern_. -->
<ul>
<li><p>The type of the <em>RelationalExpression</em> operand of the pattern <code>instanceof</code> operator must be a reference type or the null type, or a compile-time error occurs.</p></li>
<li><p>The <em>RelationalExpression</em> operand of a pattern <code>instanceof</code> operator must be compatible with the <em>Pattern</em> operand as defined in <a href="#jls-14.30.2">14.30.2</a>; otherwise, a compile-time error occurs.</p></li>
<li><p>At run time, the value of the <em>RelationalExpression</em> is matched against the <em>Pattern</em>, as detailed in <a href="#jls-14.30.3">14.30.3</a>. If it matches then the result of the pattern <code>instanceof</code> operator is <code>true</code>, otherwise the result of the pattern <code>instanceof</code> operator is <code>false</code></p></li>
</ul>
</div>
<div class="example">
<p>Example 15.20.2-1. The <strong>type</strong> <code>instanceof</code> Operator</p>
<pre><code>class Point   { int x, y; }
class Element { int atomicNumber; }
class Test {
    public static void main(String[] args) {
        Point   p = new Point();
        Element e = new Element();
        if (e instanceof Point) {  // compile-time error
            System.out.println(&quot;I get your point!&quot;);
            p = (Point)e;  // compile-time error
        }
    }
}</code></pre>
<p>This program results in two compile-time errors. The cast <code>(Point)e</code> is incorrect because no instance of <code>Element</code> or any of its possible subclasses (none are shown here) could possibly be an instance of any subclass of <code>Point</code>. The <code>instanceof</code> expression is incorrect for exactly the same reason. If, on the other hand, the class <code>Point</code> were a subclass of <code>Element</code> (an admittedly strange notion in this example):</p>
<pre><code>class Point extends Element { int x, y; }</code></pre>
<p>then the cast would be possible, though it would require a run-time check, and the <code>instanceof</code> expression would then be sensible and valid. The cast <code>(Point)e</code> would never raise an exception because it would not be executed if the value of <code>e</code> could not correctly be cast to type <code>Point</code>.</p>
</div>
</main><footer class="legal-footer"><hr/><a href="../legal/copyright.html">Copyright</a> &copy; 1993, 2020, Oracle and/or its affiliates, 500 Oracle Parkway, Redwood Shores, CA 94065 USA.<br>All rights reserved. Use is subject to <a href="https://www.oracle.com/technetwork/java/javase/terms/license/java14.0.2speclicense.html">license terms</a> and the <a href="https://www.oracle.com/technetwork/java/redist-137594.html">documentation redistribution policy</a>. <!-- Version 14.0.2+12-46 --></footer>
</body>
</html>