---
layout: post
author: LIU,HONGYANG
tags: [数据结构与算法]
---





马拉车算法是用来求最长回文子串的一种算法，它的优点在于能够将求最长回文子串的算法时间降低到线性级别。



算法主要分为两部分，

-  第一部分是，字符串预处理，消除字符串的奇偶性；
- 第二部分是，构建辅助数组;
- 第三部分是，得到回文串起始位置；





##### 第一部分：

在第一部分，我们需要消除字符串奇偶性带来的影响，所以需要在数组中间插入"#"

对于奇数数组，"aba"，转换后为"#a#b#a#"，变成了奇数

对于偶数数组，"effe"，转换后为"#e#f#f#e#"，也变成了奇数



其次，我们需要计算一个最长回文子串长度，

```
i       0 1 2 3 4 5 6 7 8 9 10 11 12
arr[i]  # c # a # b # b # a #  f  #
p[i]    1 2 1 2 1 2 5 2 1 2 1  2  1
```

由上图可以发现， 最长回文子串的长度等于最长半径回文半径减1

比如abba中，以#为中心，对应的半径为5而最长回文串为abba，它的半径为4

4就是原字符串的最长回文子串的长度。

**int maxLength = p[i] - 1**



##### 第二部分：



然后我们需要计算回文串的起始索引，这样知道了起始索引，知道了最长回文串的长度就可以截取除最长回文串啦。



为了方便查找，我们需要在数组的头部和尾端分别加上一个@和 $，注意这个两个字符不能与最长回文串的字符一样。

为什么需要加上$和@呢？

这是因为如果不加上的话，会有一个数组下标越界的问题，



比如：

“cabbaf”中p[6] = 5，当我们用i - p[6]时，6- 5 = 1,即回文串的起始位置在原数字符串中是1，没问题，符合！

再来看看奇数，如下，"aba"中p[3] =  4， i - p[3]时， 3 - 4 = -1，数组下标越界



```java
i       0 1 2 3 4 5 6 
arr[i]  # a # b # a #  
p[i]    1 2 1 4 1 2 1
```



为了解决数组下标越界这个问题，我们需要在加上$和@，加$是为了防止数组下标越界，加@是为了维持字符串长度为奇数。



加上之后如下，

```java
i       0 1 2 3 4 5 6 7 8 9 10 11 12 13 14
arr[i]  $ # c # a # b # b # a  #  f  #  @
p[i]      1 2 1 2 1 2 5 2 1 2  1  2  1
```



我们再来看看，p[7] = 5, 7 - p[7] = 2，而在原数组中，我们是从1开始的，所以需要除以2.



```java
i       0 1 2 3 4 5 6 7 8
arr[i]  $ # a # b # a # @ 
p[i]      1 2 1 4 1 2 1
```

再来看看奇数字符串，p[4] = 4, 4 - 4 = 0, 再除以2，没问题。



综上所述，回文数的起始索引等于**int index = ( i - p[i]) /2**



需要注意的是，最长回文串的最大长度和起始索引都是相对于原来的字符串而言的。

##### 

好了，现在我们知道了最长回文串的起始索引和最长半径，再使用公式就可以 **s.substring(start, start + maxLength);** 返回最长回文串啦。



##### 第三部分：



这部分也是最重要的一部分，那就是，如何求出辅助数组p[i],  用来存放最长回文半径，这是最关键的，

我们首先需要定义两个变量，

- id表示所有回文子串中，能够延伸到最右端的回文子串的中心点位置
- mx是该回文子串的右边界位置。



总之，我们这么理解，id表示最后结果的中心点，比如 "caabbaf"中的7，而mx = 12.



```java
i       0 1 2 3 4 5 6 7 8 9 10 11 12 13 14
arr[i]  $ # c # a # b # b # a  #  f  #  @
p[i]      1 2 1 2 1 2 5 2 1 2  1  2  1
```



当然，由于事先你不知道这两个值，所以我们需要设置它们为0，然后动态的寻找这两个值。

还要说一个变量i, i表示当前索引



所以，所有的情况一共分为三种，

第一种：mx > i , 且以i为中心的子串，包含在以mx内。 那么以 id 为中心，一定存在j, 是的i 和 j 关于 id对称，而此时有一个关系是，i和j以id为中心的半径相等所以j = 2* id - i, 那么p[j] = p[2*id-i]



第二种：mx> i,那么以i为中心的子串，超过mx。在这种情况下，我们可以分为两部分，第一部分是，我们依然可以找到j，那么i到mx的距离和 j到 **与mx对称**点的距离，一定是相同的。所以p[i] =  mx - i, p [j] = p[i]; 

而，对于超出mx的部分，我们需要更新p[j]++的值，如何更新呢？

```java
while(t.charAt(j+p[j])==t.charAt(j-p[j])){
        p[j] ++ ;
}
```

如下所示，不断迭代即可。

此时，最右边界继续扩展，因为以前的mx已经不再适用了，我们需要更新id和mx的值。



```java
	if(mx<p[j]+j){
        mx = p[j] + j;
        id = j;
   }
```







![Screenshot 2020-07-21 at 16.41.58](https://tva1.sinaimg.cn/large/007S8ZIlgy1ggyoplnnyaj315o0nyn98.jpg)





因此，在`mx > i`的情况下，`p[i] = Math.min(p[2*id - i], mx - i)`。



第三种，就是 i > mx的情况，在这种情况下，和第二种情况中第二部分实际上是一样的，都是右边界超过mx，此时需要继续遍历，更新边界情况。（另外如果i大于mx了，也即是边界mx后面的子串，依旧需要去比较字符计算。）



综上所述，代码如下：



```java
public String Manacher(String s){
	if(s.length()<2){
		return s;
	}
	
  //第一部分
	String t="$";
	for(int i=0;i<s.length();i++){
		t+="#" + s.charAt(i);
	}
  
  t+="#@";
  
  //第二部分，计算辅助数组，最长回文半径和起始索引。
 
  //n数组长度，id:回文串中心点位置，mx是最右端的位置
  int n = t.length();
  int[] p = new int[n];
  int id = 0,mx = 0;
  
  //最长回文串的起始位置和最大长度
  int index = 0;
  int maxLength = 0;
  for(int i=1;i<n-1;i++){
  		p[i] = mx > i?Math.min(p[2*id-i],mx-i):1;
    	//向两边扩展
    	while(t.charAt(i+p[i])==t.charAt(i-p[i])){
        p[i] ++ ;
      }
    
    	//如果回文子串的右边界超过了mx,则更新id和mx
    	if(mx<p[i]+i){
        mx = p[i] + i;
        id = i;
      }
    
    	//如果回文子串的长度大于maxLength,则更新maxLength以及index的值
    	if(maxLength<p[i]-1){
        maxLength = p[i]-1;
        index = i;
      }
    
  }
  
  //第三步，计算起始索引的位置
  int start = (index-maxLength)/2;
  return s.substring(start,start+maxLength);
  
}
```







##### References:



https://www.jianshu.com/p/392172762e55